CCS PCH C Compiler, Version 4.106, 39453               08-mai-12 15:41

               Filename: D:\Fichiers_Divers\DataPic\Lect_SD_Card\Lect_sd_4550.lst

               ROM used: 8518 bytes (26%)
                         Largest free fragment is 24250
               RAM used: 261 (13%) at main() level
                         362 (18%) worst case
               Stack:    6 locations

*
0000:  GOTO   2104
.................... //----------------------------------------------------- 
.................... //------------ Programme Sendp data capt -------------- 
.................... //----------------------------------------------------- 
.................... //-- Projet:                                         -- 
.................... //-- Date:   10-10-2011                              -- 
.................... //-- Progr:  Send data in serie 				     -- 
.................... //-- Auteur: Binon Daniel (UMONS)					 -- 
.................... //----------------------------------------------------- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //-----------------------------------------------------  
....................  
.................... #include "4550_sv3_scan.h" 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
....................  
.................... #device ADC=10		// adc en mode résolution 10 bits 
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,VREGEN 
.................... #use delay(clock=20M) 
*
023A:  MOVLW  01
023C:  MOVWF  FEA
023E:  MOVLW  3E
0240:  MOVWF  FE9
0242:  MOVF   FEF,W
0244:  BZ    0260
0246:  MOVLW  06
0248:  MOVWF  01
024A:  CLRF   00
024C:  DECFSZ 00,F
024E:  BRA    024C
0250:  DECFSZ 01,F
0252:  BRA    024A
0254:  MOVLW  7B
0256:  MOVWF  00
0258:  DECFSZ 00,F
025A:  BRA    0258
025C:  DECFSZ FEF,F
025E:  BRA    0246
0260:  RETLW  00
.................... #use rs232(baud=57600, xmit=PIN_C6, rcv=PIN_C7, stream=RS232) 
.................... #use i2c(master, sda=PIN_B0, scl=PIN_B1) 
....................  
.................... //#build(reset=0x1, interrupt=0x5)          // Necessary for Bootloader 
.................... //#ORG 0x7F00,0x7FFF {}   
....................  
.................... #define Button PIN_E2 
.................... #define led PIN_A4 
.................... #define bluethoot PIN_A4 
.................... #define TIME1 500 
....................  
.................... //-- Formatage données envoyes sur la sortie serie -- 
.................... //-- format de la trame envoyee: 
.................... //-- +--------------+--------------------+-------------+----------+----------+ 
.................... //-- |-    8bits   -|-       8bits      -|-   8bits   -|-  8bits -|-  8bits -| 
.................... //-- |-ENTETE(0xFF)-|-ADR DEVICE (1byte)-|-Type DEVICE-|-data Lsb-|-data Msb-| 
.................... //-- +--------------+--------------------+-------------+----------+----------+ 
.................... //-- 
....................  
.................... #define entete 0xFF 
.................... #define adr_inout 0x00 
.................... #define adr_ADC 0x00 
.................... #define adr_acc 0x3A 
.................... #define adr_boussole 0x42 
.................... #define adr_temp 0x90 
.................... #define adr_light 0x46 
.................... #define adr_srf02 0xe0 
....................  
.................... #define typ_inout 0x00				// 1 byte 
.................... #define typ_acc_x 0x01				// 2 bytes 
.................... #define typ_acc_y 0x02				// 2 bytes 
.................... #define typ_acc_z 0x03				// 2 bytes 
.................... #define typ_temp 0x04				// 2 bytes 
.................... #define typ_light 0x05				// 2 bytes 
.................... #define typ_srf02 0x06				// 2 bytes 
.................... #define typ_adc01 0x07				// 2 bytes 
.................... #define typ_boussole 0x0c			// 2 bytes 
....................  
.................... //-------------------------E/S------------------------ 
.................... #include "LCD420_S3.c" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //// LCD420_S3.C //// 
.................... //// Driver for common 4x20 LCD modules //// 
.................... //// //// 
.................... //// lcd_init() Must be called before any other function. //// 
.................... //// //// 
.................... //// lcd_putc(c) Will display c on the next position of the LCD. //// 
.................... //// The following have special meaning: //// 
.................... //// \f Clear display //// 
.................... //// \n Go to start of second line //// 
.................... //// \b Move back one position //// 
.................... //// \c Cursor on //// 
.................... //// \d Blink character //// 
.................... //// \1 Custom character DegC //// 
.................... //// //// 
.................... //// lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) //// 
.................... //// //// 
.................... //// lcd_getc(x,y) Returns character at position x,y on LCD //// 
.................... //// //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //// (C) Copyright 1996,1997 Custom Computer Services //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler. This source code may only be distributed to other //// 
.................... //// licensed users of the CCS C compiler. No other use, reproduction //// 
.................... //// or distribution is permitted without written permission. //// 
.................... //// Derivative programs created using this software in object code //// 
.................... //// form are not restricted in any way. //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... // These pins are for the PIC development board: 
.................... // B1 enable 
.................... // B2 rs 
.................... // B3 rw 
.................... // B4 D4 
.................... // B5 D5 
.................... // E1 D6 
.................... // E0 D7 
....................  
.................... #if defined(__PCM__)  
.................... #define LCD_RS PIN_B2 
....................  
.................... #elif defined(__PCH__) 
.................... #define LCD_RS PIN_E0 
.................... #endif 
....................  
.................... #define LCD_E PIN_B3 
.................... //#define LCD_RS PIN_B2 
.................... //#define LCD_RW PIN_B1 
.................... #define LCD_DB4 PIN_B4 
.................... #define LCD_DB5 PIN_B5 
.................... #define LCD_DB6 PIN_B6 
.................... #define LCD_DB7 PIN_B7 
....................  
.................... // Clear and home 
.................... #define LCD_CLR_DISP 0x01 // Clear screen, home cursor, unshift display 
.................... #define LCD_RETURN_HOME 0x02 // Home cursor, unshift display 
....................  
.................... // Set entry mode: display shift on/off, dec/inc cursor move direction 
.................... #define LCD_ENTRY_DEC 0x04 // Display shift off, dec cursor move dir 
.................... #define LCD_ENTRY_DEC_SHIFT 0x05 // Display shift on, dec cursor move dir 
.................... #define LCD_ENTRY_INC 0x06 // Display shift off, inc cursor move dir 
.................... #define LCD_ENTRY_INC_SHIFT 0x07 // Display shift on, inc cursor move dir 
....................  
.................... // Display on/off, cursor on/off, blinking char at cursor position 
.................... #define LCD_DISP_OFF 0x08 // Display off 
.................... #define LCD_DISP_ON 0x0C // Display on, cursor off 
.................... #define LCD_DISP_ON_BLINK 0x0D // Display on, cursor off, blink char 
.................... #define LCD_DISP_ON_CURSOR 0x0E // Display on, cursor on 
.................... #define LCD_DISP_ON_CURSOR_BLINK 0x0F // Display on, cursor on, blink char 
....................  
.................... // Move cursor/shift display 
.................... #define LCD_MOVE_CURSOR_LEFT 0x10 // Move cursor left (decrement) 
.................... #define LCD_MOVE_CURSOR_RIGHT 0x14 // Move cursor right (increment) 
.................... #define LCD_MOVE_DISP_LEFT 0x18 // Shift display left 
.................... #define LCD_MOVE_DISP_RIGHT 0x1C // Shift display right 
....................  
.................... // Function set: set interface data length and number of display lines 
.................... #define LCD_FUNCTION_4BIT_1LINE 0x20 // 4-bit interface, single line, 5x7 dots 
.................... #define LCD_FUNCTION_4BIT_2LINES 0x28 // 4-bit interface, dual line, 5x7 dots 
.................... #define LCD_FUNCTION_8BIT_1LINE 0x30 // 8-bit interface, single line, 5x7 dots 
.................... #define LCD_FUNCTION_8BIT_2LINES 0x38 // 8-bit interface, dual line, 5x7 dots 
....................  
.................... #define LCD_CGRAM_BASE_ADDR 0x40 // Set the CGRAM address 
.................... #define LCD_DDRAM_BASE_ADDR 0x80 // Set the DDRAM address 
....................  
.................... // Address positions 
.................... #define LCD_LINE_1 0x80 // Position of start of line 1 
.................... #define LCD_LINE_2 0xC0 // Position of start of line 2 
.................... #define LCD_LINE_3 0x94 // Position of start of line 3 
.................... #define LCD_LINE_4 0xD4 // Position of start of line 4 
....................  
.................... #define LCD_DEGREE_CHAR 0x00 // Ascii 00 
....................  
.................... #define lcd_type 2 // 0=5x7, 1=5x10, 2=2 lines 
....................  
.................... BYTE const LCD_INIT_STRING[4] = { 
.................... LCD_FUNCTION_4BIT_2LINES | (lcd_type << 2), // Set mode: 4-bit, 2 lines, 5x7 dots 
.................... LCD_DISP_ON, 
.................... LCD_CLR_DISP, 
.................... LCD_ENTRY_INC }; 
....................  
.................... BYTE const LCD_CUSTOM_CHARS[] = { 
.................... 0x1C,0x14,0x1C,0x00,0x00,0x00,0x00,0x00, // DegC 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F }; // Not used 
....................  
.................... BYTE lcd_line; 
.................... /* 
.................... BYTE lcd_read_nibble() { 
.................... BYTE retval; 
....................  
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
.................... retval = 0; 
.................... output_high(LCD_E); 
.................... delay_cycles(1); 
.................... retval_0 = input(LCD_DB4); 
.................... retval_1 = input(LCD_DB5); 
.................... retval_2 = input(LCD_DB6); 
.................... retval_3 = input(LCD_DB7); 
.................... output_low(LCD_E); 
.................... return(retval); 
.................... } 
.................... /* 
.................... BYTE lcd_read_byte() { 
.................... BYTE low,high; 
....................  
.................... output_high(LCD_RW); 
.................... delay_cycles(1); 
.................... high = lcd_read_nibble(); 
.................... low = lcd_read_nibble(); 
.................... return((high << 4) | low); 
.................... } 
.................... */ 
.................... void lcd_send_nibble( BYTE n ) { 
.................... 	output_bit(LCD_DB4, !!(n & 1)); 
*
01B6:  MOVLB  1
01B8:  BTFSC  x0F.0
01BA:  BRA    01C0
01BC:  BCF    F8A.4
01BE:  BRA    01C2
01C0:  BSF    F8A.4
01C2:  BCF    F93.4
.................... 	output_bit(LCD_DB5, !!(n & 2)); 
01C4:  BTFSC  x0F.1
01C6:  BRA    01CC
01C8:  BCF    F8A.5
01CA:  BRA    01CE
01CC:  BSF    F8A.5
01CE:  BCF    F93.5
.................... 	output_bit(LCD_DB6, !!(n & 4)); 
01D0:  BTFSC  x0F.2
01D2:  BRA    01D8
01D4:  BCF    F8A.6
01D6:  BRA    01DA
01D8:  BSF    F8A.6
01DA:  BCF    F93.6
.................... 	output_bit(LCD_DB7, !!(n & 8)); 
01DC:  BTFSC  x0F.3
01DE:  BRA    01E4
01E0:  BCF    F8A.7
01E2:  BRA    01E6
01E4:  BSF    F8A.7
01E6:  BCF    F93.7
.................... 	delay_cycles(1); 
01E8:  NOP   
.................... 	output_high(LCD_E); 
01EA:  BCF    F93.3
01EC:  BSF    F8A.3
.................... 	delay_cycles(1); 
01EE:  NOP   
.................... 	output_low(LCD_E); 
01F0:  BCF    F93.3
01F2:  BCF    F8A.3
.................... } 
01F4:  MOVLB  0
01F6:  RETLW  00
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
.................... 	output_low(LCD_RS); 
01F8:  BCF    F96.0
01FA:  BCF    F8D.0
.................... //	while (bit_test(lcd_read_byte(),7)); // wait until busy flag is low 
.................... 	if (address) 
01FC:  MOVLB  1
01FE:  MOVF   x0C,F
0200:  BZ    0208
.................... 		output_high(LCD_RS); 
0202:  BCF    F96.0
0204:  BSF    F8D.0
.................... 	else 
0206:  BRA    020C
.................... 		output_low(LCD_RS); 
0208:  BCF    F96.0
020A:  BCF    F8D.0
.................... //	delay_cycles(1); 
.................... //	output_low(LCD_RW); 
.................... //	delay_cycles(1); 
.................... 	output_low(LCD_E); 
020C:  BCF    F93.3
020E:  BCF    F8A.3
.................... 	lcd_send_nibble(n >> 4); 
0210:  SWAPF  x0D,W
0212:  MOVWF  x0E
0214:  MOVLW  0F
0216:  ANDWF  x0E,F
0218:  MOVFF  10E,10F
021C:  MOVLB  0
021E:  RCALL  01B6
.................... 	lcd_send_nibble(n & 0xf); 
0220:  MOVLB  1
0222:  MOVF   x0D,W
0224:  ANDLW  0F
0226:  MOVWF  x0E
0228:  MOVWF  x0F
022A:  MOVLB  0
022C:  RCALL  01B6
.................... 	delay_us(39);	 
022E:  MOVLW  40
0230:  MOVWF  00
0232:  DECFSZ 00,F
0234:  BRA    0232
0236:  BRA    0238
.................... } 
0238:  RETLW  00
....................  
.................... void lcd_init() { 
.................... BYTE i; 
.................... 	for (i=1;i<=3;++i) { 
*
0262:  MOVLW  01
0264:  MOVLB  1
0266:  MOVWF  x05
0268:  MOVF   x05,W
026A:  SUBLW  03
026C:  BNC   0288
.................... 		lcd_send_byte(0,0x20); 
026E:  CLRF   x0C
0270:  MOVLW  20
0272:  MOVWF  x0D
0274:  MOVLB  0
0276:  RCALL  01F8
.................... 		delay_ms(2); 
0278:  MOVLW  02
027A:  MOVLB  1
027C:  MOVWF  x3E
027E:  MOVLB  0
0280:  RCALL  023A
.................... 	} 
0282:  MOVLB  1
0284:  INCF   x05,F
0286:  BRA    0268
.................... 	for (i=0;i<=sizeof(LCD_INIT_STRING);++i){ 
0288:  CLRF   x05
028A:  MOVF   x05,W
028C:  SUBLW  04
028E:  BNC   02B4
.................... 		lcd_send_byte(0, LCD_INIT_STRING[i]); 
0290:  CLRF   03
0292:  MOVF   x05,W
0294:  MOVLB  0
0296:  RCALL  0004
0298:  MOVLB  1
029A:  MOVWF  x06
029C:  CLRF   x0C
029E:  MOVWF  x0D
02A0:  MOVLB  0
02A2:  RCALL  01F8
.................... 		delay_ms(2); 
02A4:  MOVLW  02
02A6:  MOVLB  1
02A8:  MOVWF  x3E
02AA:  MOVLB  0
02AC:  RCALL  023A
.................... 		} 
02AE:  MOVLB  1
02B0:  INCF   x05,F
02B2:  BRA    028A
.................... } 
02B4:  MOVLB  0
02B6:  GOTO   0490 (RETURN)
....................  
.................... void lcd_init_custom_chars() { 
.................... BYTE i; 
....................  
.................... 	lcd_send_byte(0,LCD_CGRAM_BASE_ADDR); 
.................... 	for (i=0;i<64;i++) { 
.................... 		lcd_send_byte(1,LCD_CUSTOM_CHARS[i]); 
.................... 		delay_ms(2); 
.................... 	} 
.................... } 
.................... void lcd_gotoxy( BYTE x, BYTE y ) { 
.................... BYTE address; 
....................  
.................... 	switch(y) { 
02BA:  MOVLW  01
02BC:  MOVLB  1
02BE:  SUBWF  x09,W
02C0:  ADDLW  FC
02C2:  BC    02EE
02C4:  ADDLW  04
02C6:  MOVLB  0
02C8:  GOTO   0306
.................... 		case 1 : address=LCD_LINE_1; break; 
02CC:  MOVLW  80
02CE:  MOVLB  1
02D0:  MOVWF  x0A
02D2:  BRA    02EE
.................... 		case 2 : address=LCD_LINE_2; break; 
02D4:  MOVLW  C0
02D6:  MOVLB  1
02D8:  MOVWF  x0A
02DA:  BRA    02EE
.................... 		case 3 : address=LCD_LINE_3; break; 
02DC:  MOVLW  94
02DE:  MOVLB  1
02E0:  MOVWF  x0A
02E2:  BRA    02EE
.................... 		case 4 : address=LCD_LINE_4; break; 
02E4:  MOVLW  D4
02E6:  MOVLB  1
02E8:  MOVWF  x0A
02EA:  BRA    02EE
02EC:  MOVLB  1
.................... 		 
.................... 	} 
.................... 	address+=x-1; 
02EE:  MOVLW  01
02F0:  SUBWF  x08,W
02F2:  ADDWF  x0A,F
.................... 	lcd_send_byte(0,0x80 | address); 
02F4:  MOVF   x0A,W
02F6:  IORLW  80
02F8:  MOVWF  x0B
02FA:  CLRF   x0C
02FC:  MOVWF  x0D
02FE:  MOVLB  0
0300:  RCALL  01F8
.................... } 
0302:  GOTO   039A (RETURN)
....................  
.................... void lcd_putc( char c ) { 
.................... 	switch(c) { 
*
0328:  MOVLB  1
032A:  MOVF   x07,W
032C:  XORLW  0C
032E:  MOVLB  0
0330:  BZ    0340
0332:  XORLW  06
0334:  BZ    035C
0336:  XORLW  02
0338:  BZ    036E
033A:  XORLW  09
033C:  BZ    037C
033E:  BRA    038A
.................... 		case '\f' : lcd_send_byte(0,LCD_CLR_DISP); 
0340:  MOVLB  1
0342:  CLRF   x0C
0344:  MOVLW  01
0346:  MOVWF  x0D
0348:  MOVLB  0
034A:  RCALL  01F8
.................... 			lcd_line=1; 
034C:  MOVLW  01
034E:  MOVWF  04
.................... 			delay_ms(2); break; 
0350:  MOVLW  02
0352:  MOVLB  1
0354:  MOVWF  x3E
0356:  MOVLB  0
0358:  RCALL  023A
035A:  BRA    039A
.................... 		case '\n' : lcd_gotoxy(1,++lcd_line); break; 
035C:  INCF   04,F
035E:  MOVLW  01
0360:  MOVLB  1
0362:  MOVWF  x08
0364:  MOVFF  04,109
0368:  MOVLB  0
036A:  BRA    02BA
036C:  BRA    039A
.................... 		case '\b' : lcd_send_byte(0,LCD_MOVE_CURSOR_LEFT); break; 
036E:  MOVLB  1
0370:  CLRF   x0C
0372:  MOVLW  10
0374:  MOVWF  x0D
0376:  MOVLB  0
0378:  RCALL  01F8
037A:  BRA    039A
.................... 		case '\1' : lcd_send_byte(1,LCD_DEGREE_CHAR); break;				// caractere degree 
037C:  MOVLW  01
037E:  MOVLB  1
0380:  MOVWF  x0C
0382:  CLRF   x0D
0384:  MOVLB  0
0386:  RCALL  01F8
0388:  BRA    039A
.................... 		default : lcd_send_byte(1,c); break; 
038A:  MOVLW  01
038C:  MOVLB  1
038E:  MOVWF  x0C
0390:  MOVFF  107,10D
0394:  MOVLB  0
0396:  RCALL  01F8
0398:  BRA    039A
.................... 	} 
.................... } 
039A:  GOTO   03B2 (RETURN)
....................  
.................... void cursor( byte c ) { 
.................... 	switch(c) { 
*
03BE:  MOVLB  1
03C0:  MOVF   x05,W
03C2:  ADDLW  FC
03C4:  BC    0410
03C6:  ADDLW  04
03C8:  MOVLB  0
03CA:  GOTO   0416
.................... 		case 0 : lcd_send_byte(0,LCD_DISP_ON);break;						// curseur OFF 
03CE:  MOVLB  1
03D0:  CLRF   x0C
03D2:  MOVLW  0C
03D4:  MOVWF  x0D
03D6:  MOVLB  0
03D8:  RCALL  01F8
03DA:  MOVLB  1
03DC:  BRA    0410
.................... 		case 1 : lcd_send_byte(0,LCD_DISP_ON_CURSOR); break;				// curseur ON 
03DE:  MOVLB  1
03E0:  CLRF   x0C
03E2:  MOVLW  0E
03E4:  MOVWF  x0D
03E6:  MOVLB  0
03E8:  RCALL  01F8
03EA:  MOVLB  1
03EC:  BRA    0410
.................... 		case 2 : lcd_send_byte(0,LCD_DISP_ON_BLINK); break;					// cursour OFF blink 
03EE:  MOVLB  1
03F0:  CLRF   x0C
03F2:  MOVLW  0D
03F4:  MOVWF  x0D
03F6:  MOVLB  0
03F8:  RCALL  01F8
03FA:  MOVLB  1
03FC:  BRA    0410
.................... 		case 3 : lcd_send_byte(0,LCD_DISP_ON_CURSOR_BLINK); break;			// cursour ON blink 
03FE:  MOVLB  1
0400:  CLRF   x0C
0402:  MOVLW  0F
0404:  MOVWF  x0D
0406:  MOVLB  0
0408:  RCALL  01F8
040A:  MOVLB  1
040C:  BRA    0410
040E:  MOVLB  1
.................... 	} 
.................... } 
0410:  MOVLB  0
0412:  GOTO   04AC (RETURN)
....................  
.................... /* 
.................... char lcd_getc( BYTE x, BYTE y ) { 
.................... char value; 
....................  
.................... 	lcd_gotoxy(x,y); 
.................... 	while (bit_test(lcd_read_byte(),7)); // wait until busy flag is low 
.................... 	output_high(LCD_RS); 
.................... 	value = lcd_read_byte(); 
.................... 	output_low(LCD_RS); 
.................... 	return(value); 
.................... }*/ 
....................  
....................  
....................  
.................... #use spi(DI=PIN_D2, DO=PIN_D1, CLK=PIN_D0, ENABLE=PIN_D3) 
....................  
.................... #include "HDD Driver.c" 
.................... ////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////// 
.................... //	Name:			   HDD Driver.c                       					  // 
.................... //	Date:			   02/01/2004		                   					  // 
.................... //	Version:		   1.1											              // 
.................... //	Type:			   PIC C Driver for MMC										  // 
.................... //	Author:        Mike Luck & Douglas Kennedy				           // 
.................... //	Company:		   MPIC3.COM										           // 
.................... ////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////// 
....................  
.................... //	Note: 
.................... // 		This code is a work in progress & not a finished fully working 
.................... //			project. Please check www.mpic3.com reguarly for updates. 
....................  
.................... /// PIN Assignments ////////////////////////////// 
.................... #DEFINE _CS PIN_D3 // chip select for MMC (C2) 
.................... //#DEFINE SDO PIN_C5 
.................... //#DEFINE CLK PIN_C3 
.................... //#DEFINE SDI PIN_C4 
.................... // SPI hardware pins are 
.................... // SDO C5 
.................... // SDI C4 
.................... // SCK C3 
.................... /////////////////////////////////////////////////////////////// 
....................  
.................... ///// Note old values needed before all SPI modes could be set up using SPI_setup 
.................... /// for 16 parts /////////// 
.................... //#DEFINE SSPCON 0x14 
.................... //#DEFINE SSPSTAT 0x94 
.................... //#BIT SMP=SSPSTAT.7 
.................... //#BIT CKE=SSPSTAT.6 
.................... //#BIT CKP=SSPCON.4 
.................... //#BIT SSPEN=SSPCON.5 
.................... ////////////////////////////// 
....................  
.................... // For 18F452 
.................... #DEFINE SSPSTAT 0x0FC7 
.................... #DEFINE SSPCON1 0x0FC6 
.................... #BIT SMP=SSPSTAT.7 
.................... #BIT CKE=SSPSTAT.6 
.................... #BIT CKP=SSPCON1.4 
....................  
.................... #DEFINE MAX_FILES 2 /// max number of open files 
.................... #DEFINE MMC_BUFF_SIZE 32 /// 32 for PCM 
.................... #DEFINE MMC_FILE_NAME_SIZE 32 
....................  
.................... #DEFINE ROOT_CLUSTER 0 
.................... #DEFINE NEXT_CLUSTER 1 
....................  
.................... #define MMC_INIT_TRACE FALSE 
.................... #define MMC_CMD_TRACE FALSE 
.................... #define MMC_CLUSTER_TRACE FALSE // if true prints to serial port 
.................... #define MMC_OPEN_TRACE FALSE // if true prints to serial port 
.................... #define MMC_READ_TRACE FALSE // if true prints file_addr,cluster index etc 
.................... #define MMC_WRITE_TRACE FALSE 
.................... #define MMC_READ_BLOCK_TRACE FALSE 
.................... #define MMC_SET_BLOCK_LEN_TRACE FALSE 
.................... #define MMC_WRITE_BLOCK_TRACE FALSE 
.................... #define MMC_NEW_CLUSTER FALSE 
.................... ////// MMC prototypes 
.................... #separate 
.................... int init_MMC(int max_tries); 
.................... #separate 
.................... int open_file(int fnbr,char *fname,int16 rec_length); 
.................... #separate 
.................... int file_read(int8 fnbr,char *buff); 
.................... #separate 
.................... int file_write(int8 fnbr,int *buff); 
.................... #separate 
.................... int file_set(int fnbr,int32 offset); 
.................... #separate 
.................... int file_new_cluster(int8 fnbr,int8 mode); /// mode 1=fat1 2=fat2 
....................  
.................... int32 atoint32 (char *s ); 
.................... signed int strncmp(char *s1, char *s2, int n); 
.................... ///////////////////// MMC GLOBALS ///////////////////////////// 
.................... int16 cluster_size_bytes; // bytes in a cluster 
.................... //int16 dir_cluster_chain_ptr; // link to the first cluster in the dir 
....................  
.................... int32 fat1_address; // physical address of fat1 cluster table assigned by INIT_MMC 
.................... int32 fat2_address; // physical address of fat1 cluster table assigned by INIT_MMC 
.................... int32 root_dir_address; // physical address of volume,file,folder tiles assigned by INIT_MMC 
.................... int32 data_area_address; // physical address of data area assigned by INIT_MMC 
.................... int32 winhex_adj; // Win hex hides the bytes in the reserved sectors 
.................... // this means Fat1 is address 512 
.................... // so adj is fat1-512 
....................  
.................... int32 block_size; // current MMC block size 
....................  
.................... int MMC_init=FALSE; 
....................  
.................... int MMC_dir_protected=TRUE; 
....................  
.................... ////////// open file specific globals /////////////////////// 
.................... struct{ 
.................... 	char name[MMC_FILE_NAME_SIZE+1]; // fopen file name 
.................... 	int32 dir_addr_ptr; // physical address of this files tile info 
.................... 	int16 root_cluster_ptr; // location of first cluster in FAT 
.................... 	int16 this_cluster_ptr; // location of current cluster in FAT 
.................... 	int16 next_cluster_ptr; // location of the next cluster for a file or sub dir in FAT 
.................... 	int32 addr_ptr; // physical address in the file the current 
.................... 	// cluster points to 
.................... 	// address=(this_chain_ptr-2)*cluster_size_bytes+data_area_address 
.................... 	// 
.................... 	// cluster_addr(THIS_CLUSTER) assigns it 
.................... 	// cluster_addr(NEXT_CLUSTER) moves to the data the next 
.................... 	// cluster points to 
.................... 	int32 size; // size of open file in bytes 
.................... 	int32 cluster_offset; // offset within the file representing the start of the current cluster 
.................... 	// (0 is start and ends with the cluster contianing eof ) 
.................... 	// auto increased by cluster_size_bytes each time a new cluster is entered 
....................  
.................... 	int32 offset; // current offset into the open file ( 0 is start size(file size) is end) 
.................... 	// auto increased by rec size each time a rec is read 
.................... 	// addr_prt+offset-cluster_offset is physical address of 
.................... 	// the current position within the file 
.................... 	// the physical positions are not always contiguous since the 
.................... 	// clusters of the file are not always adjacent to each other 
.................... 	int16 rec_size; // fopen record_size 
.................... 	// char buff[MMC_BUFF_SIZE+1]; // used for open and for read write 
.................... 	// init MMC uses file 0 buff to fetch the globals 
....................  
.................... } file[MAX_FILES]; 
....................  
....................  
.................... #separate 
.................... int mmc_cmd(int8 cmd,int32 address,int8 tries,int8 valid,int8 invalid){ 
.................... 	int i,r1; 
.................... 	for( i=0;i<16;i++) SPI_READ(0xFF);// digest prior operation 
*
04F6:  MOVLB  1
04F8:  CLRF   x67
04FA:  MOVF   x67,W
04FC:  SUBLW  0F
04FE:  BNC   050E
0500:  MOVF   FC9,W
0502:  MOVLW  FF
0504:  MOVWF  FC9
0506:  RRCF   FC7,W
0508:  BNC   0506
.................... 	// commands 
.................... 	// 7 6 5 4 3 2 1 0 
.................... 	// 0 1 b b b b b b bbbbbb=cmd 
.................... 	// 16=0x50 set blocklength 
.................... 	// 17=0x51 read block 
.................... 	// 24=0x58 write block 
.................... 	#if MMC_CMD_TRACE 
050A:  INCF   x67,F
050C:  BRA    04FA
.................... 	printf("\n\r cmd=%2X \n\r",cmd); 
.................... 	#endif 
.................... 	SPI_READ(cmd); 
050E:  MOVF   FC9,W
0510:  MOVFF  15F,FC9
0514:  RRCF   FC7,W
0516:  BNC   0514
.................... 	SPI_READ(MAKE8(address,3)); 
0518:  MOVFF  163,169
051C:  MOVF   FC9,W
051E:  MOVFF  163,FC9
0522:  RRCF   FC7,W
0524:  BNC   0522
.................... 	SPI_READ(MAKE8(address,2)); 
0526:  MOVFF  162,169
052A:  MOVF   FC9,W
052C:  MOVFF  162,FC9
0530:  RRCF   FC7,W
0532:  BNC   0530
.................... 	SPI_READ(MAKE8(address,1)); 
0534:  MOVFF  161,169
0538:  MOVF   FC9,W
053A:  MOVFF  161,FC9
053E:  RRCF   FC7,W
0540:  BNC   053E
.................... 	SPI_READ(MAKE8(address,0)); 
0542:  MOVFF  160,169
0546:  MOVF   FC9,W
0548:  MOVFF  160,FC9
054C:  RRCF   FC7,W
054E:  BNC   054C
.................... 	SPI_READ(0x95); // valid crc for 0x40 only invalid for others but spi mode doesn't care 
0550:  MOVF   FC9,W
0552:  MOVLW  95
0554:  MOVWF  FC9
0556:  RRCF   FC7,W
0558:  BNC   0556
.................... 	for(i=0;i< tries;i++) { 
055A:  CLRF   x67
055C:  MOVF   x64,W
055E:  SUBWF  x67,W
0560:  BC    0584
.................... 		r1=SPI_READ(0xFF); 
0562:  MOVF   FC9,W
0564:  MOVLW  FF
0566:  MOVWF  FC9
0568:  RRCF   FC7,W
056A:  BNC   0568
056C:  MOVFF  FC9,168
.................... 		#if MMC_CMD_TRACE 
.................... 			printf(" %2X",r1); 
.................... 		#endif 
.................... 		if (r1==valid) break; 
0570:  MOVF   x65,W
0572:  SUBWF  x68,W
0574:  BNZ   0578
0576:  BRA    0584
.................... 		if (r1==invalid) break; 
0578:  MOVF   x66,W
057A:  SUBWF  x68,W
057C:  BNZ   0580
057E:  BRA    0584
.................... 	} 
0580:  INCF   x67,F
0582:  BRA    055C
.................... 	return(r1); 
0584:  MOVFF  168,01
.................... } 
0588:  MOVLB  0
058A:  RETLW  00
....................  
....................  
.................... #separate 
.................... int set_BLOCKLEN( int32 size){ 
.................... 	int r1; 
....................  
.................... 	r1=mmc_cmd(0x50,size,16,0x00,0x40); /// cmd.data,tries,valid code,invlaid code 
058C:  MOVLW  50
058E:  MOVLB  1
0590:  MOVWF  x5F
0592:  MOVFF  155,163
0596:  MOVFF  154,162
059A:  MOVFF  153,161
059E:  MOVFF  152,160
05A2:  MOVLW  10
05A4:  MOVWF  x64
05A6:  CLRF   x65
05A8:  MOVLW  40
05AA:  MOVWF  x66
05AC:  MOVLB  0
05AE:  RCALL  04F6
05B0:  MOVFF  01,156
.................... 	if (r1==0x00) goto done ; 
05B4:  MOVLB  1
05B6:  MOVF   x56,F
05B8:  BNZ   05BC
05BA:  BRA    05CA
.................... 	if (r1==0x40) goto invalid; 
05BC:  MOVF   x56,W
05BE:  SUBLW  40
05C0:  BNZ   05C4
05C2:  BRA    05CA
....................  
....................  
.................... 	return(false); 
05C4:  MOVLW  00
05C6:  MOVWF  01
05C8:  BRA    05DE
.................... 	invalid: 
.................... 	#IF MMC_SET_BLOCK_LEN_TRACE 
.................... 		printf("\n\r para err\n\r"); 
.................... 	#ENDIF 
.................... done: 
.................... 	block_size=size; //// assign global block size 
05CA:  MOVFF  155,1E
05CE:  MOVFF  154,1D
05D2:  MOVFF  153,1C
05D6:  MOVFF  152,1B
.................... 	//printf("\n\r blk size=%lu",block_size); 
.................... 	return(true); 
05DA:  MOVLW  01
05DC:  MOVWF  01
.................... } 
05DE:  MOVLB  0
05E0:  RETLW  00
....................  
....................  
.................... #separate 
.................... int read_BLOCK( int32 address, char *buff){ 
.................... 	//// low level read ..requires block len to be called first to set global blocksize 
.................... 	int r1; 
.................... 	long i,iw; /// allows large gt 255 buff size addressing 
.................... 	//int data[128]; 
.................... 	r1=mmc_cmd(0x51,address,16,0x00,0x40); 
05E2:  MOVLW  51
05E4:  MOVLB  1
05E6:  MOVWF  x5F
05E8:  MOVFF  157,163
05EC:  MOVFF  156,162
05F0:  MOVFF  155,161
05F4:  MOVFF  154,160
05F8:  MOVLW  10
05FA:  MOVWF  x64
05FC:  CLRF   x65
05FE:  MOVLW  40
0600:  MOVWF  x66
0602:  MOVLB  0
0604:  RCALL  04F6
0606:  MOVFF  01,15A
....................  
.................... 	if (r1==0x00) goto get_token ; // we can read data payload 
060A:  MOVLB  1
060C:  MOVF   x5A,F
060E:  BNZ   0612
0610:  BRA    0626
.................... 	if (r1==0x40) goto invalid; 
0612:  MOVF   x5A,W
0614:  SUBLW  40
0616:  BNZ   061A
0618:  BRA    0620
....................  
.................... 	#IF MMC_READ_BLOCK_TRACE 
.................... 		printf("\n\r read block err 1 address=%lu \n\r",address); 
.................... 	#ENDIF 
.................... 	return(false); 
061A:  MOVLW  00
061C:  MOVWF  01
061E:  BRA    06A8
.................... 	invalid: 
.................... 	#IF MMC_READ_BLOCK_TRACE 
.................... 		printf("\n\r read block err 2 adress=%lu \n\r",address); 
.................... 	#ENDIF 
.................... 	return(false); 
0620:  MOVLW  00
0622:  MOVWF  01
0624:  BRA    06A8
.................... 	get_token: 
.................... 	for(iw=0;iw<1024;iw++){ 
0626:  CLRF   x5E
0628:  CLRF   x5D
062A:  MOVF   x5E,W
062C:  SUBLW  03
062E:  BNC   064E
.................... 	r1=SPI_READ(0xFF); 
0630:  MOVF   FC9,W
0632:  MOVLW  FF
0634:  MOVWF  FC9
0636:  RRCF   FC7,W
0638:  BNC   0636
063A:  MOVFF  FC9,15A
.................... 	//data[iw]=r1; 
.................... 	if (r1==0xFE) goto read_data; // read token $FE 
063E:  MOVF   x5A,W
0640:  SUBLW  FE
0642:  BNZ   0646
0644:  BRA    0654
.................... 	} 
.................... 	#IF MMC_READ_BLOCK_TRACE 
0646:  INCF   x5D,F
0648:  BTFSC  FD8.2
064A:  INCF   x5E,F
064C:  BRA    062A
.................... 		printf("\n\r read block err 3 address=%lu \n\r",address); 
.................... 	#ENDIF 
.................... 	return(false); 
064E:  MOVLW  00
0650:  MOVWF  01
0652:  BRA    06A8
.................... 	read_data: 
.................... 	#IF MMC_READ_BLOCK_TRACE 
.................... 		printf("\n\r read block tries for FE =%lu \n\r",iw); 
.................... 	#ENDIF 
....................  
.................... 	for (i=0;i<block_size;i++) buff[i]=SPI_READ(0xFF); 
0654:  CLRF   x5C
0656:  CLRF   x5B
0658:  MOVF   1E,F
065A:  BNZ   066E
065C:  MOVF   1D,F
065E:  BNZ   066E
0660:  MOVF   x5C,W
0662:  SUBWF  1C,W
0664:  BNC   0690
0666:  BNZ   066E
0668:  MOVF   1B,W
066A:  SUBWF  x5B,W
066C:  BC    0690
066E:  MOVF   x58,W
0670:  ADDWF  x5B,W
0672:  MOVWF  FE9
0674:  MOVF   x59,W
0676:  ADDWFC x5C,W
0678:  MOVWF  FEA
067A:  MOVF   FC9,W
067C:  MOVLW  FF
067E:  MOVWF  FC9
0680:  RRCF   FC7,W
0682:  BNC   0680
0684:  MOVFF  FC9,FEF
0688:  INCF   x5B,F
068A:  BTFSC  FD8.2
068C:  INCF   x5C,F
068E:  BRA    0658
.................... 	SPI_READ(0xFF); // read crc 
0690:  MOVF   FC9,W
0692:  MOVLW  FF
0694:  MOVWF  FC9
0696:  RRCF   FC7,W
0698:  BNC   0696
.................... 	SPI_READ(0xFF); 
069A:  MOVF   FC9,W
069C:  MOVLW  FF
069E:  MOVWF  FC9
06A0:  RRCF   FC7,W
06A2:  BNC   06A0
....................  
.................... 	return(true); 
06A4:  MOVLW  01
06A6:  MOVWF  01
.................... } 
06A8:  MOVLB  0
06AA:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... ///////////////////////////////// INIT MMC /////////////////////// 
.................... ////////////////////////////////////////////////////////////////// 
.................... #separate 
....................  
.................... int init_MMC(int max_tries){ 
.................... 	int32 start_lsec; 
.................... 	int16 sec_resv,sec_for_FAT,bytes_per_sector,root_dir_entries, 
.................... 	sec_for_data,count_of_clusters,root_dir_sectors,total_sectors; 
.................... 	int i,tries,sec_per_cluster,c; 
.................... 	char buff[32]; 
.................... 	tries=0; 
*
0770:  MOVLB  1
0772:  CLRF   x1B
.................... 	cmd0: 
.................... 	///////////////////// place null treminators in globals fname and buff 
.................... 	for(i=0;i<MAX_FILES;i++){ 
0774:  CLRF   x1A
0776:  MOVF   x1A,W
0778:  SUBLW  01
077A:  BNC   07C2
.................... 		file[i].name[0]=0; 
077C:  MOVF   x1A,W
077E:  MULLW  3D
0780:  MOVF   FF3,W
0782:  CLRF   x3F
0784:  MOVWF  x3E
0786:  MOVLW  21
0788:  ADDWF  x3E,W
078A:  MOVWF  FE9
078C:  MOVLW  00
078E:  ADDWFC x3F,W
0790:  MOVWF  FEA
0792:  CLRF   FEF
.................... 		file[i].rec_size=32; //// default rec_size = 32 byte tile size of FAT16 
0794:  MOVF   x1A,W
0796:  MULLW  3D
0798:  MOVF   FF3,W
079A:  CLRF   x3F
079C:  MOVWF  x3E
079E:  MOVLW  3B
07A0:  ADDWF  x3E,W
07A2:  MOVWF  01
07A4:  MOVLW  00
07A6:  ADDWFC x3F,W
07A8:  MOVWF  03
07AA:  MOVF   01,W
07AC:  ADDLW  21
07AE:  MOVWF  FE9
07B0:  MOVLW  00
07B2:  ADDWFC 03,W
07B4:  MOVWF  FEA
07B6:  CLRF   FEC
07B8:  MOVF   FED,F
07BA:  MOVLW  20
07BC:  MOVWF  FEF
.................... 	} 
07BE:  INCF   x1A,F
07C0:  BRA    0776
.................... 	//buff[MMC_BUFF_SIZE]=0; 
.................... 	//frec_size=32; //// default rec_size = 32 byte tile size of FAT16 
.................... 	output_high(_CS); /// reset chip hardware !!! required 
07C2:  BCF    F95.3
07C4:  BSF    F8C.3
.................... 	delay_ms(20); 
07C6:  MOVLW  14
07C8:  MOVWF  x3E
07CA:  MOVLB  0
07CC:  RCALL  023A
.................... 	for(i=0;i<20;i++) SPI_READ(0xFF); // min 80 clocks to get MMC ready 
07CE:  MOVLB  1
07D0:  CLRF   x1A
07D2:  MOVF   x1A,W
07D4:  SUBLW  13
07D6:  BNC   07E6
07D8:  MOVF   FC9,W
07DA:  MOVLW  FF
07DC:  MOVWF  FC9
07DE:  RRCF   FC7,W
07E0:  BNC   07DE
07E2:  INCF   x1A,F
07E4:  BRA    07D2
.................... 	output_low(_CS); /// !!! required 
07E6:  BCF    F95.3
07E8:  BCF    F8C.3
.................... 	delay_ms(20); 
07EA:  MOVLW  14
07EC:  MOVWF  x3E
07EE:  MOVLB  0
07F0:  RCALL  023A
.................... 	#if MMC_INIT_TRACE 
.................... 		printf("cmd0"); 
.................... 	#ENDIF 
.................... 	c=mmc_cmd(0x40,0x00000000,128,0x01,0x99); 
07F2:  MOVLW  40
07F4:  MOVLB  1
07F6:  MOVWF  x5F
07F8:  CLRF   x63
07FA:  CLRF   x62
07FC:  CLRF   x61
07FE:  CLRF   x60
0800:  MOVLW  80
0802:  MOVWF  x64
0804:  MOVLW  01
0806:  MOVWF  x65
0808:  MOVLW  99
080A:  MOVWF  x66
080C:  MOVLB  0
080E:  RCALL  04F6
0810:  MOVFF  01,11D
....................  
.................... 	if (c==0x01) goto exit_cmd1; 
0814:  MOVLB  1
0816:  DECFSZ x1D,W
0818:  BRA    081C
081A:  BRA    0830
....................  
.................... 	// note: i must cycle at least 8 times (16 is safe ) 
....................  
.................... 	if (tries++<max_tries) goto cmd0; /// restart 
081C:  MOVF   x1B,W
081E:  INCF   x1B,F
0820:  SUBWF  x05,W
0822:  BZ    082A
0824:  BNC   082A
0826:  BRA    0774
.................... 	else return (10); 
0828:  BRA    0830
082A:  MOVLW  0A
082C:  MOVWF  01
082E:  BRA    0B3A
.................... 	exit_cmd1: 
.................... 	// CPDMOD - This SOMETIMES seems to be necessary 
.................... 	// output_high(_CS); 
.................... 	// SPI_READ(0xFF); // min 8 clocks to get MMC ready 
.................... 	// output_low(_CS); 
.................... 	//CPDMOD End 
....................  
....................  
.................... 	tries=0; 
0830:  CLRF   x1B
.................... 	cmd1: 
....................  
.................... 	/// now try to switch to idle mode 
.................... 	/// Note: cmd1(idle) is the only command allowed after a cmd0(reset) 
.................... 	// 
....................  
.................... 	c=mmc_cmd(0x41,0x00000000,128,0x00,0x99); 
0832:  MOVLW  41
0834:  MOVWF  x5F
0836:  CLRF   x63
0838:  CLRF   x62
083A:  CLRF   x61
083C:  CLRF   x60
083E:  MOVLW  80
0840:  MOVWF  x64
0842:  CLRF   x65
0844:  MOVLW  99
0846:  MOVWF  x66
0848:  MOVLB  0
084A:  RCALL  04F6
084C:  MOVFF  01,11D
.................... 	if (c==0x00) { goto ready;} 
0850:  MOVLB  1
0852:  MOVF   x1D,F
0854:  BNZ   0858
0856:  BRA    087A
....................  
....................  
.................... 	if( tries++<max_tries) { printf("cmd1"); goto cmd1;} 
0858:  MOVF   x1B,W
085A:  INCF   x1B,F
085C:  SUBWF  x05,W
085E:  BZ    0874
0860:  BNC   0874
0862:  MOVLW  32
0864:  MOVWF  FF6
0866:  MOVLW  00
0868:  MOVWF  FF7
086A:  MOVLB  0
086C:  RCALL  04D4
086E:  MOVLB  1
0870:  BRA    0832
.................... 	else return(11); 
0872:  BRA    087A
0874:  MOVLW  0B
0876:  MOVWF  01
0878:  BRA    0B3A
.................... 	ready: 
.................... 	//for( i=0;i<32;i++) SPI_READ(0xFF);// digest operation 
.................... 	/// MMC is inialized and in idle state ready for commands 
.................... 	//// 
.................... 	//// we need to first access the master boot sector physical address=0 
.................... 	/// 
.................... 	if(set_BLOCKLEN((int32)32)==false) return(12); /// sets global block_size to 32 
087A:  CLRF   x55
087C:  CLRF   x54
087E:  CLRF   x53
0880:  MOVLW  20
0882:  MOVWF  x52
0884:  MOVLB  0
0886:  RCALL  058C
0888:  MOVF   01,F
088A:  BNZ   0894
088C:  MOVLW  0C
088E:  MOVWF  01
0890:  MOVLB  1
0892:  BRA    0B3A
....................  
.................... 	if (read_block(0x00000000,buff)==false) return (99); /// read the first few bytes 
0894:  MOVLB  1
0896:  CLRF   x57
0898:  CLRF   x56
089A:  CLRF   x55
089C:  CLRF   x54
089E:  MOVLW  01
08A0:  MOVWF  x59
08A2:  MOVLW  1E
08A4:  MOVWF  x58
08A6:  MOVLB  0
08A8:  RCALL  05E2
08AA:  MOVF   01,F
08AC:  BNZ   08B6
08AE:  MOVLW  63
08B0:  MOVWF  01
08B2:  MOVLB  1
08B4:  BRA    0B3A
.................... 	#if MMC_INIT_TRACE 
.................... 		printf("\n\r sector0="); 
.................... 		for(i=0;i<32;i++)printf("%2X ",buff[i]); 
.................... 	#ENDIF 
.................... 	if (buff[0]==0xEB || buff[0]==0xE9){ 
08B6:  MOVLB  1
08B8:  MOVF   x1E,W
08BA:  SUBLW  EB
08BC:  BZ    08C4
08BE:  MOVF   x1E,W
08C0:  SUBLW  E9
08C2:  BNZ   08C6
.................... 		/// sector 0 is the boot sector 
.................... 		#if MMC_INIT_TRACE 
.................... 			printf("\n\r boot sector= 0"); 
.................... 		#ENDIF 
.................... 	} 
.................... 	else{ 
08C4:  BRA    0934
.................... 		//// partition 
....................  
.................... 		/// access the master boot sector physical address 0 at offset 1BE 
.................... 		if (read_BLOCK(0x000001BE,buff)==false) return(13); 
08C6:  CLRF   x57
08C8:  CLRF   x56
08CA:  MOVLW  01
08CC:  MOVWF  x55
08CE:  MOVLW  BE
08D0:  MOVWF  x54
08D2:  MOVLW  01
08D4:  MOVWF  x59
08D6:  MOVLW  1E
08D8:  MOVWF  x58
08DA:  MOVLB  0
08DC:  RCALL  05E2
08DE:  MOVF   01,F
08E0:  BNZ   08EC
08E2:  MOVLW  0D
08E4:  MOVWF  01
08E6:  MOVLB  1
08E8:  BRA    0B3A
08EA:  MOVLB  0
.................... 		#if MMC_INIT_TRACE 
.................... 			for(i=0;i<32;i++)printf("%2X ",buff[i]); 
.................... 		#ENDIF 
.................... 		// start_lsec is address of the partion boot sector 
.................... 		start_lsec=make32(buff[11],buff[10],buff[9],buff[8]); 
08EC:  MOVFF  129,109
08F0:  MOVFF  128,108
08F4:  MOVFF  127,107
08F8:  MOVFF  126,106
.................... 		#if MMC_INIT_TRACE 
.................... 			printf("\n\r boot sector= %lu",start_lsec); 
.................... 		#ENDIF 
.................... 		if (read_BLOCK(start_lsec*512,buff)==false) return(14); 
08FC:  BCF    FD8.0
08FE:  MOVLB  1
0900:  CLRF   x3E
0902:  RLCF   x06,W
0904:  MOVWF  x3F
0906:  RLCF   x07,W
0908:  MOVWF  x40
090A:  RLCF   x08,W
090C:  MOVWF  x41
090E:  MOVWF  x57
0910:  MOVFF  140,156
0914:  MOVFF  13F,155
0918:  MOVFF  13E,154
091C:  MOVLW  01
091E:  MOVWF  x59
0920:  MOVLW  1E
0922:  MOVWF  x58
0924:  MOVLB  0
0926:  RCALL  05E2
0928:  MOVF   01,F
092A:  BNZ   0936
092C:  MOVLW  0E
092E:  MOVWF  01
0930:  MOVLB  1
0932:  BRA    0B3A
0934:  MOVLB  0
.................... 	} 
....................  
.................... 	bytes_per_sector=make16(buff[12],buff[11]); 
0936:  MOVFF  12A,10F
093A:  MOVFF  129,10E
.................... 	if(bytes_per_sector!=512) return(15); 
093E:  MOVLB  1
0940:  MOVF   x0E,F
0942:  BNZ   094A
0944:  MOVF   x0F,W
0946:  SUBLW  02
0948:  BZ    0950
094A:  MOVLW  0F
094C:  MOVWF  01
094E:  BRA    0B3A
.................... 	sec_per_cluster=buff[13]; 
0950:  MOVFF  12B,11C
.................... 	cluster_size_bytes=(int16)sec_per_cluster*bytes_per_sector; 
0954:  CLRF   x3F
0956:  MOVFF  11C,13E
095A:  MOVFF  13F,141
095E:  MOVFF  11C,140
0962:  MOVFF  10F,143
0966:  MOVFF  10E,142
096A:  MOVLB  0
096C:  RCALL  06AC
096E:  MOVFF  02,06
0972:  MOVFF  01,05
....................  
....................  
.................... 	sec_resv=make16(buff[15],buff[14]); 
0976:  MOVFF  12D,10B
097A:  MOVFF  12C,10A
....................  
.................... 	root_dir_entries=make16(buff[18],buff[17]);// number of 32 byte tiles 
097E:  MOVFF  130,111
0982:  MOVFF  12F,110
....................  
.................... 	total_sectors=make16(buff[20],buff[19]); 
0986:  MOVFF  132,119
098A:  MOVFF  131,118
....................  
.................... 	sec_for_FAT=make16(buff[23],buff[22]); 
098E:  MOVFF  135,10D
0992:  MOVFF  134,10C
.................... 	//branch to file directory 
.................... 	fat1_address=(start_lsec+sec_resv)*bytes_per_sector; 
0996:  MOVLB  1
0998:  MOVF   x0A,W
099A:  ADDWF  x06,W
099C:  MOVWF  x3E
099E:  MOVF   x0B,W
09A0:  ADDWFC x07,W
09A2:  MOVWF  x3F
09A4:  MOVLW  00
09A6:  ADDWFC x08,W
09A8:  MOVWF  x40
09AA:  MOVLW  00
09AC:  ADDWFC x09,W
09AE:  MOVWF  x41
09B0:  MOVWF  x5D
09B2:  MOVFF  140,15C
09B6:  MOVFF  13F,15B
09BA:  MOVFF  13E,15A
09BE:  CLRF   x61
09C0:  CLRF   x60
09C2:  MOVFF  10F,15F
09C6:  MOVFF  10E,15E
09CA:  MOVLB  0
09CC:  RCALL  06CE
09CE:  MOVFF  03,0A
09D2:  MOVFF  02,09
09D6:  MOVFF  01,08
09DA:  MOVFF  00,07
.................... 	fat2_address=fat1_address+bytes_per_sector*sec_for_FAT; 
09DE:  MOVFF  10F,141
09E2:  MOVFF  10E,140
09E6:  MOVFF  10D,143
09EA:  MOVFF  10C,142
09EE:  RCALL  06AC
09F0:  MOVF   01,W
09F2:  ADDWF  07,W
09F4:  MOVWF  0B
09F6:  MOVF   02,W
09F8:  ADDWFC 08,W
09FA:  MOVWF  0C
09FC:  MOVLW  00
09FE:  ADDWFC 09,W
0A00:  MOVWF  0D
0A02:  MOVLW  00
0A04:  ADDWFC 0A,W
0A06:  MOVWF  0E
.................... 	root_dir_address=(sec_for_FAT*2+start_lsec+sec_resv)*bytes_per_sector; 
0A08:  BCF    FD8.0
0A0A:  MOVLB  1
0A0C:  RLCF   x0C,W
0A0E:  MOVWF  x3E
0A10:  RLCF   x0D,W
0A12:  MOVWF  x3F
0A14:  MOVF   x06,W
0A16:  ADDWF  x3E,F
0A18:  MOVF   x07,W
0A1A:  ADDWFC x3F,F
0A1C:  MOVLW  00
0A1E:  ADDWFC x08,W
0A20:  MOVWF  x40
0A22:  MOVLW  00
0A24:  ADDWFC x09,W
0A26:  MOVWF  x41
0A28:  MOVF   x0A,W
0A2A:  ADDWF  x3E,F
0A2C:  MOVF   x0B,W
0A2E:  ADDWFC x3F,F
0A30:  MOVLW  00
0A32:  ADDWFC x40,F
0A34:  ADDWFC x41,F
0A36:  MOVFF  141,15D
0A3A:  MOVFF  140,15C
0A3E:  MOVFF  13F,15B
0A42:  MOVFF  13E,15A
0A46:  CLRF   x61
0A48:  CLRF   x60
0A4A:  MOVFF  10F,15F
0A4E:  MOVFF  10E,15E
0A52:  MOVLB  0
0A54:  RCALL  06CE
0A56:  MOVFF  03,12
0A5A:  MOVFF  02,11
0A5E:  MOVFF  01,10
0A62:  MOVFF  00,0F
.................... 	data_area_address=root_dir_address+root_dir_entries*32; 
0A66:  MOVLB  1
0A68:  RLCF   x10,W
0A6A:  MOVWF  02
0A6C:  RLCF   x11,W
0A6E:  MOVWF  03
0A70:  RLCF   02,F
0A72:  RLCF   03,F
0A74:  RLCF   02,F
0A76:  RLCF   03,F
0A78:  RLCF   02,F
0A7A:  RLCF   03,F
0A7C:  RLCF   02,F
0A7E:  RLCF   03,F
0A80:  MOVLW  E0
0A82:  ANDWF  02,F
0A84:  MOVF   02,W
0A86:  ADDWF  0F,W
0A88:  MOVWF  13
0A8A:  MOVF   03,W
0A8C:  ADDWFC 10,W
0A8E:  MOVWF  14
0A90:  MOVLW  00
0A92:  ADDWFC 11,W
0A94:  MOVWF  15
0A96:  MOVLW  00
0A98:  ADDWFC 12,W
0A9A:  MOVWF  16
.................... 	///// check for FAT16 
.................... 	root_dir_sectors=root_dir_entries>>4; 
0A9C:  RRCF   x11,W
0A9E:  MOVWF  x17
0AA0:  RRCF   x10,W
0AA2:  MOVWF  x16
0AA4:  RRCF   x17,F
0AA6:  RRCF   x16,F
0AA8:  RRCF   x17,F
0AAA:  RRCF   x16,F
0AAC:  RRCF   x17,F
0AAE:  RRCF   x16,F
0AB0:  MOVLW  0F
0AB2:  ANDWF  x17,F
....................  
.................... 	sec_for_data=total_sectors - sec_resv -sec_for_fat*2 -root_dir_sectors; 
0AB4:  MOVF   x0A,W
0AB6:  SUBWF  x18,W
0AB8:  MOVWF  x3E
0ABA:  MOVF   x0B,W
0ABC:  SUBWFB x19,W
0ABE:  MOVWF  x3F
0AC0:  BCF    FD8.0
0AC2:  RLCF   x0C,W
0AC4:  MOVWF  02
0AC6:  RLCF   x0D,W
0AC8:  MOVWF  03
0ACA:  MOVF   02,W
0ACC:  SUBWF  x3E,F
0ACE:  MOVF   03,W
0AD0:  SUBWFB x3F,F
0AD2:  MOVF   x16,W
0AD4:  SUBWF  x3E,W
0AD6:  MOVWF  x12
0AD8:  MOVF   x17,W
0ADA:  SUBWFB x3F,W
0ADC:  MOVWF  x13
....................  
.................... 	count_of_clusters=sec_for_data/sec_per_cluster; 
0ADE:  MOVFF  113,13F
0AE2:  MOVFF  112,13E
0AE6:  CLRF   x41
0AE8:  MOVFF  11C,140
0AEC:  MOVLB  0
0AEE:  BRA    0728
0AF0:  MOVFF  02,115
0AF4:  MOVFF  01,114
....................  
.................... 	if (count_of_clusters <4085 || count_of_clusters>65525) return(17); 
0AF8:  MOVLB  1
0AFA:  MOVF   x15,W
0AFC:  SUBLW  0F
0AFE:  BNC   0B08
0B00:  BNZ   0B18
0B02:  MOVF   x14,W
0B04:  SUBLW  F4
0B06:  BC    0B18
0B08:  MOVF   x15,W
0B0A:  SUBLW  FE
0B0C:  BC    0B1E
0B0E:  XORLW  FF
0B10:  BNZ   0B18
0B12:  MOVF   x14,W
0B14:  SUBLW  F5
0B16:  BC    0B1E
0B18:  MOVLW  11
0B1A:  MOVWF  01
0B1C:  BRA    0B3A
....................  
.................... 	winhex_adj=fat1_address-bytes_per_sector; 
0B1E:  MOVF   x0E,W
0B20:  SUBWF  07,W
0B22:  MOVWF  17
0B24:  MOVF   x0F,W
0B26:  SUBWFB 08,W
0B28:  MOVWF  18
0B2A:  MOVLW  00
0B2C:  SUBWFB 09,W
0B2E:  MOVWF  19
0B30:  MOVLW  00
0B32:  SUBWFB 0A,W
0B34:  MOVWF  1A
....................  
.................... 	#if MMC_INIT_TRACE 
....................  
.................... 		printf("Files:/n/r"); 
.................... 		for(i=0;i<MAX_FILES;i++){ 
.................... 			printf("/n/r",file[i].name[i]); 
.................... 		} 
....................  
.................... 	#ENDIF 
....................  
.................... 	return(0); 
0B36:  MOVLW  00
0B38:  MOVWF  01
.................... } 
0B3A:  MOVLB  0
0B3C:  GOTO   1F6A (RETURN)
....................  
....................  
.................... #separate 
.................... int get_CID(char s){ 
.................... 	int i,r1; 
.................... 	r1=mmc_cmd(0x4A,0x00000000,16,0x00,0x99); 
....................  
....................  
.................... 	if (r1==0x00) goto get_token ; // we can read data payload 
....................  
.................... 	return(false); 
.................... 	get_token: 
.................... 	for(i=0;i<16;i++)if (SPI_READ(0xFF)==0xFE) goto read_CID; // read token $FE 
.................... 	return(false); 
.................... 	read_CID: 
.................... 	//for (i=0;i<18;i++) s[i]=SPI_READ(0xFF); 
....................  
.................... 	return(true); 
.................... } 
....................  
....................  
.................... #separate 
.................... int get_CSD(char s){ 
.................... 	int i,r1; 
.................... 	r1=mmc_cmd(0x4A,0x00000000,16,0x00,0x99); 
....................  
....................  
.................... 	if (r1==0x00) goto get_token ; // we can read data payload 
....................  
.................... 	return(false); 
.................... 	get_token: 
.................... 	for(i=0;i<16;i++)if (SPI_READ(0xFF)==0xFE) goto read_CSD; // read token $FE 
.................... 	return(false); 
.................... 	read_CSD: 
.................... 	//for(i=0;i<18;i++) s[i]=SPI_READ(0xFF); 
....................  
.................... 	return(true); 
.................... } 
....................  
....................  
.................... #separate 
.................... int write_BLOCK( int32 address,char *buff,int16 size) 
.................... { 
.................... 	/// low level write ....MMC restriction is that exactly 512 bytes must be written 
.................... 	/// so a 512 byte section is read in starting at address the first (size) bytes 
.................... 	/// are over written with the new data and the updated 512 bytes written back 
.................... 	/// the starting address of the block that contains the requeseted address 
.................... 	/// 
.................... 	/// the data may span a block if so it is split and two writes are done 
.................... 	/// so as to maitain MMC 512 write boundary restrictions 
....................  
.................... 	int r1,a,b,c,d; 
.................... 	int16 i,blk_offset,bytes_posted; 
.................... 	char tmp_buff[512]; 
.................... 	int32 block_address; 
....................  
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("addr=%lu",address); 
.................... 	#endif 
....................  
.................... 	a=make8(address,3); 
.................... 	b=make8(address,2); 
.................... 	c=make8(address,1); 
.................... 	c=c & 0b11111110; 
.................... 	d=0; 
.................... 	block_address=make32(a,b,c,d); //// address int divided by 512 
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("wb>> size=%lu payload=",size); 
.................... 		for(i=0;i<size;i++)printf("%c",buff[i]); 
.................... 	#endif 
....................  
.................... 	/// first set up the block size to 512 
.................... 	if(set_BLOCKLEN((int32)512)==false) return(false); // sets global block_size 
....................  
.................... 	if(block_size!=512) return(false); 
.................... 	bytes_posted=0; /// no data updated yet 
....................  
.................... 	//////////////////////////////////////////////// 
.................... 	next_block: /// loop back here for second block 
.................... 	//////////////////////////////////////////////// 
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("\n\r blk addr=%lu \n\r",block_address); 
.................... 	#endif 
....................  
.................... 	if((block_address < data_area_address) && MMC_dir_protected) return(false); 
....................  
.................... 	MMC_dir_protected=true; 
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("read blk"); 
.................... 	#endif 
.................... 	/// first read in the existing block 
.................... 	if(read_block(block_address,tmp_buff)==false) return(false) ; 
....................  
....................  
....................  
.................... 	/// now update the block with new data 
.................... 	blk_offset=(address - block_address); /// offset within the block 
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("blk_offset=%lu size=%lu",blk_offset,size); 
.................... 	#endif 
....................  
.................... 	if( blk_offset + size > 512 ){ 
.................... 		// data spans the block so write to end of block first 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			//// original data 
.................... 			printf("\n\r spans wb="); 
.................... 			for(i=blk_offset;i<512;i++)printf("%c",tmp_buff[i]); 
.................... 		#endif 
....................  
.................... 		for (i=blk_offset;i < 512;i++)tmp_buff[i]=buff[i-blk_offset]; 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			/// updated data 
.................... 			printf("\n\r spans wb*="); 
.................... 			for(i=blk_offset;i<512;i++)printf("%c",tmp_buff[i]); 
.................... 		#endif 
....................  
.................... 		bytes_posted=512-blk_offset; /// wrote from offset to end of block 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			printf("\n\r posted=%lu",bytes_posted); 
.................... 		#endif 
....................  
.................... 	} 
.................... 	else{ 
.................... 		//original or remaining spanned block data fits in next block or original block 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			printf(" blk offset=%lu",blk_offset); 
.................... 			/// original data 
.................... 			printf("\n\r wb="); 
.................... 			for(i=blk_offset;i<blk_offset+size;i++)printf("%c",tmp_buff[i]); 
.................... 		#endif 
....................  
.................... 		for (i=blk_offset;i<blk_offset+ size;i++)tmp_buff[i]=buff[bytes_posted+i-blk_offset]; 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			/// updated data 
.................... 			printf("\n\r wb*="); 
.................... 			for(i=blk_offset;i<blk_offset+size;i++)printf("%c",tmp_buff[i]); 
.................... 		#endif 
....................  
.................... 		bytes_posted=size; 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			printf("\n\r posted=%lu",bytes_posted); 
.................... 		#endif 
....................  
.................... 	} 
....................  
.................... 	/////////////////////////////////// 
.................... 	/////////// write out the block 
.................... 	////////////////////////////////// 
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("wb>> writing block %lu",block_address); 
.................... 	#endif 
.................... 	r1=mmc_cmd(0x58,block_address,16,0x00,0x40); 
....................  
....................  
.................... 	if (r1==0x00) goto send_token ; // we can send data payload 
.................... 	if (r1==0x40) goto invalid; 
....................  
....................  
.................... 	return(false); 
.................... invalid: 
.................... 	printf("\n\r write block err %2X\n\r",r1); 
.................... 	return(false); 
.................... 	send_token: 
.................... 	SPI_READ(0xFE); 
....................  
.................... 	for (i=0;i < 512;i++) { 
....................  
.................... 		SPI_READ(tmp_buff[i]); /// send payload 
.................... 	} 
....................  
....................  
.................... 	SPI_READ(0xFF); // send dummy chcksum 
.................... 	SPI_READ(0xFF); 
.................... 	r1=SPI_READ(0xFF); 
.................... 	for( i=0;i<0x0fff;i++) { 
.................... 		r1=SPI_READ(0xFF);// digest prior operation 
.................... 		if (r1!=0x00) break; 
.................... 	} 
....................  
.................... 	if(size > bytes_posted){ 
.................... 		/// data spanned block so we need to upadte next block as well 
.................... 		size=size-bytes_posted; 
.................... 		block_address=block_address+512;/// advance a block 
....................  
.................... 		address=address+bytes_posted; /// move address ptr forward 
....................  
.................... 		goto next_block; 
.................... 	} 
....................  
....................  
.................... 	return(true); 
.................... } 
....................  
....................  
.................... #separate 
.................... void dump_block(){ 
.................... 	int in_buff[12],c,i,j; 
.................... 	int32 read_address; 
.................... 	char buff[MMC_BUFF_SIZE+1]; 
.................... 	for(i=0;i<12;i++)in_buff[i]=0; 
.................... 	printf("\n\r Input Start address:"); 
.................... 	j=0; 
.................... 	do { 
.................... 		c=getc(); 
.................... 		in_buff[j++]=c; 
.................... 		putc(c); 
.................... 	} 
.................... 	while(c!=13); 
.................... 	in_buff[j-1]=0; 
....................  
.................... 	read_address=atoint32(in_buff); 
.................... 	if (read_BLOCK(read_address,buff)==true){ 
.................... 		printf(" BLOCK\n\r"); 
.................... 		for(j=0;j<MMC_BUFF_SIZE;j=j+8){ 
.................... 			printf("%4LX ",read_address+j); 
.................... 			for(i=0;i<8;i++)printf(" %2X",buff[i+j]); 
.................... 			printf("\n\r"); 
....................  
.................... 		} 
.................... 	} 
.................... 	else printf("\n\r read_BLOCK failed"); 
....................  
.................... } 
....................  
....................  
.................... #separate 
.................... int32 cluster_addr(int fnbr,int mode){ 
.................... 	int32 address; 
.................... 	char buff[2]; //// buffer for 2 byte ptrs 
.................... 	///// returns the physical address in the data area of the data pointed to by either the 
.................... 	///// root cluster or the next cluster in the chain 
.................... 	///// 
.................... 	///// if ROOT_CLUSTER is called then this routine returns the address of the first cluster 
.................... 	///// and assigns this_cluster_ptr and next_cluster_ptr 
.................... 	///// 
.................... 	///// if NEXT_CLUSTER is called then this routine returns the address of the next cluster 
.................... 	///// using the existing next_cluster ptr number 
.................... 	///// and moves the existing next_cluster ptr number into this_cluster 
.................... 	///// and assigns the new next cluster ptr number (FFFF) if at the end of chain 
.................... 	///// if NEXT_CLUSTER is called and the next_cluster_ptr number is FFFF 
.................... 	///// an address of FFFFFFFF is returned 
....................  
.................... 	///// uses the globals cluster_size_bytes,data_area_address 
.................... 	//// file struct has the base=root cluster ptr, current=this cluster ptr ,next =cluster chain ptr 
....................  
.................... 	//// !!!! a call with NEXT_cluster must have a valid next_cluster_ptr value 
.................... 	//// !!!! a call to THIS CLUSTER must have a valid this_cluster_ptr 
....................  
.................... 	//// !!!! Fopen logic considers the cluster prt in the directory tile 
.................... 	//// to be a next=next_cluster_ptr so NEXT_CLUSTER is used to calc the physical address 
.................... 	//// of the first root cluster this also assigns the current=this_cluster_ptr 
.................... 	/// and fetches the next cluster prt 
.................... 	//// 
.................... 	#IF MMC_CLUSTER_TRACE // if true prints to serial port 
.................... 		printf("\n\r cluster addr>> next_cluster_ptr= %lu this_cluster=%lu \r\n",file[fnbr].next_cluster_ptr,file[fnbr].this_cluster_ptr); 
.................... 	#ENDIF 
.................... 	if (mode==NEXT_CLUSTER){ 
*
0B90:  MOVLB  1
0B92:  DECFSZ x49,W
0B94:  BRA    0DAC
.................... 		///access the next cluster in the chain 
.................... 		/// requires a valid this_cluster_ptr number and a valid next_cluster_ptr number 
....................  
.................... 		if(file[fnbr].next_cluster_ptr==0xFFFF){ 
0B96:  MOVF   x48,W
0B98:  MULLW  3D
0B9A:  MOVF   FF3,W
0B9C:  CLRF   x51
0B9E:  MOVWF  x50
0BA0:  MOVLW  29
0BA2:  ADDWF  x50,W
0BA4:  MOVWF  01
0BA6:  MOVLW  00
0BA8:  ADDWFC x51,W
0BAA:  MOVWF  03
0BAC:  MOVF   01,W
0BAE:  ADDLW  21
0BB0:  MOVWF  FE9
0BB2:  MOVLW  00
0BB4:  ADDWFC 03,W
0BB6:  MOVWF  FEA
0BB8:  MOVFF  FEC,151
0BBC:  MOVF   FED,F
0BBE:  MOVFF  FEF,150
0BC2:  INCFSZ x50,W
0BC4:  BRA    0BD6
0BC6:  INCFSZ x51,W
0BC8:  BRA    0BD6
.................... 			#IF MMC_CLUSTER_TRACE // if true prints to serial port 
.................... 				printf("last cluster"); 
.................... 			#ENDIF 
.................... 			address=0XFFFFFFFF; 
0BCA:  MOVLW  FF
0BCC:  MOVWF  x4D
0BCE:  MOVWF  x4C
0BD0:  MOVWF  x4B
0BD2:  MOVWF  x4A
.................... 		} 
.................... 		else{ 
0BD4:  BRA    0DAC
.................... 			if(set_BLOCKLEN((int32)2)==false) return(35); /// set up to read 2 bytes 
0BD6:  CLRF   x55
0BD8:  CLRF   x54
0BDA:  CLRF   x53
0BDC:  MOVLW  02
0BDE:  MOVWF  x52
0BE0:  MOVLB  0
0BE2:  RCALL  058C
0BE4:  MOVF   01,F
0BE6:  BNZ   0BF4
0BE8:  MOVLW  23
0BEA:  MOVWF  00
0BEC:  CLRF   01
0BEE:  CLRF   02
0BF0:  CLRF   03
0BF2:  BRA    0FEC
.................... 			if(read_BLOCK(fat1_address+(file[fnbr].next_cluster_ptr)*2,buff)==false) return(33); 
0BF4:  MOVLB  1
0BF6:  MOVF   x48,W
0BF8:  MULLW  3D
0BFA:  MOVF   FF3,W
0BFC:  CLRF   x51
0BFE:  MOVWF  x50
0C00:  MOVLW  29
0C02:  ADDWF  x50,W
0C04:  MOVWF  01
0C06:  MOVLW  00
0C08:  ADDWFC x51,W
0C0A:  MOVWF  03
0C0C:  MOVF   01,W
0C0E:  ADDLW  21
0C10:  MOVWF  FE9
0C12:  MOVLW  00
0C14:  ADDWFC 03,W
0C16:  MOVWF  FEA
0C18:  MOVFF  FEC,151
0C1C:  MOVF   FED,F
0C1E:  MOVFF  FEF,150
0C22:  BCF    FD8.0
0C24:  RLCF   x50,W
0C26:  MOVWF  02
0C28:  RLCF   x51,W
0C2A:  MOVWF  03
0C2C:  MOVF   02,W
0C2E:  ADDWF  07,W
0C30:  MOVWF  x50
0C32:  MOVF   03,W
0C34:  ADDWFC 08,W
0C36:  MOVWF  x51
0C38:  MOVLW  00
0C3A:  ADDWFC 09,W
0C3C:  MOVWF  x52
0C3E:  MOVLW  00
0C40:  ADDWFC 0A,W
0C42:  MOVWF  x53
0C44:  MOVWF  x57
0C46:  MOVFF  152,156
0C4A:  MOVFF  151,155
0C4E:  MOVFF  150,154
0C52:  MOVLW  01
0C54:  MOVWF  x59
0C56:  MOVLW  4E
0C58:  MOVWF  x58
0C5A:  MOVLB  0
0C5C:  RCALL  05E2
0C5E:  MOVF   01,F
0C60:  BNZ   0C6E
0C62:  MOVLW  21
0C64:  MOVWF  00
0C66:  CLRF   01
0C68:  CLRF   02
0C6A:  CLRF   03
0C6C:  BRA    0FEC
.................... 			file[fnbr].this_cluster_ptr=file[fnbr].next_cluster_ptr; // update current with prev next in chain 
0C6E:  MOVLB  1
0C70:  MOVF   x48,W
0C72:  MULLW  3D
0C74:  MOVF   FF3,W
0C76:  CLRF   x51
0C78:  MOVWF  x50
0C7A:  MOVLW  27
0C7C:  ADDWF  x50,W
0C7E:  MOVWF  01
0C80:  MOVLW  00
0C82:  ADDWFC x51,W
0C84:  MOVWF  03
0C86:  MOVF   01,W
0C88:  ADDLW  21
0C8A:  MOVWF  01
0C8C:  MOVLW  00
0C8E:  ADDWFC 03,F
0C90:  MOVFF  01,150
0C94:  MOVFF  03,151
0C98:  MOVF   x48,W
0C9A:  MULLW  3D
0C9C:  MOVF   FF3,W
0C9E:  CLRF   x53
0CA0:  MOVWF  x52
0CA2:  MOVLW  29
0CA4:  ADDWF  x52,W
0CA6:  MOVWF  01
0CA8:  MOVLW  00
0CAA:  ADDWFC x53,W
0CAC:  MOVWF  03
0CAE:  MOVF   01,W
0CB0:  ADDLW  21
0CB2:  MOVWF  FE9
0CB4:  MOVLW  00
0CB6:  ADDWFC 03,W
0CB8:  MOVWF  FEA
0CBA:  MOVFF  FEC,03
0CBE:  MOVF   FED,F
0CC0:  MOVFF  FEF,152
0CC4:  MOVFF  151,FEA
0CC8:  MOVFF  150,FE9
0CCC:  MOVFF  03,FEC
0CD0:  MOVF   FED,F
0CD2:  MOVFF  152,FEF
.................... 			file[fnbr].next_cluster_ptr=make16(buff[1],buff[0]); /// update next in chain 
0CD6:  MOVF   x48,W
0CD8:  MULLW  3D
0CDA:  MOVF   FF3,W
0CDC:  CLRF   x51
0CDE:  MOVWF  x50
0CE0:  MOVLW  29
0CE2:  ADDWF  x50,W
0CE4:  MOVWF  01
0CE6:  MOVLW  00
0CE8:  ADDWFC x51,W
0CEA:  MOVWF  03
0CEC:  MOVF   01,W
0CEE:  ADDLW  21
0CF0:  MOVWF  FE9
0CF2:  MOVLW  00
0CF4:  ADDWFC 03,W
0CF6:  MOVWF  FEA
0CF8:  MOVFF  14F,FEC
0CFC:  MOVF   FED,F
0CFE:  MOVFF  14E,FEF
....................  
.................... 			address=((int32)file[fnbr].this_cluster_ptr-(int32)2)*(int32)cluster_size_bytes+ 
.................... 			data_area_address; 
0D02:  MOVF   x48,W
0D04:  MULLW  3D
0D06:  MOVF   FF3,W
0D08:  CLRF   x51
0D0A:  MOVWF  x50
0D0C:  MOVLW  27
0D0E:  ADDWF  x50,W
0D10:  MOVWF  01
0D12:  MOVLW  00
0D14:  ADDWFC x51,W
0D16:  MOVWF  03
0D18:  MOVF   01,W
0D1A:  ADDLW  21
0D1C:  MOVWF  FE9
0D1E:  MOVLW  00
0D20:  ADDWFC 03,W
0D22:  MOVWF  FEA
0D24:  MOVFF  FEC,03
0D28:  MOVF   FED,F
0D2A:  MOVFF  FEF,150
0D2E:  MOVFF  03,151
0D32:  CLRF   x52
0D34:  CLRF   x53
0D36:  MOVLW  02
0D38:  SUBWF  x50,F
0D3A:  MOVLW  00
0D3C:  SUBWFB x51,F
0D3E:  SUBWFB x52,F
0D40:  SUBWFB x53,F
0D42:  MOVFF  05,00
0D46:  MOVFF  06,01
0D4A:  CLRF   02
0D4C:  CLRF   03
0D4E:  MOVFF  03,157
0D52:  MOVFF  02,156
0D56:  MOVFF  06,155
0D5A:  MOVFF  05,154
0D5E:  MOVFF  FEA,159
0D62:  MOVFF  FE9,158
0D66:  MOVFF  153,15D
0D6A:  MOVFF  152,15C
0D6E:  MOVFF  151,15B
0D72:  MOVFF  150,15A
0D76:  MOVFF  03,161
0D7A:  MOVFF  02,160
0D7E:  MOVFF  06,15F
0D82:  MOVFF  05,15E
0D86:  MOVLB  0
0D88:  RCALL  06CE
0D8A:  MOVFF  159,FEA
0D8E:  MOVFF  158,FE9
0D92:  MOVF   13,W
0D94:  MOVLB  1
0D96:  ADDWF  00,W
0D98:  MOVWF  x4A
0D9A:  MOVF   14,W
0D9C:  ADDWFC 01,W
0D9E:  MOVWF  x4B
0DA0:  MOVF   15,W
0DA2:  ADDWFC 02,W
0DA4:  MOVWF  x4C
0DA6:  MOVF   16,W
0DA8:  ADDWFC 03,W
0DAA:  MOVWF  x4D
....................  
.................... 		} 
.................... 	} 
.................... 	if (mode==ROOT_CLUSTER){ 
0DAC:  MOVF   x49,F
0DAE:  BTFSS  FD8.2
0DB0:  BRA    0F8E
.................... 		//// root_cluster_ptr was assigned from the file tile in fopen 
.................... 		file[fnbr].this_cluster_ptr=file[fnbr].root_cluster_ptr; 
0DB2:  MOVF   x48,W
0DB4:  MULLW  3D
0DB6:  MOVF   FF3,W
0DB8:  CLRF   x51
0DBA:  MOVWF  x50
0DBC:  MOVLW  27
0DBE:  ADDWF  x50,W
0DC0:  MOVWF  01
0DC2:  MOVLW  00
0DC4:  ADDWFC x51,W
0DC6:  MOVWF  03
0DC8:  MOVF   01,W
0DCA:  ADDLW  21
0DCC:  MOVWF  01
0DCE:  MOVLW  00
0DD0:  ADDWFC 03,F
0DD2:  MOVFF  01,150
0DD6:  MOVFF  03,151
0DDA:  MOVF   x48,W
0DDC:  MULLW  3D
0DDE:  MOVF   FF3,W
0DE0:  CLRF   x53
0DE2:  MOVWF  x52
0DE4:  MOVLW  25
0DE6:  ADDWF  x52,W
0DE8:  MOVWF  01
0DEA:  MOVLW  00
0DEC:  ADDWFC x53,W
0DEE:  MOVWF  03
0DF0:  MOVF   01,W
0DF2:  ADDLW  21
0DF4:  MOVWF  FE9
0DF6:  MOVLW  00
0DF8:  ADDWFC 03,W
0DFA:  MOVWF  FEA
0DFC:  MOVFF  FEC,03
0E00:  MOVF   FED,F
0E02:  MOVFF  FEF,152
0E06:  MOVFF  151,FEA
0E0A:  MOVFF  150,FE9
0E0E:  MOVFF  03,FEC
0E12:  MOVF   FED,F
0E14:  MOVFF  152,FEF
.................... 		if(set_BLOCKLEN((int32)2)==false) return(35); /// set up to read 2 bytes 
0E18:  CLRF   x55
0E1A:  CLRF   x54
0E1C:  CLRF   x53
0E1E:  MOVLW  02
0E20:  MOVWF  x52
0E22:  MOVLB  0
0E24:  CALL   058C
0E28:  MOVF   01,F
0E2A:  BNZ   0E38
0E2C:  MOVLW  23
0E2E:  MOVWF  00
0E30:  CLRF   01
0E32:  CLRF   02
0E34:  CLRF   03
0E36:  BRA    0FEC
.................... 		if(read_BLOCK(fat1_address+(file[fnbr].this_cluster_ptr)*2,buff)==false) return(33); 
0E38:  MOVLB  1
0E3A:  MOVF   x48,W
0E3C:  MULLW  3D
0E3E:  MOVF   FF3,W
0E40:  CLRF   x51
0E42:  MOVWF  x50
0E44:  MOVLW  27
0E46:  ADDWF  x50,W
0E48:  MOVWF  01
0E4A:  MOVLW  00
0E4C:  ADDWFC x51,W
0E4E:  MOVWF  03
0E50:  MOVF   01,W
0E52:  ADDLW  21
0E54:  MOVWF  FE9
0E56:  MOVLW  00
0E58:  ADDWFC 03,W
0E5A:  MOVWF  FEA
0E5C:  MOVFF  FEC,151
0E60:  MOVF   FED,F
0E62:  MOVFF  FEF,150
0E66:  BCF    FD8.0
0E68:  RLCF   x50,W
0E6A:  MOVWF  02
0E6C:  RLCF   x51,W
0E6E:  MOVWF  03
0E70:  MOVF   02,W
0E72:  ADDWF  07,W
0E74:  MOVWF  x50
0E76:  MOVF   03,W
0E78:  ADDWFC 08,W
0E7A:  MOVWF  x51
0E7C:  MOVLW  00
0E7E:  ADDWFC 09,W
0E80:  MOVWF  x52
0E82:  MOVLW  00
0E84:  ADDWFC 0A,W
0E86:  MOVWF  x53
0E88:  MOVWF  x57
0E8A:  MOVFF  152,156
0E8E:  MOVFF  151,155
0E92:  MOVFF  150,154
0E96:  MOVLW  01
0E98:  MOVWF  x59
0E9A:  MOVLW  4E
0E9C:  MOVWF  x58
0E9E:  MOVLB  0
0EA0:  CALL   05E2
0EA4:  MOVF   01,F
0EA6:  BNZ   0EB4
0EA8:  MOVLW  21
0EAA:  MOVWF  00
0EAC:  CLRF   01
0EAE:  CLRF   02
0EB0:  CLRF   03
0EB2:  BRA    0FEC
.................... 		file[fnbr].next_cluster_ptr=make16(buff[1],buff[0]); /// update next in chain 
0EB4:  MOVLB  1
0EB6:  MOVF   x48,W
0EB8:  MULLW  3D
0EBA:  MOVF   FF3,W
0EBC:  CLRF   x51
0EBE:  MOVWF  x50
0EC0:  MOVLW  29
0EC2:  ADDWF  x50,W
0EC4:  MOVWF  01
0EC6:  MOVLW  00
0EC8:  ADDWFC x51,W
0ECA:  MOVWF  03
0ECC:  MOVF   01,W
0ECE:  ADDLW  21
0ED0:  MOVWF  FE9
0ED2:  MOVLW  00
0ED4:  ADDWFC 03,W
0ED6:  MOVWF  FEA
0ED8:  MOVFF  14F,FEC
0EDC:  MOVF   FED,F
0EDE:  MOVFF  14E,FEF
.................... 		address=((int32)file[fnbr].this_cluster_ptr-(int32)2)*(int32)cluster_size_bytes+ 
.................... 		data_area_address; 
0EE2:  MOVF   x48,W
0EE4:  MULLW  3D
0EE6:  MOVF   FF3,W
0EE8:  CLRF   x51
0EEA:  MOVWF  x50
0EEC:  MOVLW  27
0EEE:  ADDWF  x50,W
0EF0:  MOVWF  01
0EF2:  MOVLW  00
0EF4:  ADDWFC x51,W
0EF6:  MOVWF  03
0EF8:  MOVF   01,W
0EFA:  ADDLW  21
0EFC:  MOVWF  FE9
0EFE:  MOVLW  00
0F00:  ADDWFC 03,W
0F02:  MOVWF  FEA
0F04:  MOVFF  FEC,03
0F08:  MOVF   FED,F
0F0A:  MOVFF  FEF,150
0F0E:  MOVFF  03,151
0F12:  CLRF   x52
0F14:  CLRF   x53
0F16:  MOVLW  02
0F18:  SUBWF  x50,F
0F1A:  MOVLW  00
0F1C:  SUBWFB x51,F
0F1E:  SUBWFB x52,F
0F20:  SUBWFB x53,F
0F22:  MOVFF  05,00
0F26:  MOVFF  06,01
0F2A:  CLRF   02
0F2C:  CLRF   03
0F2E:  MOVFF  03,157
0F32:  MOVFF  02,156
0F36:  MOVFF  06,155
0F3A:  MOVFF  05,154
0F3E:  MOVFF  FEA,159
0F42:  MOVFF  FE9,158
0F46:  MOVFF  153,15D
0F4A:  MOVFF  152,15C
0F4E:  MOVFF  151,15B
0F52:  MOVFF  150,15A
0F56:  MOVFF  03,161
0F5A:  MOVFF  02,160
0F5E:  MOVFF  06,15F
0F62:  MOVFF  05,15E
0F66:  MOVLB  0
0F68:  CALL   06CE
0F6C:  MOVFF  159,FEA
0F70:  MOVFF  158,FE9
0F74:  MOVF   13,W
0F76:  MOVLB  1
0F78:  ADDWF  00,W
0F7A:  MOVWF  x4A
0F7C:  MOVF   14,W
0F7E:  ADDWFC 01,W
0F80:  MOVWF  x4B
0F82:  MOVF   15,W
0F84:  ADDWFC 02,W
0F86:  MOVWF  x4C
0F88:  MOVF   16,W
0F8A:  ADDWFC 03,W
0F8C:  MOVWF  x4D
....................  
.................... 	} 
....................  
.................... 	// printf("clust addr call fnbr=%u blk_size=%lu",fnbr,file[fnbr].rec_size); 
....................  
.................... 	if(set_BLOCKLEN(file[fnbr].rec_size)==false) return(37); /// reset to original rec_size 
0F8E:  MOVF   x48,W
0F90:  MULLW  3D
0F92:  MOVF   FF3,W
0F94:  CLRF   x51
0F96:  MOVWF  x50
0F98:  MOVLW  3B
0F9A:  ADDWF  x50,W
0F9C:  MOVWF  01
0F9E:  MOVLW  00
0FA0:  ADDWFC x51,W
0FA2:  MOVWF  03
0FA4:  MOVF   01,W
0FA6:  ADDLW  21
0FA8:  MOVWF  FE9
0FAA:  MOVLW  00
0FAC:  ADDWFC 03,W
0FAE:  MOVWF  FEA
0FB0:  MOVFF  FEC,151
0FB4:  MOVF   FED,F
0FB6:  MOVFF  FEF,150
0FBA:  CLRF   x55
0FBC:  CLRF   x54
0FBE:  MOVFF  151,153
0FC2:  MOVFF  150,152
0FC6:  MOVLB  0
0FC8:  CALL   058C
0FCC:  MOVF   01,F
0FCE:  BNZ   0FDC
0FD0:  MOVLW  25
0FD2:  MOVWF  00
0FD4:  CLRF   01
0FD6:  CLRF   02
0FD8:  CLRF   03
0FDA:  BRA    0FEC
....................  
.................... 	#IF MMC_CLUSTER_TRACE // if true prints to serial port 
.................... 		printf("\n\r cluster addr>> next_cluster_ptr*= %lu this_cluster*=%lu \r\n",file[fnbr].next_cluster_ptr,file[fnbr].this_cluster_ptr); 
.................... 	#ENDIF return(address); 
0FDC:  MOVFF  14A,00
0FE0:  MOVFF  14B,01
0FE4:  MOVFF  14C,02
0FE8:  MOVFF  14D,03
.................... } 
0FEC:  RETLW  00
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////////// OPEN FILE /////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////////// 
.................... #separate 
.................... int open_file(int fnbr,char *fname,int16 rec_length){ 
.................... 	int32 dir_addr_ptr; 
.................... 	int16 bytes_read; 
.................... 	int i,ptr1,ptr2,lnf_tiles,j; 
.................... 	char file_name[12]; 
.................... 	int attribute,directory,archive; 
.................... 	char tmp; 
.................... 	char buff[32]; //// buffer for 32 byte tiles 
....................  
.................... 	int level; /// level in the directory structure 0 is top 
.................... 	/////// directory is searched and if file is found 
....................  
.................... 	////// 
.................... 	////// init_MMC(tries) must be called first 
.................... 	////// uses globals root_dir_address 
....................  
.................... 	//start by searching the root directory for folder or file 
....................  
.................... 	/// assign an inital next_cluster_ptr in the root directory 
.................... 	file[fnbr].next_cluster_ptr=0; 
*
1080:  MOVLB  1
1082:  MOVF   x05,W
1084:  MULLW  3D
1086:  MOVF   FF3,W
1088:  CLRF   x47
108A:  MOVWF  x46
108C:  MOVLW  29
108E:  ADDWF  x46,W
1090:  MOVWF  01
1092:  MOVLW  00
1094:  ADDWFC x47,W
1096:  MOVWF  03
1098:  MOVF   01,W
109A:  ADDLW  21
109C:  MOVWF  FE9
109E:  MOVLW  00
10A0:  ADDWFC 03,W
10A2:  MOVWF  FEA
10A4:  CLRF   FEC
10A6:  MOVF   FED,F
10A8:  CLRF   FEF
.................... 	file[fnbr].this_cluster_ptr=0; 
10AA:  MOVF   x05,W
10AC:  MULLW  3D
10AE:  MOVF   FF3,W
10B0:  CLRF   x47
10B2:  MOVWF  x46
10B4:  MOVLW  27
10B6:  ADDWF  x46,W
10B8:  MOVWF  01
10BA:  MOVLW  00
10BC:  ADDWFC x47,W
10BE:  MOVWF  03
10C0:  MOVF   01,W
10C2:  ADDLW  21
10C4:  MOVWF  FE9
10C6:  MOVLW  00
10C8:  ADDWFC 03,W
10CA:  MOVWF  FEA
10CC:  CLRF   FEC
10CE:  MOVF   FED,F
10D0:  CLRF   FEF
....................  
.................... 	dir_addr_ptr=root_dir_address; 
10D2:  MOVFF  12,10D
10D6:  MOVFF  11,10C
10DA:  MOVFF  10,10B
10DE:  MOVFF  0F,10A
.................... 	file_name[11]=0; 
10E2:  CLRF   x20
.................... 	level=0; 
10E4:  CLRF   x45
.................... 	ptr1=0; 
10E6:  CLRF   x11
.................... 	ptr2=0; 
10E8:  CLRF   x12
.................... 	bytes_read=0; //// byte read so far in this cluster 
10EA:  CLRF   x0F
10EC:  CLRF   x0E
....................  
.................... 	read_directory: 
.................... 	/// extract the directory levels(folders) 
.................... 	while ((fname[ptr2]!='/') && (fname[ptr2]!='\\') && (fname[ptr2]!='\0') && (fname[ptr2]!='.') ){ 
10EE:  CLRF   03
10F0:  MOVF   x12,W
10F2:  ADDWF  x06,W
10F4:  MOVWF  FE9
10F6:  MOVF   x07,W
10F8:  ADDWFC 03,W
10FA:  MOVWF  FEA
10FC:  MOVF   FEF,W
10FE:  SUBLW  2F
1100:  BZ    114E
1102:  CLRF   03
1104:  MOVF   x12,W
1106:  ADDWF  x06,W
1108:  MOVWF  FE9
110A:  MOVF   x07,W
110C:  ADDWFC 03,W
110E:  MOVWF  FEA
1110:  MOVF   FEF,W
1112:  SUBLW  5C
1114:  BZ    114E
1116:  CLRF   03
1118:  MOVF   x12,W
111A:  ADDWF  x06,W
111C:  MOVWF  FE9
111E:  MOVF   x07,W
1120:  ADDWFC 03,W
1122:  MOVWF  FEA
1124:  MOVF   FEF,F
1126:  BZ    114E
1128:  CLRF   03
112A:  MOVF   x12,W
112C:  ADDWF  x06,W
112E:  MOVWF  FE9
1130:  MOVF   x07,W
1132:  ADDWFC 03,W
1134:  MOVWF  FEA
1136:  MOVF   FEF,W
1138:  SUBLW  2E
113A:  BZ    114E
.................... 		// a dos directory (folder) name can not exceed 8 chars 
.................... 		if ((ptr2-ptr1)>7) return (20); 
113C:  MOVF   x11,W
113E:  SUBWF  x12,W
1140:  SUBLW  07
1142:  BC    114A
1144:  MOVLW  14
1146:  MOVWF  01
1148:  BRA    1688
.................... 		ptr2++; 
114A:  INCF   x12,F
.................... 	} 
.................... 	#IF MMC_OPEN_TRACE 
114C:  BRA    10EE
.................... 		printf("\n\r fopen ptr1=%u ptr2=%u ",ptr1,ptr2); 
.................... 	#ENDIF 
....................  
.................... 	if (ptr2==0){ ptr2=1;ptr1=1;goto read_directory;} /// skip a leading '/' or '\' 
114E:  MOVF   x12,F
1150:  BNZ   115A
1152:  MOVLW  01
1154:  MOVWF  x12
1156:  MOVWF  x11
1158:  BRA    10EE
.................... 	if ((ptr2-ptr1)==0) return (21); 
115A:  MOVF   x11,W
115C:  SUBWF  x12,W
115E:  BNZ   1166
1160:  MOVLW  15
1162:  MOVWF  01
1164:  BRA    1688
....................  
.................... 	// ptr1 is the chars processed so far 
.................... 	// ptr2 is the position of '/' or '\' or '.' or '\0' 
.................... 	// prepare the file or directory name fomat is cccccccceee 
.................... 	// c is a valid letter or blank eee is extension or blank 
.................... 	// a directory name is 'cccccccc ' a file 'cccccccceee' always 11 chars 
.................... 	for(i=0;i<11;i++)file_name[i]=32;//blank 
1166:  CLRF   x10
1168:  MOVF   x10,W
116A:  SUBLW  0A
116C:  BNC   1184
116E:  CLRF   03
1170:  MOVF   x10,W
1172:  ADDLW  15
1174:  MOVWF  FE9
1176:  MOVLW  01
1178:  ADDWFC 03,W
117A:  MOVWF  FEA
117C:  MOVLW  20
117E:  MOVWF  FEF
1180:  INCF   x10,F
1182:  BRA    1168
.................... 	file_name[11]=0; 
1184:  CLRF   x20
.................... 	i=0; 
1186:  CLRF   x10
.................... 	while(ptr1<ptr2){ 
1188:  MOVF   x12,W
118A:  SUBWF  x11,W
118C:  BC    11CE
.................... 		// extract the name 
....................  
.................... 		tmp=fname[ptr1]; 
118E:  CLRF   03
1190:  MOVF   x11,W
1192:  ADDWF  x06,W
1194:  MOVWF  FE9
1196:  MOVF   x07,W
1198:  ADDWFC 03,W
119A:  MOVWF  FEA
119C:  MOVFF  FEF,124
.................... 		tmp=TOUPPER(tmp); 
11A0:  MOVF   x24,W
11A2:  SUBLW  60
11A4:  BC    11B2
11A6:  MOVF   x24,W
11A8:  SUBLW  7A
11AA:  BNC   11B2
11AC:  MOVF   x24,W
11AE:  ANDLW  DF
11B0:  BRA    11B4
11B2:  MOVF   x24,W
11B4:  MOVWF  x24
.................... 		file_name[i]=tmp; 
11B6:  CLRF   03
11B8:  MOVF   x10,W
11BA:  ADDLW  15
11BC:  MOVWF  FE9
11BE:  MOVLW  01
11C0:  ADDWFC 03,W
11C2:  MOVWF  FEA
11C4:  MOVFF  124,FEF
.................... 		ptr1++;i++; 
11C8:  INCF   x11,F
11CA:  INCF   x10,F
.................... 	} 
11CC:  BRA    1188
.................... 	if(fname[ptr2]=='.'){ 
11CE:  CLRF   03
11D0:  MOVF   x12,W
11D2:  ADDWF  x06,W
11D4:  MOVWF  FE9
11D6:  MOVF   x07,W
11D8:  ADDWFC 03,W
11DA:  MOVWF  FEA
11DC:  MOVF   FEF,W
11DE:  SUBLW  2E
11E0:  BNZ   123A
.................... 		// extract the extension 
.................... 		i=8; 
11E2:  MOVLW  08
11E4:  MOVWF  x10
.................... 		while((fname[ptr1]!='\0') && (i<12)){ 
11E6:  CLRF   03
11E8:  MOVF   x11,W
11EA:  ADDWF  x06,W
11EC:  MOVWF  FE9
11EE:  MOVF   x07,W
11F0:  ADDWFC 03,W
11F2:  MOVWF  FEA
11F4:  MOVF   FEF,F
11F6:  BZ    123A
11F8:  MOVF   x10,W
11FA:  SUBLW  0B
11FC:  BNC   123A
.................... 			ptr1++; 
11FE:  INCF   x11,F
.................... 			tmp=fname[ptr1]; 
1200:  CLRF   03
1202:  MOVF   x11,W
1204:  ADDWF  x06,W
1206:  MOVWF  FE9
1208:  MOVF   x07,W
120A:  ADDWFC 03,W
120C:  MOVWF  FEA
120E:  MOVFF  FEF,124
.................... 			file_name[i]=TOUPPER(tmp); 
1212:  CLRF   03
1214:  MOVF   x10,W
1216:  ADDLW  15
1218:  MOVWF  FE9
121A:  MOVLW  01
121C:  ADDWFC 03,W
121E:  MOVWF  FEA
1220:  MOVF   x24,W
1222:  SUBLW  60
1224:  BC    1232
1226:  MOVF   x24,W
1228:  SUBLW  7A
122A:  BNC   1232
122C:  MOVF   x24,W
122E:  ANDLW  DF
1230:  BRA    1234
1232:  MOVF   x24,W
1234:  MOVWF  FEF
.................... 			i++; 
1236:  INCF   x10,F
.................... 		} 
1238:  BRA    11E6
.................... 	} 
.................... 	ptr1++; 
123A:  INCF   x11,F
.................... 	ptr2=ptr1; // advance over the '\' or '/' so next pass starts correctly 
123C:  MOVFF  111,112
.................... 	if (block_size!=(int32)32){ 
1240:  MOVF   1B,W
1242:  SUBLW  20
1244:  BNZ   1252
1246:  MOVF   1C,F
1248:  BNZ   1252
124A:  MOVF   1D,F
124C:  BNZ   1252
124E:  MOVF   1E,F
1250:  BZ    126E
.................... 		if(set_BLOCKLEN((int32)32)==false) return(17); /// tiles are 32 bytes 
1252:  CLRF   x55
1254:  CLRF   x54
1256:  CLRF   x53
1258:  MOVLW  20
125A:  MOVWF  x52
125C:  MOVLB  0
125E:  CALL   058C
1262:  MOVF   01,F
1264:  BNZ   1270
1266:  MOVLW  11
1268:  MOVWF  01
126A:  MOVLB  1
126C:  BRA    1688
126E:  MOVLB  0
.................... 	} 
.................... 	if (read_BLOCK(dir_addr_ptr,buff)==false) return(10); 
1270:  MOVFF  10D,157
1274:  MOVFF  10C,156
1278:  MOVFF  10B,155
127C:  MOVFF  10A,154
1280:  MOVLW  01
1282:  MOVLB  1
1284:  MOVWF  x59
1286:  MOVLW  25
1288:  MOVWF  x58
128A:  MOVLB  0
128C:  CALL   05E2
1290:  MOVF   01,F
1292:  BNZ   129E
1294:  MOVLW  0A
1296:  MOVWF  01
1298:  MOVLB  1
129A:  BRA    1688
129C:  MOVLB  0
....................  
.................... 	// decode the FAT16 entries 
.................... 	// a tile is 32 bytes 
.................... 	// std dos files take one tile 
.................... 	// a long file name has multiple tiles 
.................... 	// starting with the last down to the first and 
.................... 	// then a std dos tile is found 
.................... 	// byte 11 is 0x0f for LNF tiles and 0x00 for std 
.................... 	// we skip the LNF and goto STD tile 
....................  
.................... 	tile_decode: 
.................... 	lnf_tiles=0; 
129E:  MOVLB  1
12A0:  CLRF   x13
.................... 	if (buff[0]==0xE5) goto next_tile; ///0xE5 is the deleted file flag 
12A2:  MOVF   x25,W
12A4:  SUBLW  E5
12A6:  BNZ   12AA
12A8:  BRA    1470
.................... 	if (buff[0]==0x00){ 
12AA:  MOVF   x25,F
12AC:  BNZ   12E2
.................... 		printf("\n\r file err [%s] not found \n\r",file_name); 
12AE:  MOVLW  8A
12B0:  MOVWF  FF6
12B2:  MOVLW  00
12B4:  MOVWF  FF7
12B6:  MOVLW  0D
12B8:  MOVWF  x46
12BA:  MOVLB  0
12BC:  RCALL  0B40
12BE:  MOVLW  01
12C0:  MOVWF  FEA
12C2:  MOVLW  15
12C4:  MOVWF  FE9
12C6:  RCALL  0B6A
12C8:  MOVLW  99
12CA:  MOVWF  FF6
12CC:  MOVLW  00
12CE:  MOVWF  FF7
12D0:  MOVLW  0E
12D2:  MOVLB  1
12D4:  MOVWF  x46
12D6:  MOVLB  0
12D8:  RCALL  0B40
.................... 		return(11); /// file not found 
12DA:  MOVLW  0B
12DC:  MOVWF  01
12DE:  MOVLB  1
12E0:  BRA    1688
.................... 	} 
.................... 	if (buff[11]==0x0F){ 
12E2:  MOVF   x30,W
12E4:  SUBLW  0F
12E6:  BNZ   138E
.................... 		/// get number of LNF tiles 
.................... 		lnf_tiles=buff[0] & 0b00111111; 
12E8:  MOVF   x25,W
12EA:  ANDLW  3F
12EC:  MOVWF  x13
.................... 		bytes_read=bytes_read+lnf_tiles*32; 
12EE:  MOVF   x13,W
12F0:  MULLW  20
12F2:  MOVF   FF3,W
12F4:  ADDWF  x0E,F
12F6:  MOVLW  00
12F8:  ADDWFC x0F,F
.................... 		if(bytes_read>cluster_size_bytes){ 
12FA:  MOVF   06,W
12FC:  SUBWF  x0F,W
12FE:  BNC   1354
1300:  BNZ   1308
1302:  MOVF   x0E,W
1304:  SUBWF  05,W
1306:  BC    1354
.................... 			// compute next cluster address next_cluster_ptr must be valid 
.................... 			// assigns this_cluster_ptr 
....................  
.................... 			dir_addr_ptr=cluster_addr(fnbr,NEXT_CLUSTER); 
1308:  MOVFF  105,148
130C:  MOVLW  01
130E:  MOVWF  x49
1310:  MOVLB  0
1312:  RCALL  0B90
1314:  MOVFF  03,10D
1318:  MOVFF  02,10C
131C:  MOVFF  01,10B
1320:  MOVFF  00,10A
.................... 			if (dir_addr_ptr==0xFFFFFF) return (22); 
1324:  MOVLB  1
1326:  INCFSZ x0A,W
1328:  BRA    133C
132A:  INCFSZ x0B,W
132C:  BRA    133C
132E:  INCFSZ x0C,W
1330:  BRA    133C
1332:  MOVF   x0D,F
1334:  BNZ   133C
1336:  MOVLW  16
1338:  MOVWF  01
133A:  BRA    1688
.................... 			bytes_read=bytes_read-cluster_size_bytes; 
133C:  MOVF   05,W
133E:  SUBWF  x0E,F
1340:  MOVF   06,W
1342:  SUBWFB x0F,F
.................... 			dir_addr_ptr=dir_addr_ptr+bytes_read; 
1344:  MOVF   x0E,W
1346:  ADDWF  x0A,F
1348:  MOVF   x0F,W
134A:  ADDWFC x0B,F
134C:  MOVLW  00
134E:  ADDWFC x0C,F
1350:  ADDWFC x0D,F
.................... 		} 
.................... 		else{ 
1352:  BRA    1364
.................... 			dir_addr_ptr=dir_addr_ptr+lnf_tiles*32; 
1354:  MOVF   x13,W
1356:  MULLW  20
1358:  MOVF   FF3,W
135A:  ADDWF  x0A,F
135C:  MOVLW  00
135E:  ADDWFC x0B,F
1360:  ADDWFC x0C,F
1362:  ADDWFC x0D,F
.................... 		} 
....................  
.................... 		//advance over the lnf tiles 
.................... 		/// test to see if we need next cluster in chain 
.................... 		if (read_BLOCK(dir_addr_ptr,buff)==false) return(31); 
1364:  MOVFF  10D,157
1368:  MOVFF  10C,156
136C:  MOVFF  10B,155
1370:  MOVFF  10A,154
1374:  MOVLW  01
1376:  MOVWF  x59
1378:  MOVLW  25
137A:  MOVWF  x58
137C:  MOVLB  0
137E:  CALL   05E2
1382:  MOVF   01,F
1384:  BNZ   1390
1386:  MOVLW  1F
1388:  MOVWF  01
138A:  MOVLB  1
138C:  BRA    1688
138E:  MOVLB  0
.................... 		/// !!! may read into next sector 
.................... 	} 
....................  
....................  
.................... 	/// check out the standard DOS tile 
.................... 	#IF MMC_OPEN_TRACE 
.................... 		printf("\n\r fname[%s] level=%u \n\r",file_name,level); 
.................... 		for (j=0;j<11;j++)printf("%c",buff[j]); 
.................... 	#ENDIF 
.................... 	if(strncmp(buff,file_name, 11)==0){ ///8.3 file name ex "FILE EXT" "FOLDER " 
1390:  MOVLW  01
1392:  MOVLB  1
1394:  MOVWF  x47
1396:  MOVLW  25
1398:  MOVWF  x46
139A:  MOVLW  01
139C:  MOVWF  x49
139E:  MOVLW  15
13A0:  MOVWF  x48
13A2:  MOVLW  0B
13A4:  MOVWF  x4A
13A6:  MOVLB  0
13A8:  BRA    0FEE
13AA:  MOVF   01,F
13AC:  BNZ   1472
.................... 		// we have a file type or a sub directory(folder) 
.................... 		// so we get the starting cluster number 
.................... 		attribute=buff[11]; 
13AE:  MOVFF  130,121
....................  
.................... 		file[fnbr].root_cluster_ptr=make16(buff[27],buff[26]);/// assign initial cluster ptr 
13B2:  MOVLB  1
13B4:  MOVF   x05,W
13B6:  MULLW  3D
13B8:  MOVF   FF3,W
13BA:  CLRF   x47
13BC:  MOVWF  x46
13BE:  MOVLW  25
13C0:  ADDWF  x46,W
13C2:  MOVWF  01
13C4:  MOVLW  00
13C6:  ADDWFC x47,W
13C8:  MOVWF  03
13CA:  MOVF   01,W
13CC:  ADDLW  21
13CE:  MOVWF  FE9
13D0:  MOVLW  00
13D2:  ADDWFC 03,W
13D4:  MOVWF  FEA
13D6:  MOVFF  140,FEC
13DA:  MOVF   FED,F
13DC:  MOVFF  13F,FEF
.................... 		/// if it is not a directory 
.................... 		/// it points to the begining of the file 
.................... 		/// cluster chain 
....................  
....................  
....................  
.................... 		if ((attribute & 0b00010000)>0)directory=true; 
13E0:  MOVF   x21,W
13E2:  ANDLW  10
13E4:  BZ    13EC
13E6:  MOVLW  01
13E8:  MOVWF  x22
.................... 		else directory=false; 
13EA:  BRA    13EE
13EC:  CLRF   x22
.................... 		if ((attribute & 0b00100000)>0 || attribute==0){ 
13EE:  MOVF   x21,W
13F0:  ANDLW  20
13F2:  BNZ   13F8
13F4:  MOVF   x21,F
13F6:  BNZ   146C
.................... 			archive=true; //// we have our file 
13F8:  MOVLW  01
13FA:  MOVWF  x23
....................  
.................... 			file[fnbr].size=make32(buff[31],buff[30],buff[29],buff[28]); 
13FC:  MOVF   x05,W
13FE:  MULLW  3D
1400:  MOVF   FF3,W
1402:  CLRF   x47
1404:  MOVWF  x46
1406:  MOVLW  2F
1408:  ADDWF  x46,W
140A:  MOVWF  01
140C:  MOVLW  00
140E:  ADDWFC x47,W
1410:  MOVWF  03
1412:  MOVF   01,W
1414:  ADDLW  21
1416:  MOVWF  FE9
1418:  MOVLW  00
141A:  ADDWFC 03,W
141C:  MOVWF  FEA
141E:  MOVF   FEE,F
1420:  MOVF   FEE,F
1422:  MOVFF  144,FEC
1426:  MOVF   FED,F
1428:  MOVFF  143,FEF
142C:  MOVF   FED,F
142E:  MOVFF  142,FEF
1432:  MOVF   FED,F
1434:  MOVFF  141,FEF
.................... 			file[fnbr].dir_addr_ptr=dir_addr_ptr; ///save address of this files tile 
1438:  MOVF   x05,W
143A:  MULLW  3D
143C:  MOVF   FF3,W
143E:  CLRF   x47
1440:  MOVWF  x46
1442:  MOVLW  21
1444:  ADDWF  x46,W
1446:  MOVWF  01
1448:  MOVLW  00
144A:  ADDWFC x47,W
144C:  MOVWF  03
144E:  MOVF   01,W
1450:  ADDLW  21
1452:  MOVWF  FE9
1454:  MOVLW  00
1456:  ADDWFC 03,W
1458:  MOVWF  FEA
145A:  MOVFF  10A,FEF
145E:  MOVFF  10B,FEC
1462:  MOVFF  10C,FEC
1466:  MOVFF  10D,FEC
.................... 			/// assign global value 
.................... 		} 
.................... 		else archive=false; 
146A:  BRA    146E
146C:  CLRF   x23
....................  
....................  
....................  
.................... 		goto match_found; 
146E:  BRA    1520
1470:  MOVLB  0
.................... 		// goto fill_table; // we have a match 
.................... 	} 
.................... 	next_tile: 
.................... 	bytes_read=bytes_read+32; 
1472:  MOVLW  20
1474:  MOVLB  1
1476:  ADDWF  x0E,F
1478:  MOVLW  00
147A:  ADDWFC x0F,F
.................... 	if(bytes_read > cluster_size_bytes){ 
147C:  MOVF   06,W
147E:  SUBWF  x0F,W
1480:  BNC   14D8
1482:  BNZ   148A
1484:  MOVF   x0E,W
1486:  SUBWF  05,W
1488:  BC    14D8
.................... 		/// requires a valid next=next_cluster_ptr 
.................... 		// compute next cluster address and assign this cluster 
.................... 		dir_addr_ptr=cluster_addr(fnbr,NEXT_CLUSTER); 
148A:  MOVFF  105,148
148E:  MOVLW  01
1490:  MOVWF  x49
1492:  MOVLB  0
1494:  CALL   0B90
1498:  MOVFF  03,10D
149C:  MOVFF  02,10C
14A0:  MOVFF  01,10B
14A4:  MOVFF  00,10A
.................... 		if (dir_addr_ptr==0xFFFFFF) return (23); 
14A8:  MOVLB  1
14AA:  INCFSZ x0A,W
14AC:  BRA    14C0
14AE:  INCFSZ x0B,W
14B0:  BRA    14C0
14B2:  INCFSZ x0C,W
14B4:  BRA    14C0
14B6:  MOVF   x0D,F
14B8:  BNZ   14C0
14BA:  MOVLW  17
14BC:  MOVWF  01
14BE:  BRA    1688
.................... 		bytes_read=bytes_read-cluster_size_bytes; 
14C0:  MOVF   05,W
14C2:  SUBWF  x0E,F
14C4:  MOVF   06,W
14C6:  SUBWFB x0F,F
.................... 		dir_addr_ptr=dir_addr_ptr+bytes_read; 
14C8:  MOVF   x0E,W
14CA:  ADDWF  x0A,F
14CC:  MOVF   x0F,W
14CE:  ADDWFC x0B,F
14D0:  MOVLW  00
14D2:  ADDWFC x0C,F
14D4:  ADDWFC x0D,F
.................... 	} 
.................... 	else{ 
14D6:  BRA    14E4
.................... 		dir_addr_ptr=dir_addr_ptr+32; 
14D8:  MOVLW  20
14DA:  ADDWF  x0A,F
14DC:  MOVLW  00
14DE:  ADDWFC x0B,F
14E0:  ADDWFC x0C,F
14E2:  ADDWFC x0D,F
.................... 	} 
....................  
....................  
.................... 	dir_addr_ptr=dir_addr_ptr+32; 
14E4:  MOVLW  20
14E6:  ADDWF  x0A,F
14E8:  MOVLW  00
14EA:  ADDWFC x0B,F
14EC:  ADDWFC x0C,F
14EE:  ADDWFC x0D,F
....................  
.................... 	if (read_BLOCK(dir_addr_ptr,buff)==false) return(32); 
14F0:  MOVFF  10D,157
14F4:  MOVFF  10C,156
14F8:  MOVFF  10B,155
14FC:  MOVFF  10A,154
1500:  MOVLW  01
1502:  MOVWF  x59
1504:  MOVLW  25
1506:  MOVWF  x58
1508:  MOVLB  0
150A:  CALL   05E2
150E:  MOVF   01,F
1510:  BNZ   151C
1512:  MOVLW  20
1514:  MOVWF  01
1516:  MOVLB  1
1518:  BRA    1688
151A:  MOVLB  0
.................... 	goto tile_decode; 
151C:  BRA    129E
151E:  MOVLB  1
....................  
.................... 	match_found: 
.................... 	///// if we have a sub directory we need to cycle down a level 
.................... 	if (directory==true) { 
1520:  DECFSZ x22,W
1522:  BRA    1546
.................... 		// compute the sub directory address 
.................... 		// compute this cluster address this_cluster_ptr must be valid 
.................... 		dir_addr_ptr=cluster_addr(fnbr,ROOT_CLUSTER); /// set physical addr of starting cluster 
1524:  MOVFF  105,148
1528:  CLRF   x49
152A:  MOVLB  0
152C:  CALL   0B90
1530:  MOVFF  03,10D
1534:  MOVFF  02,10C
1538:  MOVFF  01,10B
153C:  MOVFF  00,10A
.................... 		#IF MMC_OPEN_TRACE 
.................... 			printf("\n\r next_cluster_ptr=%lu \n\r ",file[fnbr].next_cluster_ptr); 
.................... 		#ENDIF 
.................... 		//printf("\n\r dir_addr_ptr=%lu",dir_addr_ptr); 
.................... 		// dir_addr_ptr=((int32)cluster_table[0]-(int32)2)*(int32)cluster_size_bytes+ 
.................... 		// data_area_address; 
.................... 		level++; 
1540:  MOVLB  1
1542:  INCF   x45,F
.................... 		goto read_directory; 
1544:  BRA    10EE
.................... 	} 
....................  
....................  
.................... 	// note record length must divide into 512 to align properly 
.................... 	if (rec_length<2) return(12); 
1546:  MOVF   x09,F
1548:  BNZ   1556
154A:  MOVF   x08,W
154C:  SUBLW  01
154E:  BNC   1556
1550:  MOVLW  0C
1552:  MOVWF  01
1554:  BRA    1688
....................  
....................  
....................  
.................... 	/// get the initial file_addr_ptr 
....................  
.................... 	file[fnbr].addr_ptr=cluster_addr(fnbr,ROOT_CLUSTER); 
1556:  MOVF   x05,W
1558:  MULLW  3D
155A:  MOVF   FF3,W
155C:  CLRF   x47
155E:  MOVWF  x46
1560:  MOVLW  2B
1562:  ADDWF  x46,W
1564:  MOVWF  01
1566:  MOVLW  00
1568:  ADDWFC x47,W
156A:  MOVWF  03
156C:  MOVF   01,W
156E:  ADDLW  21
1570:  MOVWF  01
1572:  MOVLW  00
1574:  ADDWFC 03,F
1576:  MOVFF  01,146
157A:  MOVFF  03,147
157E:  MOVFF  105,148
1582:  CLRF   x49
1584:  MOVLB  0
1586:  CALL   0B90
158A:  MOVFF  147,FEA
158E:  MOVFF  146,FE9
1592:  MOVFF  00,FEF
1596:  MOVFF  01,FEC
159A:  MOVFF  02,FEC
159E:  MOVFF  03,FEC
.................... 	file[fnbr].offset=0; //init bytes read from beginning of open file 
15A2:  MOVLB  1
15A4:  MOVF   x05,W
15A6:  MULLW  3D
15A8:  MOVF   FF3,W
15AA:  CLRF   x47
15AC:  MOVWF  x46
15AE:  MOVLW  37
15B0:  ADDWF  x46,W
15B2:  MOVWF  01
15B4:  MOVLW  00
15B6:  ADDWFC x47,W
15B8:  MOVWF  03
15BA:  MOVF   01,W
15BC:  ADDLW  21
15BE:  MOVWF  FE9
15C0:  MOVLW  00
15C2:  ADDWFC 03,W
15C4:  MOVWF  FEA
15C6:  MOVF   FEE,F
15C8:  MOVF   FEE,F
15CA:  CLRF   FEC
15CC:  MOVF   FED,F
15CE:  CLRF   FEF
15D0:  MOVF   FED,F
15D2:  CLRF   FEF
15D4:  MOVF   FED,F
15D6:  CLRF   FEF
.................... 	file[fnbr].cluster_offset=0; //init bytes read to beginning of the current cluster 
15D8:  MOVF   x05,W
15DA:  MULLW  3D
15DC:  MOVF   FF3,W
15DE:  CLRF   x47
15E0:  MOVWF  x46
15E2:  MOVLW  33
15E4:  ADDWF  x46,W
15E6:  MOVWF  01
15E8:  MOVLW  00
15EA:  ADDWFC x47,W
15EC:  MOVWF  03
15EE:  MOVF   01,W
15F0:  ADDLW  21
15F2:  MOVWF  FE9
15F4:  MOVLW  00
15F6:  ADDWFC 03,W
15F8:  MOVWF  FEA
15FA:  MOVF   FEE,F
15FC:  MOVF   FEE,F
15FE:  CLRF   FEC
1600:  MOVF   FED,F
1602:  CLRF   FEF
1604:  MOVF   FED,F
1606:  CLRF   FEF
1608:  MOVF   FED,F
160A:  CLRF   FEF
.................... 	file[fnbr].rec_size=(int32)rec_length; /// assign file record size 
160C:  MOVF   x05,W
160E:  MULLW  3D
1610:  MOVF   FF3,W
1612:  CLRF   x47
1614:  MOVWF  x46
1616:  MOVLW  3B
1618:  ADDWF  x46,W
161A:  MOVWF  01
161C:  MOVLW  00
161E:  ADDWFC x47,W
1620:  MOVWF  03
1622:  MOVF   01,W
1624:  ADDLW  21
1626:  MOVWF  FE9
1628:  MOVLW  00
162A:  ADDWFC 03,W
162C:  MOVWF  FEA
162E:  MOVFF  108,FEF
1632:  MOVFF  109,FEC
.................... 	#IF MMC_OPEN_TRACE 
.................... 		printf("root_cluster=%lu \n\r",file[fnbr].root_cluster_ptr); 
.................... 	#ENDIF 
....................  
.................... 	//printf("\n\r fopen %u rec size=%lu",fnbr,file[fnbr].rec_size); 
....................  
.................... 	if(set_BLOCKLEN(file[fnbr].rec_size)==false) return(13); 
1636:  MOVF   x05,W
1638:  MULLW  3D
163A:  MOVF   FF3,W
163C:  CLRF   x47
163E:  MOVWF  x46
1640:  MOVLW  3B
1642:  ADDWF  x46,W
1644:  MOVWF  01
1646:  MOVLW  00
1648:  ADDWFC x47,W
164A:  MOVWF  03
164C:  MOVF   01,W
164E:  ADDLW  21
1650:  MOVWF  FE9
1652:  MOVLW  00
1654:  ADDWFC 03,W
1656:  MOVWF  FEA
1658:  MOVFF  FEC,147
165C:  MOVF   FED,F
165E:  MOVFF  FEF,146
1662:  CLRF   x55
1664:  CLRF   x54
1666:  MOVFF  147,153
166A:  MOVFF  146,152
166E:  MOVLB  0
1670:  CALL   058C
1674:  MOVF   01,F
1676:  BNZ   1682
1678:  MOVLW  0D
167A:  MOVWF  01
167C:  MOVLB  1
167E:  BRA    1688
1680:  MOVLB  0
....................  
.................... 	return(0); 
1682:  MOVLW  00
1684:  MOVWF  01
1686:  MOVLB  1
.................... } 
1688:  MOVLB  0
168A:  GOTO   1FBC (RETURN)
....................  
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////// FILE READ /////////////////////////////////////// 
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... #separate 
.................... int file_read(int8 fnbr,char *buff){ 
.................... 	int32 address; 
.................... 	int32 nxt_cluster; 
.................... 	//// MMC allows a read to start and stop at any address but this file system 
.................... 	//// imposes a record size restriction the record size must divide into the 
.................... 	/// 512 block to allow writing of the records 
.................... 	/// rec_size must align with cluster boundary 2048 ...must be a divisor of 2048 
.................... 	/// find the cluster containing the offset 
.................... 	/// buff must be at least the size of the recordsize requested in the File open 
....................  
.................... 	//printf("foffset=%lu coffset=%lu ",file[fnbr].offset,file[fnbr].cluster_offset);////$$$$ 
....................  
.................... 	if ( file[fnbr].offset>=file[fnbr].size) return(10); /// already beyond eof 
*
17E4:  MOVLB  1
17E6:  MOVF   x05,W
17E8:  MULLW  3D
17EA:  MOVF   FF3,W
17EC:  CLRF   x11
17EE:  MOVWF  x10
17F0:  MOVLW  37
17F2:  ADDWF  x10,W
17F4:  MOVWF  01
17F6:  MOVLW  00
17F8:  ADDWFC x11,W
17FA:  MOVWF  03
17FC:  MOVF   01,W
17FE:  ADDLW  21
1800:  MOVWF  FE9
1802:  MOVLW  00
1804:  ADDWFC 03,W
1806:  MOVWF  FEA
1808:  MOVFF  FEF,110
180C:  MOVFF  FEC,111
1810:  MOVFF  FEC,112
1814:  MOVFF  FEC,113
1818:  MOVF   x05,W
181A:  MULLW  3D
181C:  MOVF   FF3,W
181E:  CLRF   x15
1820:  MOVWF  x14
1822:  MOVLW  2F
1824:  ADDWF  x14,W
1826:  MOVWF  01
1828:  MOVLW  00
182A:  ADDWFC x15,W
182C:  MOVWF  03
182E:  MOVF   01,W
1830:  ADDLW  21
1832:  MOVWF  FE9
1834:  MOVLW  00
1836:  ADDWFC 03,W
1838:  MOVWF  FEA
183A:  MOVFF  FEF,00
183E:  MOVFF  FEC,01
1842:  MOVFF  FEC,02
1846:  MOVFF  FEC,03
184A:  MOVF   03,W
184C:  SUBWF  x13,W
184E:  BNC   186E
1850:  BNZ   1868
1852:  MOVF   02,W
1854:  SUBWF  x12,W
1856:  BNC   186E
1858:  BNZ   1868
185A:  MOVF   01,W
185C:  SUBWF  x11,W
185E:  BNC   186E
1860:  BNZ   1868
1862:  MOVF   00,W
1864:  SUBWF  x10,W
1866:  BNC   186E
1868:  MOVLW  0A
186A:  MOVWF  01
186C:  BRA    1DA2
....................  
.................... 	if ( file[fnbr].offset + (int32) file[fnbr].rec_size > file[fnbr].cluster_offset + (int32) cluster_size_bytes){ 
186E:  MOVF   x05,W
1870:  MULLW  3D
1872:  MOVF   FF3,W
1874:  CLRF   x11
1876:  MOVWF  x10
1878:  MOVLW  37
187A:  ADDWF  x10,W
187C:  MOVWF  01
187E:  MOVLW  00
1880:  ADDWFC x11,W
1882:  MOVWF  03
1884:  MOVF   01,W
1886:  ADDLW  21
1888:  MOVWF  FE9
188A:  MOVLW  00
188C:  ADDWFC 03,W
188E:  MOVWF  FEA
1890:  MOVFF  FEF,110
1894:  MOVFF  FEC,111
1898:  MOVFF  FEC,112
189C:  MOVFF  FEC,113
18A0:  MOVF   x05,W
18A2:  MULLW  3D
18A4:  MOVF   FF3,W
18A6:  CLRF   x15
18A8:  MOVWF  x14
18AA:  MOVLW  3B
18AC:  ADDWF  x14,W
18AE:  MOVWF  01
18B0:  MOVLW  00
18B2:  ADDWFC x15,W
18B4:  MOVWF  03
18B6:  MOVF   01,W
18B8:  ADDLW  21
18BA:  MOVWF  FE9
18BC:  MOVLW  00
18BE:  ADDWFC 03,W
18C0:  MOVWF  FEA
18C2:  MOVFF  FEC,03
18C6:  MOVF   FED,F
18C8:  MOVFF  FEF,00
18CC:  MOVFF  03,01
18D0:  CLRF   02
18D2:  CLRF   03
18D4:  MOVF   00,W
18D6:  ADDWF  x10,F
18D8:  MOVF   01,W
18DA:  ADDWFC x11,F
18DC:  MOVF   02,W
18DE:  ADDWFC x12,F
18E0:  MOVF   03,W
18E2:  ADDWFC x13,F
18E4:  MOVF   x05,W
18E6:  MULLW  3D
18E8:  MOVF   FF3,W
18EA:  CLRF   x15
18EC:  MOVWF  x14
18EE:  MOVLW  33
18F0:  ADDWF  x14,W
18F2:  MOVWF  01
18F4:  MOVLW  00
18F6:  ADDWFC x15,W
18F8:  MOVWF  03
18FA:  MOVF   01,W
18FC:  ADDLW  21
18FE:  MOVWF  FE9
1900:  MOVLW  00
1902:  ADDWFC 03,W
1904:  MOVWF  FEA
1906:  MOVFF  FEF,114
190A:  MOVFF  FEC,115
190E:  MOVFF  FEC,116
1912:  MOVFF  FEC,117
1916:  MOVFF  05,00
191A:  MOVFF  06,01
191E:  CLRF   02
1920:  CLRF   03
1922:  MOVF   x14,W
1924:  ADDWF  00,F
1926:  MOVF   x15,W
1928:  ADDWFC 01,F
192A:  MOVF   x16,W
192C:  ADDWFC 02,F
192E:  MOVF   x17,W
1930:  ADDWFC 03,F
1932:  MOVF   03,W
1934:  SUBWF  x13,W
1936:  BTFSS  FD8.0
1938:  BRA    1A52
193A:  BNZ   1958
193C:  MOVF   02,W
193E:  SUBWF  x12,W
1940:  BTFSS  FD8.0
1942:  BRA    1A52
1944:  BNZ   1958
1946:  MOVF   01,W
1948:  SUBWF  x11,W
194A:  BTFSS  FD8.0
194C:  BRA    1A52
194E:  BNZ   1958
1950:  MOVF   x10,W
1952:  SUBWF  00,W
1954:  BTFSC  FD8.0
1956:  BRA    1A52
.................... 		#IF MMC_READ_TRACE 
.................... 			printf("adv to next cluster"); 
.................... 		#ENDIF 
.................... 		/// need to advance to the next cluster 
.................... 		nxt_cluster=cluster_addr(fnbr,NEXT_CLUSTER); 
1958:  MOVFF  105,148
195C:  MOVLW  01
195E:  MOVWF  x49
1960:  MOVLB  0
1962:  CALL   0B90
1966:  MOVFF  03,10F
196A:  MOVFF  02,10E
196E:  MOVFF  01,10D
1972:  MOVFF  00,10C
.................... 		if ( nxt_cluster!=0XFFFFFFFF) file[fnbr].addr_ptr=nxt_cluster; 
1976:  MOVLB  1
1978:  INCFSZ x0C,W
197A:  BRA    198A
197C:  INCFSZ x0D,W
197E:  BRA    198A
1980:  INCFSZ x0E,W
1982:  BRA    198A
1984:  INCFSZ x0F,W
1986:  BRA    198A
1988:  BRA    19BE
198A:  MOVF   x05,W
198C:  MULLW  3D
198E:  MOVF   FF3,W
1990:  CLRF   x11
1992:  MOVWF  x10
1994:  MOVLW  2B
1996:  ADDWF  x10,W
1998:  MOVWF  01
199A:  MOVLW  00
199C:  ADDWFC x11,W
199E:  MOVWF  03
19A0:  MOVF   01,W
19A2:  ADDLW  21
19A4:  MOVWF  FE9
19A6:  MOVLW  00
19A8:  ADDWFC 03,W
19AA:  MOVWF  FEA
19AC:  MOVFF  10C,FEF
19B0:  MOVFF  10D,FEC
19B4:  MOVFF  10E,FEC
19B8:  MOVFF  10F,FEC
.................... 		else return(11); /// last cluster in file reached 
19BC:  BRA    19C4
19BE:  MOVLW  0B
19C0:  MOVWF  01
19C2:  BRA    1DA2
....................  
.................... 		file[fnbr].cluster_offset=file[fnbr].cluster_offset+(int32)cluster_size_bytes; //foffset is the byte offset within the file 
19C4:  MOVF   x05,W
19C6:  MULLW  3D
19C8:  MOVF   FF3,W
19CA:  CLRF   x11
19CC:  MOVWF  x10
19CE:  MOVLW  33
19D0:  ADDWF  x10,W
19D2:  MOVWF  01
19D4:  MOVLW  00
19D6:  ADDWFC x11,W
19D8:  MOVWF  03
19DA:  MOVF   01,W
19DC:  ADDLW  21
19DE:  MOVWF  01
19E0:  MOVLW  00
19E2:  ADDWFC 03,F
19E4:  MOVFF  01,110
19E8:  MOVFF  03,111
19EC:  MOVF   x05,W
19EE:  MULLW  3D
19F0:  MOVF   FF3,W
19F2:  CLRF   x13
19F4:  MOVWF  x12
19F6:  MOVLW  33
19F8:  ADDWF  x12,W
19FA:  MOVWF  01
19FC:  MOVLW  00
19FE:  ADDWFC x13,W
1A00:  MOVWF  03
1A02:  MOVF   01,W
1A04:  ADDLW  21
1A06:  MOVWF  FE9
1A08:  MOVLW  00
1A0A:  ADDWFC 03,W
1A0C:  MOVWF  FEA
1A0E:  MOVFF  FEF,112
1A12:  MOVFF  FEC,113
1A16:  MOVFF  FEC,114
1A1A:  MOVFF  FEC,115
1A1E:  MOVFF  05,00
1A22:  MOVFF  06,01
1A26:  CLRF   02
1A28:  CLRF   03
1A2A:  MOVF   x12,W
1A2C:  ADDWF  00,F
1A2E:  MOVF   x13,W
1A30:  ADDWFC 01,F
1A32:  MOVF   x14,W
1A34:  ADDWFC 02,F
1A36:  MOVF   x15,W
1A38:  ADDWFC 03,F
1A3A:  MOVFF  111,FEA
1A3E:  MOVFF  110,FE9
1A42:  MOVFF  00,FEF
1A46:  MOVFF  01,FEC
1A4A:  MOVFF  02,FEC
1A4E:  MOVFF  03,FEC
.................... 		//that file_addr_ptr points to 
.................... 	} 
.................... 	address=file[fnbr].addr_ptr+file[fnbr].offset-file[fnbr].cluster_offset; 
1A52:  MOVF   x05,W
1A54:  MULLW  3D
1A56:  MOVF   FF3,W
1A58:  CLRF   x11
1A5A:  MOVWF  x10
1A5C:  MOVLW  2B
1A5E:  ADDWF  x10,W
1A60:  MOVWF  01
1A62:  MOVLW  00
1A64:  ADDWFC x11,W
1A66:  MOVWF  03
1A68:  MOVF   01,W
1A6A:  ADDLW  21
1A6C:  MOVWF  FE9
1A6E:  MOVLW  00
1A70:  ADDWFC 03,W
1A72:  MOVWF  FEA
1A74:  MOVFF  FEF,110
1A78:  MOVFF  FEC,111
1A7C:  MOVFF  FEC,112
1A80:  MOVFF  FEC,113
1A84:  MOVF   x05,W
1A86:  MULLW  3D
1A88:  MOVF   FF3,W
1A8A:  CLRF   x15
1A8C:  MOVWF  x14
1A8E:  MOVLW  37
1A90:  ADDWF  x14,W
1A92:  MOVWF  01
1A94:  MOVLW  00
1A96:  ADDWFC x15,W
1A98:  MOVWF  03
1A9A:  MOVF   01,W
1A9C:  ADDLW  21
1A9E:  MOVWF  FE9
1AA0:  MOVLW  00
1AA2:  ADDWFC 03,W
1AA4:  MOVWF  FEA
1AA6:  MOVFF  FEF,00
1AAA:  MOVFF  FEC,01
1AAE:  MOVFF  FEC,02
1AB2:  MOVFF  FEC,03
1AB6:  MOVF   00,W
1AB8:  ADDWF  x10,F
1ABA:  MOVF   01,W
1ABC:  ADDWFC x11,F
1ABE:  MOVF   02,W
1AC0:  ADDWFC x12,F
1AC2:  MOVF   03,W
1AC4:  ADDWFC x13,F
1AC6:  MOVF   x05,W
1AC8:  MULLW  3D
1ACA:  MOVF   FF3,W
1ACC:  CLRF   x15
1ACE:  MOVWF  x14
1AD0:  MOVLW  33
1AD2:  ADDWF  x14,W
1AD4:  MOVWF  01
1AD6:  MOVLW  00
1AD8:  ADDWFC x15,W
1ADA:  MOVWF  03
1ADC:  MOVF   01,W
1ADE:  ADDLW  21
1AE0:  MOVWF  FE9
1AE2:  MOVLW  00
1AE4:  ADDWFC 03,W
1AE6:  MOVWF  FEA
1AE8:  MOVFF  FEF,00
1AEC:  MOVFF  FEC,01
1AF0:  MOVFF  FEC,02
1AF4:  MOVFF  FEC,03
1AF8:  MOVF   00,W
1AFA:  SUBWF  x10,W
1AFC:  MOVWF  x08
1AFE:  MOVF   01,W
1B00:  SUBWFB x11,W
1B02:  MOVWF  x09
1B04:  MOVF   02,W
1B06:  SUBWFB x12,W
1B08:  MOVWF  x0A
1B0A:  MOVF   03,W
1B0C:  SUBWFB x13,W
1B0E:  MOVWF  x0B
.................... 	#IF MMC_READ_TRACE 
.................... 		//printf("\n\r offset=%lu",cluster_offset); 
.................... 		printf("\n\r data_area_address=%lu",address); 
.................... 		printf("\n\r cluster_size_bytes=%lu",cluster_size_bytes); 
....................  
.................... 		//printf("\n\r file_addr_ptr=%lu",file_addr_ptr); 
.................... 	#ENDIF 
....................  
.................... 	if (read_BLOCK(address,buff)==false)return(12); /// read block into buff 
1B10:  MOVFF  10B,157
1B14:  MOVFF  10A,156
1B18:  MOVFF  109,155
1B1C:  MOVFF  108,154
1B20:  MOVFF  107,159
1B24:  MOVFF  106,158
1B28:  MOVLB  0
1B2A:  CALL   05E2
1B2E:  MOVF   01,F
1B30:  BNZ   1B3A
1B32:  MOVLW  0C
1B34:  MOVWF  01
1B36:  MOVLB  1
1B38:  BRA    1DA2
....................  
.................... 	if ( file[fnbr].offset+file[fnbr].rec_size< file[fnbr].size ) file[fnbr].offset=file[fnbr].offset+file[fnbr].rec_size; 
1B3A:  MOVLB  1
1B3C:  MOVF   x05,W
1B3E:  MULLW  3D
1B40:  MOVF   FF3,W
1B42:  CLRF   x11
1B44:  MOVWF  x10
1B46:  MOVLW  37
1B48:  ADDWF  x10,W
1B4A:  MOVWF  01
1B4C:  MOVLW  00
1B4E:  ADDWFC x11,W
1B50:  MOVWF  03
1B52:  MOVF   01,W
1B54:  ADDLW  21
1B56:  MOVWF  FE9
1B58:  MOVLW  00
1B5A:  ADDWFC 03,W
1B5C:  MOVWF  FEA
1B5E:  MOVFF  FEF,110
1B62:  MOVFF  FEC,111
1B66:  MOVFF  FEC,112
1B6A:  MOVFF  FEC,113
1B6E:  MOVF   x05,W
1B70:  MULLW  3D
1B72:  MOVF   FF3,W
1B74:  CLRF   x15
1B76:  MOVWF  x14
1B78:  MOVLW  3B
1B7A:  ADDWF  x14,W
1B7C:  MOVWF  01
1B7E:  MOVLW  00
1B80:  ADDWFC x15,W
1B82:  MOVWF  03
1B84:  MOVF   01,W
1B86:  ADDLW  21
1B88:  MOVWF  FE9
1B8A:  MOVLW  00
1B8C:  ADDWFC 03,W
1B8E:  MOVWF  FEA
1B90:  MOVFF  FEC,03
1B94:  MOVF   FED,F
1B96:  MOVF   FEF,W
1B98:  ADDWF  x10,F
1B9A:  MOVF   03,W
1B9C:  ADDWFC x11,F
1B9E:  MOVLW  00
1BA0:  ADDWFC x12,F
1BA2:  ADDWFC x13,F
1BA4:  MOVF   x05,W
1BA6:  MULLW  3D
1BA8:  MOVF   FF3,W
1BAA:  CLRF   x15
1BAC:  MOVWF  x14
1BAE:  MOVLW  2F
1BB0:  ADDWF  x14,W
1BB2:  MOVWF  01
1BB4:  MOVLW  00
1BB6:  ADDWFC x15,W
1BB8:  MOVWF  03
1BBA:  MOVF   01,W
1BBC:  ADDLW  21
1BBE:  MOVWF  FE9
1BC0:  MOVLW  00
1BC2:  ADDWFC 03,W
1BC4:  MOVWF  FEA
1BC6:  MOVFF  FEF,00
1BCA:  MOVFF  FEC,01
1BCE:  MOVFF  FEC,02
1BD2:  MOVFF  FEC,03
1BD6:  MOVF   x13,W
1BD8:  SUBWF  03,W
1BDA:  BNC   1CA4
1BDC:  BNZ   1BF4
1BDE:  MOVF   x12,W
1BE0:  SUBWF  02,W
1BE2:  BNC   1CA4
1BE4:  BNZ   1BF4
1BE6:  MOVF   x11,W
1BE8:  SUBWF  01,W
1BEA:  BNC   1CA4
1BEC:  BNZ   1BF4
1BEE:  MOVF   00,W
1BF0:  SUBWF  x10,W
1BF2:  BC    1CA4
1BF4:  MOVF   x05,W
1BF6:  MULLW  3D
1BF8:  MOVF   FF3,W
1BFA:  CLRF   x11
1BFC:  MOVWF  x10
1BFE:  MOVLW  37
1C00:  ADDWF  x10,W
1C02:  MOVWF  01
1C04:  MOVLW  00
1C06:  ADDWFC x11,W
1C08:  MOVWF  03
1C0A:  MOVF   01,W
1C0C:  ADDLW  21
1C0E:  MOVWF  01
1C10:  MOVLW  00
1C12:  ADDWFC 03,F
1C14:  MOVFF  01,110
1C18:  MOVFF  03,111
1C1C:  MOVF   x05,W
1C1E:  MULLW  3D
1C20:  MOVF   FF3,W
1C22:  CLRF   x13
1C24:  MOVWF  x12
1C26:  MOVLW  37
1C28:  ADDWF  x12,W
1C2A:  MOVWF  01
1C2C:  MOVLW  00
1C2E:  ADDWFC x13,W
1C30:  MOVWF  03
1C32:  MOVF   01,W
1C34:  ADDLW  21
1C36:  MOVWF  FE9
1C38:  MOVLW  00
1C3A:  ADDWFC 03,W
1C3C:  MOVWF  FEA
1C3E:  MOVFF  FEF,112
1C42:  MOVFF  FEC,113
1C46:  MOVFF  FEC,114
1C4A:  MOVFF  FEC,115
1C4E:  MOVF   x05,W
1C50:  MULLW  3D
1C52:  MOVF   FF3,W
1C54:  CLRF   x17
1C56:  MOVWF  x16
1C58:  MOVLW  3B
1C5A:  ADDWF  x16,W
1C5C:  MOVWF  01
1C5E:  MOVLW  00
1C60:  ADDWFC x17,W
1C62:  MOVWF  03
1C64:  MOVF   01,W
1C66:  ADDLW  21
1C68:  MOVWF  FE9
1C6A:  MOVLW  00
1C6C:  ADDWFC 03,W
1C6E:  MOVWF  FEA
1C70:  MOVFF  FEC,03
1C74:  MOVF   FED,F
1C76:  MOVF   FEF,W
1C78:  ADDWF  x12,W
1C7A:  MOVWF  00
1C7C:  MOVF   03,W
1C7E:  ADDWFC x13,W
1C80:  MOVWF  01
1C82:  MOVLW  00
1C84:  ADDWFC x14,W
1C86:  MOVWF  02
1C88:  MOVLW  00
1C8A:  ADDWFC x15,W
1C8C:  MOVFF  111,FEA
1C90:  MOVFF  110,FE9
1C94:  MOVFF  00,FEF
1C98:  MOVFF  01,FEC
1C9C:  MOVFF  02,FEC
1CA0:  MOVWF  FEC
.................... 	else{ /// end of file 
1CA2:  BRA    1D9E
.................... 		#IF MMC_READ_TRACE 
.................... 			printf("eof size=%lu",file[fnbr].size); 
.................... 		#ENDIF 
.................... 		buff[ file[fnbr].size-file[fnbr].offset]=0; /// short record 
1CA4:  MOVF   x05,W
1CA6:  MULLW  3D
1CA8:  MOVF   FF3,W
1CAA:  CLRF   x11
1CAC:  MOVWF  x10
1CAE:  MOVLW  2F
1CB0:  ADDWF  x10,W
1CB2:  MOVWF  01
1CB4:  MOVLW  00
1CB6:  ADDWFC x11,W
1CB8:  MOVWF  03
1CBA:  MOVF   01,W
1CBC:  ADDLW  21
1CBE:  MOVWF  FE9
1CC0:  MOVLW  00
1CC2:  ADDWFC 03,W
1CC4:  MOVWF  FEA
1CC6:  MOVFF  FEF,110
1CCA:  MOVFF  FEC,111
1CCE:  MOVFF  FEC,112
1CD2:  MOVFF  FEC,113
1CD6:  MOVF   x05,W
1CD8:  MULLW  3D
1CDA:  MOVF   FF3,W
1CDC:  CLRF   x15
1CDE:  MOVWF  x14
1CE0:  MOVLW  37
1CE2:  ADDWF  x14,W
1CE4:  MOVWF  01
1CE6:  MOVLW  00
1CE8:  ADDWFC x15,W
1CEA:  MOVWF  03
1CEC:  MOVF   01,W
1CEE:  ADDLW  21
1CF0:  MOVWF  FE9
1CF2:  MOVLW  00
1CF4:  ADDWFC 03,W
1CF6:  MOVWF  FEA
1CF8:  MOVFF  FEF,00
1CFC:  MOVFF  FEC,01
1D00:  MOVFF  FEC,02
1D04:  MOVFF  FEC,03
1D08:  MOVF   00,W
1D0A:  SUBWF  x10,F
1D0C:  MOVF   01,W
1D0E:  SUBWFB x11,F
1D10:  MOVF   02,W
1D12:  SUBWFB x12,F
1D14:  MOVF   03,W
1D16:  SUBWFB x13,F
1D18:  MOVF   x06,W
1D1A:  ADDWF  x10,W
1D1C:  MOVWF  FE9
1D1E:  MOVF   x07,W
1D20:  ADDWFC x11,W
1D22:  MOVWF  FEA
1D24:  CLRF   FEF
.................... 		file[fnbr].offset=file[fnbr].size; 
1D26:  MOVF   x05,W
1D28:  MULLW  3D
1D2A:  MOVF   FF3,W
1D2C:  CLRF   x11
1D2E:  MOVWF  x10
1D30:  MOVLW  37
1D32:  ADDWF  x10,W
1D34:  MOVWF  01
1D36:  MOVLW  00
1D38:  ADDWFC x11,W
1D3A:  MOVWF  03
1D3C:  MOVF   01,W
1D3E:  ADDLW  21
1D40:  MOVWF  01
1D42:  MOVLW  00
1D44:  ADDWFC 03,F
1D46:  MOVFF  01,110
1D4A:  MOVFF  03,111
1D4E:  MOVF   x05,W
1D50:  MULLW  3D
1D52:  MOVF   FF3,W
1D54:  CLRF   x13
1D56:  MOVWF  x12
1D58:  MOVLW  2F
1D5A:  ADDWF  x12,W
1D5C:  MOVWF  01
1D5E:  MOVLW  00
1D60:  ADDWFC x13,W
1D62:  MOVWF  03
1D64:  MOVF   01,W
1D66:  ADDLW  21
1D68:  MOVWF  FE9
1D6A:  MOVLW  00
1D6C:  ADDWFC 03,W
1D6E:  MOVWF  FEA
1D70:  MOVFF  FEF,00
1D74:  MOVFF  FEC,01
1D78:  MOVFF  FEC,02
1D7C:  MOVFF  FEC,03
1D80:  MOVFF  111,FEA
1D84:  MOVFF  110,FE9
1D88:  MOVFF  00,FEF
1D8C:  MOVFF  01,FEC
1D90:  MOVFF  02,FEC
1D94:  MOVFF  03,FEC
.................... 		return(255); //eof 
1D98:  MOVLW  FF
1D9A:  MOVWF  01
1D9C:  BRA    1DA2
.................... 	} 
.................... 	return(0); 
1D9E:  MOVLW  00
1DA0:  MOVWF  01
.................... } 
1DA2:  MOVLB  0
1DA4:  GOTO   2066 (RETURN)
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////// WRITE FILE ///////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... #separate 
.................... int file_write(int8 fnbr,int *buff){ 
.................... 	//// buff size must be at least the recordsize requested in File open 
.................... 	//// the record is updated only chars beyond rec_size are ignored 
.................... 	/// set up for write 
.................... 	/// A MMC write is restricted it must be for a block and allign on block boundaries 
.................... 	/// blocklen must be exactly 512 and start address must be the begining of a 
.................... 	/// sector 
.................... 	/// the buff could potentially span a sector and or span a block(512) boundary 
.................... 	/// ex there could be 1byte left in a block and 1 byte lect in a sector 
.................... 	// if the block is the last block in the sector 
.................... 	/// worst case we could write to two blocks and need a new sector 
.................... 	int32 address,nxt_cluster; 
....................  
.................... 	int16 in_cluster_size,out_cluster_size; 
.................... 	int8 appending_flag; 
.................... 	appending_flag=0; 
.................... 	if (file[fnbr].offset + file[fnbr].rec_size>=file[fnbr].size) appending_flag=1; 
....................  
....................  
.................... 	/// find the cluster containing the offset 
.................... 	if ( file[fnbr].offset+file[fnbr].rec_size>=file[fnbr].cluster_offset + cluster_size_bytes){ 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("spanning cluster \n\r"); 
.................... 		#ENDIF 
.................... 		/// spans the current cluster so we split the write 
.................... 		in_cluster_size=file[fnbr].cluster_offset+cluster_size_bytes-file[fnbr].offset; 
.................... 		/// bytes from start of file to end of this cluste- bytes into the file 
.................... 		out_cluster_size=file[fnbr].rec_size - in_cluster_size; 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("write>> spanning cluster inside=%lu outside=%lu \n\r",in_cluster_size,out_cluster_size); 
.................... 		#ENDIF 
.................... 		address=file[fnbr].addr_ptr+file[fnbr].offset - file[fnbr].cluster_offset; 
.................... 		// physical address= 
.................... 		// physical address of the cluster +offset from begining of file 
.................... 		// - offset from the begining of file for the byte at the begining of the cluster 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("write file>>cluster=%lu in clstr addr=%lu",file[fnbr].this_cluster_ptr,address); 
.................... 		#ENDIF 
.................... 		//// address=physical offset of this cluster +bytes into this cluster 
.................... 		if(write_BLOCK(address,buff,in_cluster_size)==false)return(81); //// write first chunk 
....................  
....................  
....................  
.................... 		/// allocate the next cluster 
.................... 		nxt_cluster=cluster_addr(fnbr,NEXT_CLUSTER); ///physical address of file data that the 
.................... 		/// specific cluster indexes 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("nxt_cluster=%lu",nxt_cluster); 
.................... 		#ENDIF 
....................  
.................... 		if ( nxt_cluster==0xFFFFFFFF){ 
.................... 			#IF MMC_WRITE_TRACE 
.................... 				printf("updating FAT"); 
.................... 			#ENDIF 
.................... 			//// FAT2 is an identical copy of FAT1 
.................... 			file_new_cluster(fnbr,1); /// a new cluster is allocated in FAT1 
.................... 			file_new_cluster(fnbr,2); /// a new cluster is allocated in FAT2 
.................... 			nxt_cluster=cluster_addr(fnbr,NEXT_CLUSTER); ///physical address of file data that the 
.................... 			#IF MMC_WRITE_TRACE 
.................... 				printf("\n\r write>>nxt_cluster addr=%lu this clstr=%lu next=%lu",nxt_cluster,file[fnbr].this_cluster_ptr,file[fnbr].next_cluster_ptr); /// specific cluster indexes 
.................... 			#ENDIF 
.................... 		} 
....................  
.................... 		file[fnbr].addr_ptr =nxt_cluster; 
.................... 		file[fnbr].cluster_offset=file[fnbr].cluster_offset + cluster_size_bytes; //foffset is the byte offset within the file 
.................... 		//that file_addr_ptr points to 
.................... 		address=file[fnbr].addr_ptr + file[fnbr].offset - file[fnbr].cluster_offset + in_cluster_size; 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("out addr=%lu,out size=%lu",address,out_cluster_size); 
.................... 		#ENDIF 
.................... 		if(write_BLOCK(address,&buff[in_cluster_size],out_cluster_size)==false)return(82); /// write block pads with 0x00 to end of sector 
.................... 	}// end of spanned cluster 
.................... 	else{ 
.................... 		/// within the current cluster 
.................... 		address=file[fnbr].addr_ptr+file[fnbr].offset - file[fnbr].cluster_offset; 
....................  
....................  
....................  
.................... 		if(write_BLOCK(address,buff,file[fnbr].rec_size)==false)return(84); /// write block pads with 0x00 to end of sector 
....................  
.................... 	} 
.................... 	if(appending_flag==1) { 
.................... 		/// if appended we need to up date the file size 
.................... 		file[fnbr].size=file[fnbr].size + file[fnbr].rec_size; /// add one record 
.................... 		address=file[fnbr].dir_addr_ptr+28; /// file size is offset 28 in tiles 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("new file size=%lu",file[fnbr].size); 
.................... 		#ENDIF 
.................... 		buff[0]=make8(file[fnbr].size,0); 
.................... 		buff[1]=make8(file[fnbr].size,1); 
.................... 		buff[2]=make8(file[fnbr].size,2); 
.................... 		buff[3]=make8(file[fnbr].size,3); 
.................... 		MMC_dir_protected=false; 
.................... 		if(write_BLOCK(address,buff,4)==false)return(85); 
.................... 	} 
.................... 	if(set_BLOCKLEN(file[fnbr].rec_size)==false) return(86); /// reset to original rec_size 
.................... 	return(0); 
.................... } 
....................  
....................  
.................... #separate 
.................... int file_set(int fnbr,int32 offset){ 
.................... 	/// file open sets the offset to the begining offset=0 
.................... 	/// this sets the offset within the file ...offset of 0 is a reset 
....................  
.................... 	if(offset>=file[fnbr].size) return(71); 
....................  
.................... 	file[fnbr].offset=offset; //// overwrite the existing offset 
.................... 	file[fnbr].next_cluster_ptr=file[fnbr].root_cluster_ptr; /// set current ptr to beginning 
.................... 	file[fnbr].cluster_offset=0; 
.................... 	// move the cluster to the one containing the offset 
....................  
.................... 	while ( offset>cluster_size_bytes ){ 
....................  
.................... 		file[fnbr].addr_ptr=cluster_addr(fnbr,NEXT_CLUSTER); 
.................... 		file[fnbr].cluster_offset+=cluster_size_bytes; //foffset is the byte offset within the file 
.................... 		if (offset-cluster_size_bytes >0) offset= offset - cluster_size_bytes; 
....................  
.................... 	} 
.................... 	return(0); 
.................... } 
....................  
....................  
.................... #separate 
.................... int file_new_cluster(int8 fnbr,int8 mode){ ///////////// this does identical writes to either the FAT1 and FAT2 sectors 
.................... 	int16 eof_cluster; 
....................  
.................... 	char buff[2],tmp_buff[2]; 
.................... 	int32 address; 
.................... 	int32 fat_address; 
.................... 	int16 slot; 
.................... 	/// an unused cluster has the value 0x0000 as its next cluster ptr 
.................... 	/// a used cluster has either 0xFFFF meaning last in chain 
.................... 	/// or a valid cluster displacement in the FAT1 amd FAT2 area 
.................... 	/// to append a cluster the 0XFFFF needs to be replaced by the appended 
.................... 	/// cluster location and the appended locations data (next ptr) needs to be set to 0XFFFF 
....................  
....................  
....................  
.................... 	eof_cluster=file[fnbr].this_cluster_ptr; 
.................... 	#IF MMC_NEW_CLUSTER 
.................... 		printf("the cluster with eof (FFFF)=%lu \n\r",eof_cluster); 
.................... 	#ENDIF 
....................  
.................... 	slot=0; 
.................... 	if(set_BLOCKLEN((int32)2)==false)return(false); // force blocklen to 2 
.................... 	/// use global address of FAT1 assigned by INIT 
.................... 	if (mode==2)fat_address=fat2_address; 
.................... 	else fat_address=fat1_address; 
.................... 	address=fat_address; 
....................  
.................... 	#IF MMC_NEW_CLUSTER 
.................... 		printf("mode=%u FAT addr=%lu \n\r",mode,address); 
.................... 	#ENDIF 
....................  
.................... 	do{ 
.................... 		if(read_block(address,buff)==false) return(false) ; 
.................... 		slot=slot+1; 
.................... 		address=address+2; 
.................... 		//printf(" slot %lu =%2x %2x",slot,buff[0],buff[1]); 
.................... 	} 
.................... 	while (buff[0]!=0 || buff[1]!=0); 
....................  
.................... 	address=address-2; // correct for over step 
.................... 	slot=slot-1; 
....................  
....................  
.................... 	#IF MMC_NEW_CLUSTER 
.................... 		printf("slot=%lu address=%lu",slot,address); 
.................... 	#ENDIF 
....................  
.................... 	/// found an unused cluster 
.................... 	tmp_buff[0]=0xFF;tmp_buff[1]=0xFF; /// stamp it as last 
.................... 	MMC_dir_protected=false; /// allow writes to the protected areas 
.................... 	if(write_block(address,tmp_buff,2)==false ) return(false); 
....................  
.................... 	///////////////////////////////////////////// 
.................... 	/// update prev cluster with 0xFFFF in it 
.................... 	tmp_buff[1]=make8(slot,1); 
.................... 	tmp_buff[0]=make8(slot,0); 
.................... 	if (mode==1){ 
.................... 		//// update the file info 
.................... 		file[fnbr].next_cluster_ptr=slot; 
.................... 		#IF MMC_NEW_CLUSTER 
.................... 			printf("cluster %lu was updated to point to %lu",file[fnbr].this_cluster_ptr,file[fnbr].next_cluster_ptr); 
.................... 		#ENDIF 
.................... 	} 
.................... 	/// compute physical address of the current cluster 
.................... 	MMC_dir_protected=false; /// allow writes to the protected areas 
.................... 	if(write_BLOCK(fat_address+(file[fnbr].this_cluster_ptr)*2,tmp_buff,2)==false) return(33); 
.................... 	if(set_BLOCKLEN((int32)file[fnbr].rec_size)==false)return(false); // reset blocklen 
....................  
.................... 	return(true); 
.................... } 
....................  
....................  
.................... signed int strncmp(char *s1, char *s2, int n){ 
.................... 	for (; n > 0; s1++, s2++, n--){ 
*
0FEE:  MOVLB  1
0FF0:  MOVF   x4A,F
0FF2:  BZ    1076
.................... 		if (*s1 != *s2) return((*s1 <*s2) ? -1: 1); 
0FF4:  MOVFF  147,03
0FF8:  MOVFF  146,FE9
0FFC:  MOVFF  147,FEA
1000:  MOVFF  FEF,14B
1004:  MOVFF  149,03
1008:  MOVFF  148,FE9
100C:  MOVFF  149,FEA
1010:  MOVF   FEF,W
1012:  SUBWF  x4B,W
1014:  BZ    1044
1016:  MOVFF  147,03
101A:  MOVFF  146,FE9
101E:  MOVFF  147,FEA
1022:  MOVFF  FEF,14B
1026:  MOVFF  149,03
102A:  MOVFF  148,FE9
102E:  MOVFF  149,FEA
1032:  MOVF   FEF,W
1034:  SUBWF  x4B,W
1036:  BC    103C
1038:  MOVLW  FF
103A:  BRA    103E
103C:  MOVLW  01
103E:  MOVWF  01
1040:  BRA    107A
.................... 		else if (*s1 == '\0') return(0); 
1042:  BRA    105A
1044:  MOVFF  147,03
1048:  MOVFF  146,FE9
104C:  MOVFF  147,FEA
1050:  MOVF   FEF,F
1052:  BNZ   105A
1054:  MOVLW  00
1056:  MOVWF  01
1058:  BRA    107A
.................... 	} 
105A:  MOVFF  147,03
105E:  MOVF   x46,W
1060:  INCF   x46,F
1062:  BTFSC  FD8.2
1064:  INCF   x47,F
1066:  MOVFF  149,03
106A:  MOVF   x48,W
106C:  INCF   x48,F
106E:  BTFSC  FD8.2
1070:  INCF   x49,F
1072:  DECF   x4A,F
1074:  BRA    0FF0
.................... 	return(0); 
1076:  MOVLW  00
1078:  MOVWF  01
.................... } 
107A:  MOVLB  0
107C:  GOTO   13AA (RETURN)
....................  
....................  
.................... //#define _CS PIN_D3 
.................... int error,error0; 
.................... int16 rec_no; 
.................... int16 index,rec_size; 
.................... char fname[32],buff0[MMC_BUFF_SIZE+1],buff1[MMC_BUFF_SIZE+1]; 
....................  
....................  
.................... //-------------------------fonction buzzer------------------------ 
.................... //permet d'emettre un son dont on peut paramétrer la fréquence et la durée 
....................  
.................... void beep(int freq, int duree) 
.................... {  
....................    setup_ccp1(CCP_PWM);                   
*
0438:  BCF    F94.2
043A:  BCF    F8B.2
043C:  BCF    F96.6
043E:  MOVLW  0C
0440:  MOVWF  FBD
0442:  CLRF   FB7
0444:  CLRF   FB6
....................    set_pwm1_duty(freq/2); 
0446:  BCF    FD8.0
0448:  MOVLB  1
044A:  RRCF   x05,W
044C:  MOVWF  FBE
....................    setup_timer_2(T2_DIV_BY_16,freq,5);    
044E:  MOVLW  20
0450:  IORLW  06
0452:  MOVWF  FCA
0454:  MOVFF  105,FCB
....................    while (duree--) delay_ms(10); 
0458:  MOVF   x06,W
045A:  DECF   x06,F
045C:  XORLW  00
045E:  BZ    046C
0460:  MOVLW  0A
0462:  MOVWF  x3E
0464:  MOVLB  0
0466:  RCALL  023A
0468:  MOVLB  1
046A:  BRA    0458
....................    setup_ccp1(CCP_OFF); 
046C:  BSF    F94.2
046E:  CLRF   FBD
0470:  CLRF   FB7
0472:  CLRF   FB6
.................... } 
0474:  MOVLB  0
0476:  GOTO   04BA (RETURN)
....................  
.................... void initialisation()  
.................... { 
.................... 	SETUP_SPI (SPI_MASTER |  SPI_SS_DISABLED |SPI_H_TO_L| SPI_CLK_DIV_16 | SPI_XMIT_L_TO_H); 
047A:  BCF    FC6.5
047C:  BCF    F94.7
047E:  BSF    F93.0
0480:  BCF    F93.1
0482:  MOVLW  31
0484:  MOVWF  FC6
0486:  MOVLW  00
0488:  MOVWF  FC7
....................  
.................... //	set_tris_c(0b10010011); //c7=rx I, c6=tx O, c5 SDO O,c4 SDI I 
.................... 	output_high(_CS); 
048A:  BCF    F95.3
048C:  BSF    F8C.3
.................... 	 
.................... 	lcd_init(); 
048E:  BRA    0262
....................    	lcd_putc("\fLecture Carte SD\n"); 
0490:  MOVLW  A8
0492:  MOVWF  FF6
0494:  MOVLW  00
0496:  MOVWF  FF7
0498:  RCALL  039E
.................... 	lcd_putc("(C)UMONS - 2011"); 
049A:  MOVLW  BC
049C:  MOVWF  FF6
049E:  MOVLW  00
04A0:  MOVWF  FF7
04A2:  RCALL  039E
.................... 	cursor(0);										// curseur OFF 
04A4:  MOVLB  1
04A6:  CLRF   x05
04A8:  MOVLB  0
04AA:  BRA    03BE
.................... 	beep(200,20); 
04AC:  MOVLW  C8
04AE:  MOVLB  1
04B0:  MOVWF  x05
04B2:  MOVLW  14
04B4:  MOVWF  x06
04B6:  MOVLB  0
04B8:  BRA    0438
.................... 	delay_ms(1000);	 
04BA:  MOVLW  04
04BC:  MOVLB  1
04BE:  MOVWF  x05
04C0:  MOVLW  FA
04C2:  MOVWF  x3E
04C4:  MOVLB  0
04C6:  RCALL  023A
04C8:  MOVLB  1
04CA:  DECFSZ x05,F
04CC:  BRA    04C0
.................... } 
04CE:  MOVLB  0
04D0:  GOTO   2140 (RETURN)
....................  
.................... void test_carte() 
.................... { 
....................  
.................... 	printf("\r\n**** SD / MMC FAT16  Read Demo **** "); 
*
1EEA:  MOVLW  CC
1EEC:  MOVWF  FF6
1EEE:  MOVLW  00
1EF0:  MOVWF  FF7
1EF2:  CALL   04D4
.................... 	printf("\r\n"); 
1EF6:  MOVLW  0D
1EF8:  BTFSS  F9E.4
1EFA:  BRA    1EF8
1EFC:  MOVWF  FAD
1EFE:  MOVLW  0A
1F00:  BTFSS  F9E.4
1F02:  BRA    1F00
1F04:  MOVWF  FAD
.................... 	Delay_ms(1000); 
1F06:  MOVLW  04
1F08:  MOVLB  1
1F0A:  MOVWF  x05
1F0C:  MOVLW  FA
1F0E:  MOVWF  x3E
1F10:  MOVLB  0
1F12:  CALL   023A
1F16:  MOVLB  1
1F18:  DECFSZ x05,F
1F1A:  BRA    1F0C
.................... 	printf("\r\Now Open HOME.TXT File on SD Card  "); 
1F1C:  MOVLW  F4
1F1E:  MOVWF  FF6
1F20:  MOVLW  00
1F22:  MOVWF  FF7
1F24:  MOVLB  0
1F26:  CALL   04D4
.................... 	printf("\r\n"); 
1F2A:  MOVLW  0D
1F2C:  BTFSS  F9E.4
1F2E:  BRA    1F2C
1F30:  MOVWF  FAD
1F32:  MOVLW  0A
1F34:  BTFSS  F9E.4
1F36:  BRA    1F34
1F38:  MOVWF  FAD
.................... 	Delay_ms(3000); 
1F3A:  MOVLW  0C
1F3C:  MOVLB  1
1F3E:  MOVWF  x05
1F40:  MOVLW  FA
1F42:  MOVWF  x3E
1F44:  MOVLB  0
1F46:  CALL   023A
1F4A:  MOVLB  1
1F4C:  DECFSZ x05,F
1F4E:  BRA    1F40
....................  
.................... 	buff0[MMC_BUFF_SIZE]=0; 
1F50:  MOVLB  0
1F52:  CLRF   xE3
.................... 	buff1[MMC_BUFF_SIZE]=0; 
1F54:  MOVLB  1
1F56:  CLRF   x04
.................... 	rec_no=0; 
1F58:  MOVLB  0
1F5A:  CLRF   x9E
1F5C:  CLRF   x9D
....................  
.................... 	///////// init MMC //////////////////////////////////////// 
.................... 	error=init_MMC(10); 
1F5E:  MOVLW  0A
1F60:  MOVLB  1
1F62:  MOVWF  x05
1F64:  MOVLB  0
1F66:  GOTO   0770
1F6A:  MOVFF  01,9B
.................... 	if (error>0) { 
1F6E:  MOVF   x9B,F
1F70:  BZ    1F74
.................... 		goto mmc_exit; 
1F72:  BRA    20BE
.................... 	} 
....................  
.................... 	printf("\n\r MMC initialized \n\r"); 
1F74:  MOVLW  1A
1F76:  MOVWF  FF6
1F78:  MOVLW  01
1F7A:  MOVWF  FF7
1F7C:  CALL   04D4
.................... 	rec_size=MMC_BUFF_SIZE; 
1F80:  CLRF   xA2
1F82:  MOVLW  20
1F84:  MOVWF  xA1
....................  
.................... 	//strcpy(fname,"HOME\\HOME.TXT"); 
.................... 	strcpy(fname,"HOME.TXT"); 
1F86:  CLRF   FEA
1F88:  MOVLW  A3
1F8A:  MOVWF  FE9
1F8C:  MOVLW  00
1F8E:  CALL   0018
1F92:  TBLRD*-
1F94:  TBLRD*+
1F96:  MOVF   FF5,W
1F98:  MOVWF  FEE
1F9A:  IORLW  00
1F9C:  BNZ   1F94
.................... 	rec_size=MMC_BUFF_SIZE; 
1F9E:  CLRF   xA2
1FA0:  MOVLW  20
1FA2:  MOVWF  xA1
.................... 	error0=open_file(0,fname,rec_size); 
1FA4:  MOVLB  1
1FA6:  CLRF   x05
1FA8:  CLRF   x07
1FAA:  MOVLW  A3
1FAC:  MOVWF  x06
1FAE:  MOVFF  A2,109
1FB2:  MOVFF  A1,108
1FB6:  MOVLB  0
1FB8:  GOTO   1080
1FBC:  MOVFF  01,9C
....................  
.................... 	if (error0>0) { 
1FC0:  MOVF   x9C,F
1FC2:  BZ    1FFC
.................... 		printf("\n\r fopen as 0 failed error=%U\n\r",error); 
1FC4:  MOVLW  30
1FC6:  MOVWF  FF6
1FC8:  MOVLW  01
1FCA:  MOVWF  FF7
1FCC:  MOVLW  1B
1FCE:  MOVLB  1
1FD0:  MOVWF  x46
1FD2:  MOVLB  0
1FD4:  CALL   0B40
1FD8:  MOVFF  9B,105
1FDC:  MOVLW  1B
1FDE:  MOVLB  1
1FE0:  MOVWF  x06
1FE2:  MOVLB  0
1FE4:  CALL   16BA
1FE8:  MOVLW  0A
1FEA:  BTFSS  F9E.4
1FEC:  BRA    1FEA
1FEE:  MOVWF  FAD
1FF0:  MOVLW  0D
1FF2:  BTFSS  F9E.4
1FF4:  BRA    1FF2
1FF6:  MOVWF  FAD
.................... 		goto mmc_exit; 
1FF8:  BRA    20BE
.................... 	} 
.................... 	else printf("\n\r opened as 0 file %s with rec size %lu \n\r",fname,rec_size); 
1FFA:  BRA    2056
1FFC:  MOVLW  50
1FFE:  MOVWF  FF6
2000:  MOVLW  01
2002:  MOVWF  FF7
2004:  MOVLW  14
2006:  MOVLB  1
2008:  MOVWF  x46
200A:  MOVLB  0
200C:  CALL   0B40
2010:  CLRF   FEA
2012:  MOVLW  A3
2014:  MOVWF  FE9
2016:  CALL   0B6A
201A:  MOVLW  66
201C:  MOVWF  FF6
201E:  MOVLW  01
2020:  MOVWF  FF7
2022:  MOVLW  0F
2024:  MOVLB  1
2026:  MOVWF  x46
2028:  MOVLB  0
202A:  CALL   0B40
202E:  MOVLW  10
2030:  MOVWF  FE9
2032:  MOVFF  A2,106
2036:  MOVFF  A1,105
203A:  GOTO   1738
203E:  MOVLW  20
2040:  BTFSS  F9E.4
2042:  BRA    2040
2044:  MOVWF  FAD
2046:  MOVLW  0A
2048:  BTFSS  F9E.4
204A:  BRA    2048
204C:  MOVWF  FAD
204E:  MOVLW  0D
2050:  BTFSS  F9E.4
2052:  BRA    2050
2054:  MOVWF  FAD
....................  
.................... 	do { 
.................... 		error0=file_read(0,buff0); 
2056:  MOVLB  1
2058:  CLRF   x05
205A:  CLRF   x07
205C:  MOVLW  C3
205E:  MOVWF  x06
2060:  MOVLB  0
2062:  GOTO   17E4
2066:  MOVFF  01,9C
.................... 		if (error0>0 && error0<255 ) { 
206A:  MOVF   x9C,F
206C:  BZ    20AA
206E:  INCFSZ x9C,W
2070:  BRA    2074
2072:  BRA    20AA
.................... 			printf("\n\r fread 0 failed error=%U\n\r",error0); 
2074:  MOVLW  7C
2076:  MOVWF  FF6
2078:  MOVLW  01
207A:  MOVWF  FF7
207C:  MOVLW  18
207E:  MOVLB  1
2080:  MOVWF  x46
2082:  MOVLB  0
2084:  CALL   0B40
2088:  MOVFF  9C,105
208C:  MOVLW  1B
208E:  MOVLB  1
2090:  MOVWF  x06
2092:  MOVLB  0
2094:  CALL   16BA
2098:  MOVLW  0A
209A:  BTFSS  F9E.4
209C:  BRA    209A
209E:  MOVWF  FAD
20A0:  MOVLW  0D
20A2:  BTFSS  F9E.4
20A4:  BRA    20A2
20A6:  MOVWF  FAD
.................... 			break; 
20A8:  BRA    20BE
.................... 		} 
.................... 		printf("%s",buff0); 
20AA:  CLRF   FEA
20AC:  MOVLW  C3
20AE:  MOVWF  FE9
20B0:  CALL   0B6A
.................... 		rec_no++; 
20B4:  INCF   x9D,F
20B6:  BTFSC  FD8.2
20B8:  INCF   x9E,F
.................... 	} while (error0==0); 
20BA:  MOVF   x9C,F
20BC:  BZ    2056
....................  
.................... 	mmc_exit: 
.................... 	printf("\n\r done winhex adj= %lu \n\r",winhex_adj); 
20BE:  MOVLW  9A
20C0:  MOVWF  FF6
20C2:  MOVLW  01
20C4:  MOVWF  FF7
20C6:  MOVLW  14
20C8:  MOVLB  1
20CA:  MOVWF  x46
20CC:  MOVLB  0
20CE:  CALL   0B40
20D2:  MOVLW  41
20D4:  MOVWF  FE9
20D6:  MOVFF  1A,108
20DA:  MOVFF  19,107
20DE:  MOVFF  18,106
20E2:  MOVFF  17,105
20E6:  BRA    1E28
20E8:  MOVLW  20
20EA:  BTFSS  F9E.4
20EC:  BRA    20EA
20EE:  MOVWF  FAD
20F0:  MOVLW  0A
20F2:  BTFSS  F9E.4
20F4:  BRA    20F2
20F6:  MOVWF  FAD
20F8:  MOVLW  0D
20FA:  BTFSS  F9E.4
20FC:  BRA    20FA
20FE:  MOVWF  FAD
....................  
.................... } 
2100:  GOTO   2142 (RETURN)
....................  
.................... //-------------------------xxx------------------------ 
.................... void main() { 
2104:  CLRF   FF8
2106:  BCF    FD0.7
2108:  CLRF   FEA
210A:  CLRF   FE9
210C:  BSF    FB8.3
210E:  MOVLW  56
2110:  MOVWF  FAF
2112:  MOVLW  00
2114:  MOVWF  FB0
2116:  MOVLW  A6
2118:  MOVWF  FAC
211A:  MOVLW  90
211C:  MOVWF  FAB
211E:  BSF    F95.2
2120:  BCF    F95.1
2122:  BCF    F95.0
2124:  BCF    F8C.0
2126:  BCF    F95.3
2128:  BCF    F8C.3
212A:  CLRF   1F
212C:  MOVLW  01
212E:  MOVWF  20
2130:  MOVF   FC1,W
2132:  ANDLW  C0
2134:  IORLW  0F
2136:  MOVWF  FC1
2138:  MOVLW  07
213A:  MOVWF  FB4
....................  
.................... 		initialisation(); 
213C:  GOTO   047A
.................... 		test_carte(); 
2140:  BRA    1EEA
.................... 		while(true) { 
.................... 		 
.................... 		} 
2142:  BRA    2142
.................... } 
2144:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   IESO FCMEN HS PLL12 CPUDIV4 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
