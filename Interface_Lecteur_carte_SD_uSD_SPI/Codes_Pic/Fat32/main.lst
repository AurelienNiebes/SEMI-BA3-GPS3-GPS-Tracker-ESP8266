CCS PCH C Compiler, Version 4.106, 39453               19-nov.-12 14:42

               Filename: D:\Fichiers_Divers\DataPic\Fat32\main.lst

               ROM used: 17106 bytes (52%)
                         Largest free fragment is 15662
               RAM used: 1261 (62%) at main() level
                         1358 (66%) worst case
               Stack:    8 locations

*
0000:  GOTO   40AE
.................... // This example open a file for append, and writes "System 
.................... // started". It also shows small error handling             
.................... /* 
.................... 	char f,gfilename[12];   
....................  
.................... 	strcpy(gfilename,"EVENTS.LOG"); 
.................... 	f = fopen(gfilename,'a'); 		// open EVENTS.LOG for append 
.................... 	if (f & MMC_ERROR) 
.................... 	{ 
.................... 		printf("Couldn't open file!\r\n"); 
.................... 		if(f == MMC_NO_CARD_INSERTED) 
.................... 			printf("Please, insert MMC!"); 
.................... 		else if(f == MMC_MAX_FILES_REACHED) 
.................... 			printf("ops.. =)"); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		strcpy(msg,"System started\r\n"); 
.................... 		fputstring(msg,f); 
.................... 		fclose(f); 
.................... 	} 
.................... */ 
.................... 	// Here is a exampel that covers almost everything...       
.................... 	// It first lists all files and dirs in DIR/ and then open  
.................... 	// The first and prints the file with printf, take a look:  
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOPUT,NOLVP,NOBROWNOUT,NOWRT 
....................  
.................... #use delay(clock=24 000 000) 
*
00E4:  MOVLW  05
00E6:  MOVWF  FEA
00E8:  MOVLW  48
00EA:  MOVWF  FE9
00EC:  MOVF   FEF,W
00EE:  BZ    010C
00F0:  MOVLW  07
00F2:  MOVWF  01
00F4:  CLRF   00
00F6:  DECFSZ 00,F
00F8:  BRA    00F6
00FA:  DECFSZ 01,F
00FC:  BRA    00F4
00FE:  MOVLW  C7
0100:  MOVWF  00
0102:  DECFSZ 00,F
0104:  BRA    0102
0106:  NOP   
0108:  DECFSZ FEF,F
010A:  BRA    00F0
010C:  RETLW  00
.................... #use rs232(baud=9600, bits=8, parity = N, xmit=PIN_C6, rcv=PIN_C7) 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
087C:  MOVLB  5
087E:  MOVFF  52D,FE9
0882:  MOVFF  52E,FEA
0886:  MOVFF  FEF,531
088A:  MOVFF  530,03
088E:  MOVFF  52F,FE9
0892:  MOVFF  530,FEA
0896:  MOVF   FEF,W
0898:  SUBWF  x31,W
089A:  BNZ   08C6
....................       if (*s1 == '\0') 
089C:  MOVFF  52E,03
08A0:  MOVFF  52D,FE9
08A4:  MOVFF  03,FEA
08A8:  MOVF   FEF,F
08AA:  BNZ   08B2
....................          return(0); 
08AC:  MOVLW  00
08AE:  MOVWF  01
08B0:  BRA    08F0
08B2:  MOVFF  52E,03
08B6:  MOVF   x2D,W
08B8:  INCF   x2D,F
08BA:  BTFSC  FD8.2
08BC:  INCF   x2E,F
08BE:  INCF   x2F,F
08C0:  BTFSC  FD8.2
08C2:  INCF   x30,F
08C4:  BRA    087E
....................    return((*s1 < *s2) ? -1: 1); 
08C6:  MOVFF  52E,03
08CA:  MOVFF  52D,FE9
08CE:  MOVFF  52E,FEA
08D2:  MOVFF  FEF,531
08D6:  MOVFF  530,03
08DA:  MOVFF  52F,FE9
08DE:  MOVFF  530,FEA
08E2:  MOVF   FEF,W
08E4:  SUBWF  x31,W
08E6:  BC    08EC
08E8:  MOVLW  FF
08EA:  BRA    08EE
08EC:  MOVLW  01
08EE:  MOVWF  01
.................... } 
08F0:  MOVLB  0
08F2:  GOTO   0B1E (RETURN)
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
074E:  MOVFF  519,51B
0752:  MOVFF  518,51A
0756:  MOVFF  51B,03
075A:  MOVLB  5
075C:  MOVFF  51A,FE9
0760:  MOVFF  51B,FEA
0764:  MOVF   FEF,F
0766:  BZ    0774
0768:  INCF   x1A,F
076A:  BTFSC  FD8.2
076C:  INCF   x1B,F
076E:  MOVLB  0
0770:  BRA    0756
0772:  MOVLB  5
....................    return(sc - s); 
0774:  MOVF   x18,W
0776:  SUBWF  x1A,W
0778:  MOVWF  00
077A:  MOVF   x19,W
077C:  SUBWFB x1B,W
077E:  MOVWF  03
0780:  MOVFF  00,01
.................... } 
0784:  MOVLB  0
0786:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include <MMC_SPI_FAT32.h> 	// As usual you also need to  
.................... #define MAXFILES 1 // This define specifies the maximum number 
....................                // of simultaneously open files, more files 
....................                // requires more ram. The maximun number of 
....................                // this define is 8, this is because of my 
....................                // error handlig.. but that should be more 
....................                // then enough.. 
....................  
.................... // This enable functions and variables needed for filelisting 
.................... // If you aren't going to use it, comment this line out to 
.................... // save some RAM 
.................... #define ENABLE_FILELISTNG 
....................  
.................... typedef struct _diskinforec 
.................... { 
....................    char   hJumpCode[3]; 
....................    char  OEMName[8]; 
....................    int16   hBytesPerSector; 
....................    char   bSectorsPerCluster; 
....................    int16 Reserved1; 
....................    char   FATCopies; 
....................    int16 hMaxRootEntries; 
....................    int16 hSectors; 
....................    char   Descriptor; 
....................    int16 holdSectorsPerFat; 
....................    int16 hSectorsPerTrack; 
....................    int16 hNumberofHeads; 
....................    int32   hNumberofHidden; 
....................    int32   hNumberofSectors; 
....................  
....................    int32 hSectorsPerFat; 
....................    int16 hFlags; 
....................    int16 hFAT32Version; 
....................    int32 hRootStartCluster; 
.................... } diskinforec; 
....................  
.................... typedef struct _direntry 
.................... { 
....................    char   sName[8]; 
....................    char   spam[3]; 
....................    char   bAttr; 
....................    char   bReserved[8]; 
....................       int16 hClusterH; 
....................    int16   hTime; 
....................    int16   hDate; 
....................    int16   hCluster; 
....................    int32   wSize; 
.................... } DIR; 
....................  
.................... typedef struct 
.................... { 
....................    char    IOpuffer[512]; 
....................    DIR    DirEntry; 
....................    int32 CurrentCluster; 
....................    int16 posinsector; 
....................    int32   position; 
....................    int32 dirSector; 
....................    int8   dirIdx; 
....................    char   mode; 
....................    BOOLEAN   Free; 
.................... } FILE; 
....................  
.................... typedef struct 
.................... { 
....................    int32 MMCAddress; 
....................    int32 FATstartidx; 
....................    int32 gStartSector; 
....................    int32 gFirstDataSector; 
....................    int8 gDirEntryIdx; 
....................    int32 gDirEntrySector; 
....................    int8 gFirstEmptyDirEntry; 
....................    int32 gFirstDirEntryCluster; 
.................... } FAT32Vars; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned long   Year; 
....................    char         Month; 
....................    char            Day;    
....................    char            Hour;    
....................    char            Minute;      
....................    char            Second;      
.................... } TimeRecord; 
....................  
.................... typedef struct 
.................... { 
....................    int32 dirSector; 
....................    int32 CurrentCluster; 
....................    int dirIdx; 
.................... } ListPos; 
....................  
.................... typedef struct 
.................... { 
....................    char *name; 
....................    char *shortName; 
....................    BOOLEAN isDir; 
....................    BOOLEAN isLong; 
.................... } LongFileName; 
....................  
.................... typedef char MMCResponse; 
....................  
.................... MMCResponse MMCInit(); 
.................... MMCResponse ReadSector(int32 sector, char *hova); 
.................... MMCResponse WriteSector(int32 sector, char *honnan); 
....................  
.................... void      InitFAT(); 
.................... char      FindDirEntry(char *fname, char f); 
....................  
.................... #ifdef ENABLE_FILELISTNG 
....................    MMCResponse InitList(char *path); 
....................    int8      ListFiles(char f); 
....................    MMCResponse NextPage(char f); 
....................    MMCResponse SetPage(char f, int32 page); 
....................    MMCResponse CloseList(char f); 
....................    void      FreeList(); 
.................... #endif 
....................  
.................... MMCResponse fopen(char *fname, char mode); 
.................... MMCResponse fclose(char f); 
.................... MMCResponse fflush(char f); 
.................... char      cwd(char *fname, char f); 
.................... MMCResponse fputch(char be, char f); 
.................... MMCResponse fgetch(char *ki, char f); 
.................... MMCResponse fputstring(char *be, char f); // fputs is reserved in CCS C 
.................... int16      fread(char *buffer, int16 leng, char f); 
.................... MMCResponse fwrite(char *buffer, int16 leng, char f); 
.................... MMCResponse remove(char *fname); 
.................... MMCResponse getfsize(char *fname, int32 *fsiz); 
....................  
.................... #include <MMC_SPI_FAT32.c> 	// include your device .h file...  
.................... //////////////////////////////////////////////////////////////////////// 
.................... /////////////////// FAT32 DRIVER FOR MMC OVER SPI ////////////////////// 
.................... //////////////////////////////////////////////////////////////////////// 
.................... //// Original code by Tamas Bodorics (Tomi),                        //// 
.................... //// http://www.ccsinfo.com/forum/viewtopic.php?t=23969             //// 
.................... //// Modified by Mattias "miniman" Eriksson, Sweden                 //// 
.................... //// Disclaimer:                                                    //// 
.................... //// This code is provided for you "AS IS", this means I can NOT be //// 
.................... //// held responsible for any damage or harm it may couse.          //// 
.................... //////////////////////////////////////////////////////////////////////// 
.................... //// Hardware:                                                      //// 
.................... ////   This is the hardware I use. My pic is running at 5v, the MMC //// 
.................... ////   at 3.3V, so I need voltage level conversion. That is what    //// 
.................... ////   the resistors and zener diodes are for. First a 820 ohm      //// 
.................... ////   resistor from is connected to the pic, then a 3.3V           //// 
.................... ////   zenerdiode is connected with its anode to ground and its     //// 
.................... ////   cathode to the resistor. This resistor-zenerdiode connection //// 
.................... ////   leaves about 3V on the DATA/CS/CLOCK lines which is enough.  //// 
.................... ////   A 100K pull-up resistor from Data out(Do) of the MMC is      //// 
.................... ////   required. Note: this "picture" do not have the right pin     //// 
.................... ////   assignments. Hope you can see what I'm trying to paint..     //// 
.................... ////                                                                //// 
.................... ////    __ __  3x820 ohm                       ______________       //// 
.................... ////   |  U  |--\/\/\----------- o---DATA->---|=2            |      //// 
.................... ////   | PIC |--\/\/\-------o----+---CS--->---|=1            |      //// 
.................... ////   |     |--\/\/\--o----+----+---CLOCK>---|=5    MMC     |      //// 
.................... ////   |     |        _|_, _|_, _|_,       o--|=7            |      //// 
.................... ////   |     |       '/_\ '/_\ '/_\        |   \_____________|      //// 
.................... ////   |     |     GND_|____|____|_GND     | 100k ohm               //// 
.................... ////   |_____|-----------<-DATA-<----------o--\/\/\---<3.3V         //// 
.................... ////                                                                //// 
.................... //// Notes:                                                         //// 
.................... //// - The card that is going to be used by this code has to be     //// 
.................... ////   pre-formated with FAT32, 512byte/sector. To do this, run cmd //// 
.................... ////   and type the following command:                              //// 
.................... ////   format X: /A:512 /V:LABEL /FS:FAT32                          //// 
.................... ////   where X is the diverletter of your card and LABEL is the     //// 
.................... ////   volyme name. This can also be done in the diskmanager        //// 
.................... //// - Use '/' as directory separator, example: "MYDIR/ELEMENT.WND" //// 
.................... ////   "MYDIR/SUBDIR/OTHER.TXT" etc.                                //// 
.................... ////                                                                //// 
.................... //// Functions:                                                     //// 
.................... ////   MMCInit()                                                    //// 
.................... ////      Initializes the MMC, this function must be called before  //// 
.................... ////      any other MMC functions, and at the top of the program.   //// 
.................... ////      Returns a MMCResponse.                                    //// 
.................... ////   InitFAT()                                                    //// 
.................... ////      Initializes the FAT filesystem, this function must be     //// 
.................... ////      called before any other MMC functions and after MMCInit,  //// 
.................... ////      only if the later one returned MMC_OK.                    //// 
.................... ////      Returns a MMCResponse.                                    //// 
.................... ////   InitList(char *path)                                         //// 
.................... ////      Initializes file and directory listing in the any         //// 
.................... ////      directory that is specified by path. To list files and    //// 
.................... ////      directorys in root directory path should be a empty       //// 
.................... ////      string(""). Ottherwise path should end with a "/" e.g:    //// 
.................... ////      "DIR/SUBDIR/". Returns a filehandle.                      //// 
.................... ////   Listfiles(char f)                                            //// 
.................... ////      List files and directorys in any directory that have been //// 
.................... ////      openes by InitList(). Access the list through FileList    //// 
.................... ////      array. See examples. There can only be one file handle    //// 
.................... ////      open for file listing at the same time. Returns the       //// 
.................... ////      number of files and directorys that where listed.         //// 
.................... ////   NextPage(char f)                                             //// 
.................... ////      To be able to handle many files in a dir, file listing    //// 
.................... ////      is parted up in pages. To list next page, call NextPage   //// 
.................... ////      and then ListFiles again. ListFiles must be called        //// 
.................... ////      before a NextPage function, otherwise the function will   //// 
.................... ////      not have any effect. Returns a MMCResponse.               //// 
.................... ////   SetPage(char f)                                              //// 
.................... ////      Set the page that you want to list, see above function    //// 
.................... ////      to get better understanding. Note: no need to call        //// 
.................... ////      ListFiles before this function. Returns a MMCResponse.    //// 
.................... ////   CloseList(char f)                                            //// 
.................... ////      Closes filelisting, in other words, the there are an      //// 
.................... ////      extra free file handle to use. Returns a MMCResponse      //// 
.................... ////   FreeList()                                                   //// 
.................... ////      Frees all the strings in FileList array. This function    //// 
.................... ////      is called before any new files are listed in ListFiles    //// 
.................... ////      but not in CloseList. THis means you can access the last  //// 
.................... ////      listed files even though you already have closed the      //// 
.................... ////      list. But to free the mem that are used by FileList call  //// 
.................... ////      this function.                                            //// 
.................... ////   fopen(char *fname, char mode)                                //// 
.................... ////      Opens a file specified by fname in the desired mode.      //// 
.................... ////      Valid modes are: 'r' = read, 'w' = write and 'a' = append //// 
.................... ////      No long filenames can be used. To open a file with long   //// 
.................... ////      filename, listed by ListFiles(), use the shortName field  //// 
.................... ////      in the FileList, FileList[i].shortName. Note: ListFiles   //// 
.................... ////      do only filename, not the path..                          //// 
.................... ////      Returns a filehandle if succeed, else a errorcode         //// 
.................... ////   fclose(char f)                                               //// 
.................... ////      Closes a file that previously have been opened by fopen.  //// 
.................... ////      Returns a MMCResponse                                     //// 
.................... ////   fputch(char be, char f)                                      //// 
.................... ////      Puts a char, be, in file f that previously have been      //// 
.................... ////      opened by fopen. Returns a MMCResponse                    //// 
.................... ////   fgetch(char *ki, char f)                                     //// 
.................... ////      get a char from file f that previously have been opened   //// 
.................... ////      by fopen, and puts it at the position specified by ki     //// 
.................... ////      Returns a MMCSresponse                                    //// 
.................... ////   fputstring(char *be, char f)                                 //// 
.................... ////      puts a entire string to file f that previously have been  //// 
.................... ////      opened by fopen. Returns MMCResponse                      //// 
.................... ////   fread(char *buffer, int16 leng, char f)                      //// 
.................... ////      Reads a block of data with length leng from file f that   //// 
.................... ////      previously have been opened by fopen.                     //// 
.................... ////      Returns the number of bytes that were read.               //// 
.................... ////   fwrite(char *buffer, int16 leng, char f)                     //// 
.................... ////      Writes a block of data with length leng to a file f that  //// 
.................... ////      previously have been opened by fopen.                     //// 
.................... ////      Returns a MMCResponse                                     //// 
.................... ////   getfsize(char *fname, int32 *fsiz)                           //// 
.................... ////      Reads the size of a file with a filename specified by     //// 
.................... ////      fname. Returns a MMCResponse.                             //// 
.................... ////                                                                //// 
.................... //// Examples:                                                      //// 
.................... ////   // This example open a file for append, and writes "System   //// 
.................... ////   // started". It also shows small error handling              //// 
.................... ////   char f,gfilename[12];                                        //// 
.................... ////   strcpy(gfilename,"EVENTS.LOG");                              //// 
.................... ////   f = fopen(gfilename,'a'); // open EVENTS.LOG for append      //// 
.................... ////   if (f & MMC_ERROR)                                           //// 
.................... ////   {                                                            //// 
.................... ////      printf("Couldn't open file!\r\n");                        //// 
.................... ////      if(f == MMC_NO_CARD_INSERTED)                             //// 
.................... ////         printf("Please, insert MMC!");                         //// 
.................... ////      else if(f == MMC_MAX_FILES_REACHED)                       //// 
.................... ////         printf("ops.. =)");                                    //// 
.................... ////   }                                                            //// 
.................... ////   else                                                         //// 
.................... ////   {                                                            //// 
.................... ////      strcpy(msg,"System started\r\n");                         //// 
.................... ////      fputstring(msg,f);                                        //// 
.................... ////      fclose(f);                                                //// 
.................... ////   }                                                            //// 
.................... ////                                                                //// 
.................... ////   // Here is a exampel that covers almost everything...        //// 
.................... ////   // It first lists all files and dirs in DIR/ and then open   //// 
.................... ////   // The first and prints the file with printf, take a look:   //// 
.................... ////   #include <MMC_SPI_FAT32.h> // As usual you also need to      //// 
.................... ////   #include <MMC_SPI_FAT32.c> // include your device .h file... //// 
.................... ////   void main(void)                                              //// 
.................... ////   {                                                            //// 
.................... ////      char f,filename[20],res,i,c;                              //// 
.................... ////      while(TRUE)                                               //// 
.................... ////      {                                                         //// 
.................... ////         if(MMCInit() == MMC_OK)                                //// 
.................... ////         {                                                      //// 
.................... ////            printf("MMC initialized\r\n");                      //// 
.................... ////            InitFAT();                                          //// 
.................... ////            strcpy(filename,"DIR/");                            //// 
.................... ////            f = InitList(filename);                             //// 
.................... ////            if(f & MMC_ERROR)                                   //// 
.................... ////               printf("Error");                                 //// 
.................... ////            else                                                //// 
.................... ////            {                                                   //// 
.................... ////               do                                               //// 
.................... ////               {                                                //// 
.................... ////                  res = ListFiles(f);                           //// 
.................... ////                  for(i=0;i<res;i++)                            //// 
.................... ////                  {                                             //// 
.................... ////                     printf(FileList[i].name);                  //// 
.................... ////                     if(FileList[i].isDir)                      //// 
.................... ////                        printf("\\\r\n");//a "\" with row break //// 
.................... ////                     else                                       //// 
.................... ////                        printf("\r\n");                         //// 
.................... ////                  }                                             //// 
.................... ////               } while(NextPage(f) == MMC_OK);                  //// 
.................... ////               CloseList(f); // frees the file, but the list is //// 
.................... ////            }                // still there...                  //// 
.................... ////            strcpy(filename,FileList[0].shortName);             //// 
.................... ////            f = open(filename,'r'); // open file for reading    //// 
.................... ////            if((f & MMC_ERROR) == 0) // No error, same as       //// 
.................... ////            {                        // if(f < MAXFILES)        //// 
.................... ////               while(fgetch(&c,f) == MMC_OK)                    //// 
.................... ////                  printf(c);                                    //// 
.................... ////               fclose(f);                                       //// 
.................... ////            }                                                   //// 
.................... ////            else if(f == MMC_NOT_FOUND)                         //// 
.................... ////               printf("1st file in list was probebly a dir");   //// 
.................... ////            else                                                //// 
.................... ////               printf("Other error\r\n");                       //// 
.................... ////            while(TRUE)                                         //// 
.................... ////               ; // Loop forever, program is finished           //// 
.................... ////         }                                                      //// 
.................... ////         else                                                   //// 
.................... ////            printf("MMC init failed!\r\n");                     //// 
.................... ////         delay_ms(1000);                                        //// 
.................... ////         printf("Trying once more..\r\n");                      //// 
.................... ////      }                                                         //// 
.................... ////   }                                                            //// 
.................... ////                                                                //// 
.................... //////////////////////////////////////////////////////////////////////// 
.................... //// Changelog:                                                     //// 
.................... //// YYYY-MM-DD VER LOG                                             //// 
.................... //// 2007-08-15 0.9 Fixed a hardware SPI error in writesector.      //// 
.................... ////                Thanks to wielen who found the bug.             //// 
.................... //// 2007-07-25 0.8 This, and almost all other text is written      //// 
.................... //////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////// 
....................  
.................... // If you want to use software SPI keep this line uncommented 
.................... // If you want to use hardware SPI comment this line.. 
.................... // Software SPI are slower, but you can use any clock and data 
.................... // pins that you want.. 
.................... #define MMC_SPI_SOFTWARE 
....................  
....................  
.................... // Change the port to whatever port you are going to use 
.................... #use FAST_IO(B) 
.................... // Change this to set the right tris for your pins 
.................... #define SET_MMC_TRIS() set_tris_b(0x10) // 0b0001000 1=input,0=output 
.................... // Change these pins to whatever pins you are using 
.................... #define ChipSel      pin_B7 // Chip-Select pin 
.................... #define ChipClk      pin_B5 // SPI-Clock pin 
.................... #define ChipDout   pin_B6 // SPI-Data out pin 
.................... #define ChipDin      pin_B4 // SPI-Data in pin 
....................  
.................... #ifdef MMC_SPI_SOFTWARE 
....................    // You can also specify a baud-rate in the line below, if not the fastest possible speed will be used. 
....................    // For me that was 800kHz on a 18F4550 with 48MHz external clock 
....................    #USE SPI(MASTER, SAMPLE_RISE, MSB_FIRST, IDLE=1, DI=ChipDin, DO=ChipDout, CLK=ChipClk, BITS=8, STREAM=MMC_SPI) 
*
009E:  MOVLB  5
00A0:  MOVF   x4B,W
00A2:  SUBLW  08
00A4:  BZ    00AE
00A6:  MOVWF  x4C
00A8:  RLCF   x4A,F
00AA:  DECFSZ x4C,F
00AC:  BRA    00A8
00AE:  BSF    F8A.5
00B0:  MOVFF  54B,54C
00B4:  BCF    F8A.5
00B6:  BTFSS  x4A.7
00B8:  BCF    F8A.6
00BA:  BTFSC  x4A.7
00BC:  BSF    F8A.6
00BE:  RLCF   x4A,F
00C0:  BSF    F8A.5
00C2:  RLCF   01,F
00C4:  BTFSS  F81.4
00C6:  BCF    01.0
00C8:  BTFSC  F81.4
00CA:  BSF    01.0
00CC:  DECFSZ x4C,F
00CE:  BRA    00B4
00D0:  MOVLB  0
00D2:  RETLW  00
....................    #define MMC_Xfer(a) SPI_Xfer(MMC_SPI,a) 
.................... #else 
....................    // If MMC_SPI_SOFTWARE isn't defined (se above) these variables are used, you should check if they 
....................    // matches your target device, but for most pic's they should do 
....................    #byte SSPBUF   = 0xFC9 
....................    #byte SSPSTAT   = 0xFC7 
....................    #byte SSPCON1   = 0xFC6 
....................    #bit  BF      = SSPSTAT.0 
.................... #endif 
....................  
.................... #ifdef ENABLE_FILELISTNG 
....................    #include <STDLIBM.H> // used for malloc and free functions 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
.................... node_t * create_node(long size,node_t *ptr ) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
*
162C:  MOVFF  51A,51C
1630:  MOVFF  519,51B
....................    result->size=size; 
1634:  MOVLB  5
1636:  MOVFF  51B,FE9
163A:  MOVFF  51C,FEA
163E:  MOVFF  518,FEC
1642:  MOVF   FED,F
1644:  MOVFF  517,FEF
....................    result->next = NULL; 
1648:  MOVLW  02
164A:  ADDWF  x1B,W
164C:  MOVWF  FE9
164E:  MOVLW  00
1650:  ADDWFC x1C,W
1652:  MOVWF  FEA
1654:  CLRF   FEC
1656:  MOVF   FED,F
1658:  CLRF   FEF
....................    return result; 
165A:  MOVFF  51B,01
165E:  MOVFF  51C,02
.................... } 
1662:  MOVLB  0
1664:  GOTO   1794 (RETURN)
.................... void update_node(node_t *node,long size) // update the size of given node 
.................... { 
....................    node->size=size; 
*
131E:  MOVLB  5
1320:  MOVFF  51A,FE9
1324:  MOVFF  51B,FEA
1328:  MOVFF  51D,FEC
132C:  MOVF   FED,F
132E:  MOVFF  51C,FEF
.................... } 
1332:  MOVLB  0
1334:  RETLW  00
.................... #define csize 32768 
.................... #define pos 15 
.................... #else 
.................... node_t * create_node(int size,node_t *ptr ) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
....................  
.................... void update_node(node_t *node,int size)// update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
.................... #if defined(__PCD__) 
....................    #define csize 32768 
....................    #define pos 15 
.................... #else 
....................    #define csize 127 
....................    #define pos 7 
.................... #endif 
.................... #endif 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place,node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
*
1668:  MOVLW  02
166A:  MOVLB  5
166C:  ADDWF  x13,W
166E:  MOVWF  FE9
1670:  MOVLW  00
1672:  ADDWFC x14,W
1674:  MOVWF  FEA
1676:  MOVFF  FEC,518
167A:  MOVF   FED,F
167C:  MOVFF  FEF,517
1680:  MOVF   x17,F
1682:  BNZ   169C
1684:  MOVF   x18,F
1686:  BNZ   169C
....................        node->next= NULL; 
1688:  MOVLW  02
168A:  ADDWF  x15,W
168C:  MOVWF  FE9
168E:  MOVLW  00
1690:  ADDWFC x16,W
1692:  MOVWF  FEA
1694:  CLRF   FEC
1696:  MOVF   FED,F
1698:  CLRF   FEF
....................     else 
169A:  BRA    16D2
....................        node->next=place->next; 
169C:  MOVLW  02
169E:  ADDWF  x15,W
16A0:  MOVWF  01
16A2:  MOVLW  00
16A4:  ADDWFC x16,W
16A6:  MOVWF  03
16A8:  MOVWF  x18
16AA:  MOVLW  02
16AC:  ADDWF  x13,W
16AE:  MOVWF  FE9
16B0:  MOVLW  00
16B2:  ADDWFC x14,W
16B4:  MOVWF  FEA
16B6:  MOVFF  FEC,03
16BA:  MOVF   FED,F
16BC:  MOVFF  FEF,519
16C0:  MOVFF  518,FEA
16C4:  MOVFF  01,FE9
16C8:  MOVFF  03,FEC
16CC:  MOVF   FED,F
16CE:  MOVFF  519,FEF
....................     place->next=node; 
16D2:  MOVLW  02
16D4:  ADDWF  x13,W
16D6:  MOVWF  FE9
16D8:  MOVLW  00
16DA:  ADDWFC x14,W
16DC:  MOVWF  FEA
16DE:  MOVFF  516,FEC
16E2:  MOVF   FED,F
16E4:  MOVFF  515,FEF
.................... } 
16E8:  MOVLB  0
16EA:  GOTO   17AE (RETURN)
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
*
1336:  MOVFF  07,51D
133A:  MOVFF  06,51C
133E:  MOVLW  02
1340:  MOVLB  5
1342:  ADDWF  x1C,W
1344:  MOVWF  FE9
1346:  MOVLW  00
1348:  ADDWFC x1D,W
134A:  MOVWF  FEA
134C:  MOVFF  FEC,51F
1350:  MOVF   FED,F
1352:  MOVFF  FEF,51E
1356:  MOVF   x1A,W
1358:  SUBWF  x1E,W
135A:  BNZ   1362
135C:  MOVF   x1B,W
135E:  SUBWF  x1F,W
1360:  BZ    1382
1362:  MOVLW  02
1364:  ADDWF  x1C,W
1366:  MOVWF  FE9
1368:  MOVLW  00
136A:  ADDWFC x1D,W
136C:  MOVWF  FEA
136E:  MOVFF  FEC,03
1372:  MOVF   FED,F
1374:  MOVFF  FEF,51C
1378:  MOVFF  03,51D
137C:  MOVLB  0
137E:  BRA    133E
1380:  MOVLB  5
....................    ptr->next=node->next; 
1382:  MOVLW  02
1384:  ADDWF  x1C,W
1386:  MOVWF  01
1388:  MOVLW  00
138A:  ADDWFC x1D,W
138C:  MOVWF  03
138E:  MOVWF  x1F
1390:  MOVLW  02
1392:  ADDWF  x1A,W
1394:  MOVWF  FE9
1396:  MOVLW  00
1398:  ADDWFC x1B,W
139A:  MOVWF  FEA
139C:  MOVFF  FEC,03
13A0:  MOVF   FED,F
13A2:  MOVFF  FEF,520
13A6:  MOVFF  51F,FEA
13AA:  MOVFF  01,FE9
13AE:  MOVFF  03,FEC
13B2:  MOVF   FED,F
13B4:  MOVFF  520,FEF
....................    node=NULL; 
13B8:  CLRF   x1B
13BA:  CLRF   x1A
.................... } 
13BC:  MOVLB  0
13BE:  GOTO   1488 (RETURN)
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     printf( "\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................         printf( "%lx--%x--\n\r",node,node->size); 
....................     printf( "size of node_t %u\r\n",sizeof(node_t)); 
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
13C2:  MOVFF  07,513
13C6:  MOVFF  06,512
....................    while(node!=NULL) 
....................    { 
13CA:  MOVLB  5
13CC:  MOVF   x12,F
13CE:  BNZ   13D6
13D0:  MOVF   x13,F
13D2:  BTFSC  FD8.2
13D4:  BRA    14DE
....................      if(!bit_test(node->size,pos))// node free 
13D6:  MOVFF  512,FE9
13DA:  MOVFF  513,FEA
13DE:  MOVFF  FEC,51B
13E2:  MOVF   FED,F
13E4:  MOVFF  FEF,51A
13E8:  BTFSC  x1B.7
13EA:  BRA    14BE
....................       { 
....................          nsize=node->size; 
13EC:  MOVFF  512,FE9
13F0:  MOVFF  513,FEA
13F4:  MOVFF  FEC,03
13F8:  MOVF   FED,F
13FA:  MOVFF  FEF,516
13FE:  MOVFF  03,517
....................          temp=(unsigned int16)node->next; 
1402:  MOVLW  02
1404:  ADDWF  x12,W
1406:  MOVWF  FE9
1408:  MOVLW  00
140A:  ADDWFC x13,W
140C:  MOVWF  FEA
140E:  MOVFF  FEC,515
1412:  MOVF   FED,F
1414:  MOVFF  FEF,514
....................          if(!bit_test(temp->size,pos)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
1418:  MOVFF  514,FE9
141C:  MOVFF  515,FEA
1420:  MOVFF  FEC,51B
1424:  MOVF   FED,F
1426:  MOVFF  FEF,51A
142A:  BTFSC  x1B.7
142C:  BRA    149E
142E:  MOVF   x16,W
1430:  ADDWF  x12,W
1432:  MOVWF  x1C
1434:  MOVF   x17,W
1436:  ADDWFC x13,W
1438:  MOVWF  x1D
143A:  MOVLW  04
143C:  ADDWF  x1C,W
143E:  MOVWF  01
1440:  MOVLW  00
1442:  ADDWFC x1D,W
1444:  MOVWF  03
1446:  MOVF   01,W
1448:  SUBWF  x14,W
144A:  BNZ   149E
144C:  MOVF   03,W
144E:  SUBWF  x15,W
1450:  BNZ   149E
....................          { 
....................             nextsize=temp->size; 
1452:  MOVFF  514,FE9
1456:  MOVFF  515,FEA
145A:  MOVFF  FEC,03
145E:  MOVF   FED,F
1460:  MOVFF  FEF,518
1464:  MOVFF  03,519
....................             nsize+=nextsize+sizeof(node_t); 
1468:  MOVLW  04
146A:  ADDWF  x18,W
146C:  MOVWF  01
146E:  MOVLW  00
1470:  ADDWFC x19,W
1472:  MOVWF  03
1474:  MOVF   01,W
1476:  ADDWF  x16,F
1478:  MOVF   03,W
147A:  ADDWFC x17,F
....................             remove_node(temp); 
147C:  MOVFF  515,51B
1480:  MOVFF  514,51A
1484:  MOVLB  0
1486:  BRA    1336
....................             update_node(node,nsize); 
1488:  MOVFF  513,51B
148C:  MOVFF  512,51A
1490:  MOVFF  517,51D
1494:  MOVFF  516,51C
1498:  RCALL  131E
....................          } 
....................          else 
149A:  BRA    14BA
149C:  MOVLB  5
....................          node=node->next; 
149E:  MOVLW  02
14A0:  ADDWF  x12,W
14A2:  MOVWF  FE9
14A4:  MOVLW  00
14A6:  ADDWFC x13,W
14A8:  MOVWF  FEA
14AA:  MOVFF  FEC,03
14AE:  MOVF   FED,F
14B0:  MOVFF  FEF,512
14B4:  MOVFF  03,513
14B8:  MOVLB  0
....................       } 
....................       else 
14BA:  BRA    14DA
14BC:  MOVLB  5
....................       node=node->next; 
14BE:  MOVLW  02
14C0:  ADDWF  x12,W
14C2:  MOVWF  FE9
14C4:  MOVLW  00
14C6:  ADDWFC x13,W
14C8:  MOVWF  FEA
14CA:  MOVFF  FEC,03
14CE:  MOVF   FED,F
14D0:  MOVFF  FEF,512
14D4:  MOVFF  03,513
14D8:  MOVLB  0
....................    } 
14DA:  BRA    13CA
14DC:  MOVLB  5
.................... } 
14DE:  MOVLB  0
14E0:  GOTO   1558 (RETURN)
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    node=__DYNAMIC_HEAD; 
*
16EE:  MOVFF  07,50E
16F2:  MOVFF  06,50D
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
16F6:  MOVLB  5
16F8:  MOVF   x0D,F
16FA:  BNZ   1702
16FC:  MOVF   x0E,F
16FE:  BTFSC  FD8.2
1700:  BRA    1808
....................       if(!bit_test(node->size,pos) && node->size >=size) // node is free and > = req size 
1702:  MOVFF  50D,FE9
1706:  MOVFF  50E,FEA
170A:  MOVFF  FEC,514
170E:  MOVF   FED,F
1710:  MOVFF  FEF,513
1714:  BTFSC  x14.7
1716:  BRA    17EC
1718:  MOVFF  50D,FE9
171C:  MOVFF  50E,FEA
1720:  MOVFF  FEC,516
1724:  MOVF   FED,F
1726:  MOVFF  FEF,515
172A:  MOVF   x16,F
172C:  BNZ   1734
172E:  MOVF   x0C,W
1730:  SUBWF  x15,W
1732:  BNC   17EC
....................       { 
....................          nsize=node->size; 
1734:  MOVFF  50D,FE9
1738:  MOVFF  50E,FEA
173C:  MOVFF  FEC,03
1740:  MOVF   FED,F
1742:  MOVFF  FEF,511
1746:  MOVFF  03,512
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
174A:  MOVLW  04
174C:  ADDWF  x0C,W
174E:  MOVF   x12,F
1750:  BNZ   1758
1752:  SUBWF  x11,W
1754:  BZ    17CC
1756:  BNC   17CC
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
1758:  MOVF   x0C,W
175A:  SUBWF  x11,W
175C:  MOVWF  x13
175E:  MOVLW  00
1760:  SUBWFB x12,W
1762:  MOVWF  x14
1764:  MOVLW  04
1766:  SUBWF  x13,F
1768:  MOVLW  00
176A:  SUBWFB x14,F
176C:  MOVLW  04
176E:  ADDWF  x0D,W
1770:  MOVWF  x15
1772:  MOVLW  00
1774:  ADDWFC x0E,W
1776:  MOVWF  x16
1778:  MOVF   x0C,W
177A:  ADDWF  x15,F
177C:  MOVLW  00
177E:  ADDWFC x16,F
1780:  MOVFF  514,518
1784:  MOVFF  513,517
1788:  MOVFF  516,51A
178C:  MOVFF  515,519
1790:  MOVLB  0
1792:  BRA    162C
1794:  MOVFF  02,510
1798:  MOVFF  01,50F
....................             insert_node_after(node,new); 
179C:  MOVFF  50E,514
17A0:  MOVFF  50D,513
17A4:  MOVFF  510,516
17A8:  MOVFF  50F,515
17AC:  BRA    1668
....................             update_node(node,size+csize); 
17AE:  MOVLB  5
17B0:  MOVFF  50C,513
17B4:  MOVLW  80
17B6:  MOVFF  50E,51B
17BA:  MOVFF  50D,51A
17BE:  MOVWF  x1D
17C0:  MOVFF  50C,51C
17C4:  MOVLB  0
17C6:  RCALL  131E
....................          } 
....................          else//not enough space for new node so use original size 
17C8:  BRA    17E8
17CA:  MOVLB  5
....................          update_node(node,nsize+csize); 
17CC:  MOVFF  511,513
17D0:  MOVLW  80
17D2:  ADDWF  x12,W
17D4:  MOVWF  x14
17D6:  MOVFF  50E,51B
17DA:  MOVFF  50D,51A
17DE:  MOVWF  x1D
17E0:  MOVFF  511,51C
17E4:  MOVLB  0
17E6:  RCALL  131E
....................          //end if 
....................          break; 
17E8:  MOVLB  5
17EA:  BRA    1808
....................       }//end if 
....................       node=node->next; 
17EC:  MOVLW  02
17EE:  ADDWF  x0D,W
17F0:  MOVWF  FE9
17F2:  MOVLW  00
17F4:  ADDWFC x0E,W
17F6:  MOVWF  FEA
17F8:  MOVFF  FEC,03
17FC:  MOVF   FED,F
17FE:  MOVFF  FEF,50D
1802:  MOVFF  03,50E
....................    }//end while 
1806:  BRA    16F8
....................    if(node==NULL)// reached end without finding an appropriate node 
1808:  MOVF   x0D,F
180A:  BNZ   181A
180C:  MOVF   x0E,F
180E:  BNZ   181A
....................    { 
....................       //prunsigned int8f("\r\n Not enough memory for allocation"); 
....................       return NULL; 
1810:  MOVLW  00
1812:  MOVWF  01
1814:  MOVWF  02
1816:  BRA    182A
....................    } 
....................    else 
1818:  BRA    182A
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
181A:  MOVLW  04
181C:  ADDWF  x0D,W
181E:  MOVWF  01
1820:  MOVLW  00
1822:  ADDWFC x0E,W
1824:  MOVWF  03
1826:  MOVWF  02
1828:  BRA    182A
.................... } 
182A:  MOVLB  0
182C:  RETLW  00
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................       if(!bit_test(node->size,pos) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+csize); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+csize); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       //prunsigned int8f("\r\n Not enough memory for allocation"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
*
14E4:  MOVLB  5
14E6:  MOVF   x0C,F
14E8:  BNZ   14F2
14EA:  MOVF   x0D,F
14EC:  BNZ   14F2
....................       return; 
14EE:  BRA    155A
....................    else 
14F0:  BRA    1554
....................    { 
....................       node=ptr-sizeof(node_t); 
14F2:  MOVLW  04
14F4:  SUBWF  x0C,W
14F6:  MOVWF  x0E
14F8:  MOVLW  00
14FA:  SUBWFB x0D,W
14FC:  MOVWF  x0F
....................       if(bit_test(node->size,pos))// node occupied 
14FE:  MOVFF  50E,FE9
1502:  MOVFF  50F,FEA
1506:  MOVFF  FEC,513
150A:  MOVF   FED,F
150C:  MOVFF  FEF,512
1510:  BTFSS  x13.7
1512:  BRA    154E
....................       { 
....................          nsize=node->size-csize; 
1514:  MOVFF  50E,FE9
1518:  MOVFF  50F,FEA
151C:  MOVFF  FEC,513
1520:  MOVF   FED,F
1522:  MOVFF  FEF,512
1526:  MOVLW  00
1528:  SUBWF  x12,W
152A:  MOVWF  x10
152C:  MOVLW  80
152E:  SUBWFB x13,W
1530:  MOVWF  x11
....................          update_node(node,nsize); 
1532:  MOVFF  50F,51B
1536:  MOVFF  50E,51A
153A:  MOVFF  511,51D
153E:  MOVFF  510,51C
1542:  MOVLB  0
1544:  RCALL  131E
....................          ptr=NULL; 
1546:  MOVLB  5
1548:  CLRF   x0D
154A:  CLRF   x0C
....................  
....................       } 
....................       else // wrong input, return 
154C:  BRA    1554
....................       { 
....................          ptr=NULL; 
154E:  CLRF   x0D
1550:  CLRF   x0C
....................          return; 
1552:  BRA    155A
....................       } 
....................    } 
....................    traverse(); 
1554:  MOVLB  0
1556:  BRA    13C2
1558:  MOVLB  5
.................... } 
155A:  MOVLB  0
155C:  RETLW  00
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................  
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       malloc(size); 
....................    else if(size==0) 
....................    { 
....................    free(ptr); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,pos))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-csize; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,pos) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+csize); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+csize); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+csize); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,pos) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+csize);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+csize);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          malloc(size); 
....................          //return; 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... int32 FATTable[128]; 
.................... int32 gFirstEmptyCluster; 
....................  
.................... FAT32Vars gFAT32Vars; 
.................... diskinforec DiskInfo; 
.................... FILE gFiles[MAXFILES]; 
....................  
.................... // Time stores the date and time, this is used when writing and/or creating files 
.................... TimeRecord Time; 
....................  
.................... #ifdef ENABLE_FILELISTNG 
....................    // Set the maximum number of files/dirs to be listed by Listfile() 
....................    #define MAX_FILE_LIST 10 
....................    // Variables used by InitList(), ListFiles(), NextPage() and SetPage() 
....................    ListPos StartList; 
....................    ListPos CurrentList; 
....................    BOOLEAN changeList; // Do not use this; it is only used by SetPage() and ListFiles() and Initialized by InitFAT() 
....................    // The result of ListFiles() function.. 
....................    LongFileName FileList[MAX_FILE_LIST]; 
.................... #endif 
....................  
.................... #byte MMCAddressL = gFAT32Vars 
.................... #byte MMCAddressH = gFAT32Vars+1 
.................... #byte MMCAddressHL = gFAT32Vars+2 
.................... #byte MMCAddressHH = gFAT32Vars+3 
.................... #byte gStartSectorL = gFAT32Vars+8 
.................... #byte gStartSectorH = gFAT32Vars+9 
.................... #byte gStartSectorHL = gFAT32Vars+10 
....................  
.................... // You should check that these values matches your pic device 
.................... // but for most devices they should be correct 
.................... #define FSR0L      *0xFE9 
.................... #define POSTINC0   *0xFEE 
....................  
.................... // A bunch of error codes 
.................... #define MMC_OK                0 
.................... #define MMC_ERROR             0x80 
.................... #define MMC_INVALID_FILE       0x88 
.................... #define MMC_MAX_FILES_REACHED    0x90 
.................... #define MMC_NO_CARD_INSERTED    0x98 
.................... #define MMC_TIME_OUT         0xA0 
.................... #define MMC_INVALID_RESPONSE   0xA8 
.................... #define MMC_NOT_FOUND         0xB0 
.................... #define MMC_INVALID_CLUSTER      0xB8 
.................... #define MMC_END_OF_DIR         0xC0 
.................... #define MMC_INVALID_POSITION   0xC8 
....................  
.................... // I don't like having constants in the code... yeah, I do have some anyway ;) 
.................... #define END_OF_DIR                  17 
.................... #define DIRENTRYS_PER_SECTOR         16 
.................... #define CHARACTERS_IN_LONG_FILENAMES   13 
....................  
.................... // If you want to have a cardinserted sens-pin, define CardInserted to a input, like: 
.................... // #define CardInserted !input(PIN_XX) 
.................... // MMC Card have two GND pins, pull one up with a resistor (10K or somwthing like that) to Vcc 
.................... // and connect to desired pin 
.................... #define CardInserted() 1 
....................  
.................... // Looks a bit nicer in the code 
.................... #define MMC_Select()    output_low(ChipSel) 
.................... #define MMC_Deselect()   output_high(ChipSel) 
....................  
....................  
.................... // Below this, there should be no need to change anything 
....................  
....................  
.................... char IsSelfDir(char *be) 
.................... { 
....................    if (be[0] == '.' && be[1] == '.') 
*
0788:  MOVLB  5
078A:  MOVFF  50E,FE9
078E:  MOVFF  50F,FEA
0792:  MOVF   FEF,W
0794:  SUBLW  2E
0796:  BNZ   07B2
0798:  MOVLW  01
079A:  ADDWF  x0E,W
079C:  MOVWF  FE9
079E:  MOVLW  00
07A0:  ADDWFC x0F,W
07A2:  MOVWF  FEA
07A4:  MOVF   FEF,W
07A6:  SUBLW  2E
07A8:  BNZ   07B2
....................       return 0xFF; 
07AA:  MOVLW  FF
07AC:  MOVWF  01
07AE:  BRA    07B8
....................    else 
07B0:  BRA    07B8
....................       return 0; 
07B2:  MOVLW  00
07B4:  MOVWF  01
07B6:  BRA    07B8
.................... } 
07B8:  MOVLB  0
07BA:  GOTO   0E6A (RETURN)
....................  
.................... void MMCOut(char indata) 
.................... { 
....................   #ifdef MMC_SPI_SOFTWARE 
....................    MMC_Xfer(indata); 
*
00D4:  MOVFF  549,54A
00D8:  MOVLW  08
00DA:  MOVLB  5
00DC:  MOVWF  x4B
00DE:  MOVLB  0
00E0:  RCALL  009E
....................   #else 
....................    char i; 
....................    SSPBUF=indata; 
....................    while (!BF); 
....................    i = SSPBUF; 
....................   #endif 
.................... } 
00E2:  RETLW  00
....................  
.................... void MMC8Clock() 
.................... { 
....................   #ifdef MMC_SPI_SOFTWARE 
....................    MMC_Xfer(0xFF); 
*
010E:  MOVLW  FF
0110:  MOVLB  5
0112:  MOVWF  x4A
0114:  MOVLW  08
0116:  MOVWF  x4B
0118:  MOVLB  0
011A:  RCALL  009E
....................   #else 
....................    char i; 
....................    SSPBUF=0xFF; 
....................    while (!BF); 
....................    i = SSPBUF; 
....................   #endif 
.................... } 
011C:  RETLW  00
....................  
.................... char MMCIn() 
.................... { 
....................   #ifdef MMC_SPI_SOFTWARE 
....................    return MMC_Xfer(0xFF); 
011E:  MOVLW  FF
0120:  MOVLB  5
0122:  MOVWF  x4A
0124:  MOVLW  08
0126:  MOVWF  x4B
0128:  MOVLB  0
012A:  RCALL  009E
012C:  MOVF   01,W
....................   #else 
....................    char i; 
....................    SSPBUF=0xFF; 
....................    while (!BF); 
....................    i = SSPBUF; 
....................    return i; 
....................   #endif 
.................... } 
012E:  RETLW  00
....................  
.................... MMCResponse MMCInit() 
.................... { 
....................    char response,iii,errcnt; 
....................     
....................  
....................    if (!CardInserted()) 
....................       return MMC_NO_CARD_INSERTED; 
....................  
....................    SET_MMC_TRIS();  // Set input/output 
0130:  MOVLW  10
0132:  MOVWF  F93
....................    restart_wdt(); 
0134:  CLRWDT
....................    MMC_Deselect(); 
0136:  BSF    F8A.7
....................  
....................    #ifndef MMC_SPI_SOFTWARE 
....................       bit_clear(SSPCON1,5); // Disables serial port and configures these pins as I/O port pins 
....................       SSPCON1 = 0x30; // modify this number to change SPI clock rate 
....................                      // Enables serial port and configures SCK, SDO, SDI and SS as serial port pins 
....................                      // Idle state for clock is a high level 
....................                      // 0000 = SPI Master mode, clock = FOSC/4 
....................  
....................       SSPSTAT = 0;   // Only bit 6,7 are writable 
....................                      // 0 = Input data sampled at middle of data output time 
....................                      // 0 = Transmit occurs on transition from Idle to active clock state 
....................    #endif 
....................  
....................    iii = 10; 
0138:  MOVLW  0A
013A:  MOVLB  4
013C:  MOVWF  xEC
....................    errcnt = 100; 
013E:  MOVLW  64
0140:  MOVWF  xED
....................    do 
....................    { 
....................       MMCOut(0xFF); 
0142:  MOVLW  FF
0144:  MOVLB  5
0146:  MOVWF  x49
0148:  MOVLB  0
014A:  RCALL  00D4
....................    } while (--iii); 
014C:  MOVLB  4
014E:  DECFSZ xEC,F
0150:  BRA    0142
....................    delay_us(1000); 
0152:  MOVLW  01
0154:  MOVLB  5
0156:  MOVWF  x48
0158:  MOVLB  0
015A:  RCALL  00E4
....................  
....................    MMC_Select(); // if the /CS line of the MMC is low during CMD0,(below), the card enters SPI-mode 
015C:  BCF    F8A.7
....................    MMCOut(0x40); // CMD0 
015E:  MOVLW  40
0160:  MOVLB  5
0162:  MOVWF  x49
0164:  MOVLB  0
0166:  RCALL  00D4
....................    MMCOut(0x00); 
0168:  MOVLB  5
016A:  CLRF   x49
016C:  MOVLB  0
016E:  RCALL  00D4
....................    MMCOut(0x00); 
0170:  MOVLB  5
0172:  CLRF   x49
0174:  MOVLB  0
0176:  RCALL  00D4
....................    MMCOut(0x00); 
0178:  MOVLB  5
017A:  CLRF   x49
017C:  MOVLB  0
017E:  RCALL  00D4
....................    MMCOut(0x00); 
0180:  MOVLB  5
0182:  CLRF   x49
0184:  MOVLB  0
0186:  RCALL  00D4
....................    MMCOut(0x95); // CRC 
0188:  MOVLW  95
018A:  MOVLB  5
018C:  MOVWF  x49
018E:  MOVLB  0
0190:  RCALL  00D4
....................    MMC8Clock(); 
0192:  RCALL  010E
....................    response = MMCIn(); 
0194:  RCALL  011E
0196:  MOVFF  01,4EB
....................    MMC_Deselect(); 
019A:  BSF    F8A.7
....................    do 
....................    { 
....................       delay_us(1000); 
019C:  MOVLW  01
019E:  MOVLB  5
01A0:  MOVWF  x48
01A2:  MOVLB  0
01A4:  RCALL  00E4
....................       //output_low(ChipClk); 
....................       MMC_Select(); 
01A6:  BCF    F8A.7
....................       MMCOut(0x41); // CMD1 
01A8:  MOVLW  41
01AA:  MOVLB  5
01AC:  MOVWF  x49
01AE:  MOVLB  0
01B0:  RCALL  00D4
....................       MMCOut(0x00); 
01B2:  MOVLB  5
01B4:  CLRF   x49
01B6:  MOVLB  0
01B8:  RCALL  00D4
....................       MMCOut(0x00); 
01BA:  MOVLB  5
01BC:  CLRF   x49
01BE:  MOVLB  0
01C0:  RCALL  00D4
....................       MMCOut(0x00); 
01C2:  MOVLB  5
01C4:  CLRF   x49
01C6:  MOVLB  0
01C8:  RCALL  00D4
....................       MMCOut(0x00); 
01CA:  MOVLB  5
01CC:  CLRF   x49
01CE:  MOVLB  0
01D0:  RCALL  00D4
....................       MMCOut(0x01); 
01D2:  MOVLW  01
01D4:  MOVLB  5
01D6:  MOVWF  x49
01D8:  MOVLB  0
01DA:  RCALL  00D4
....................       MMC8Clock(); 
01DC:  RCALL  010E
....................       response = MMCIn(); 
01DE:  RCALL  011E
01E0:  MOVFF  01,4EB
....................       MMC_Deselect(); 
01E4:  BSF    F8A.7
....................       MMC8Clock(); 
01E6:  RCALL  010E
....................       errcnt--; 
01E8:  MOVLB  4
01EA:  DECF   xED,F
....................    } while (response && errcnt); 
01EC:  MOVF   xEB,F
01EE:  BZ    01FA
01F0:  MOVF   xED,F
01F2:  BTFSC  FD8.2
01F4:  BRA    01FA
01F6:  MOVLB  0
01F8:  BRA    019C
....................    if(response == 0) 
01FA:  MOVF   xEB,F
01FC:  BNZ   0206
....................       return MMC_OK; 
01FE:  MOVLW  00
0200:  MOVWF  01
0202:  BRA    020C
....................    else 
0204:  BRA    020C
....................       return MMC_TIME_OUT; 
0206:  MOVLW  A0
0208:  MOVWF  01
020A:  BRA    020C
.................... } 
020C:  MOVLB  0
020E:  GOTO   40F6 (RETURN)
....................  
....................  
.................... // "Packed" Date: 
.................... // +-------+------------+-------+-----+ 
.................... // | BITS  |    15:9    |  8:5  | 4:0 | 
.................... // | VALUE |Year  1980 | Month | Day | 
.................... // +-------+------------+-------+-----+ 
.................... int16 GetCurrentDOSDate() 
.................... { 
....................    int16 retval; 
....................  
....................    retval = Time.Year - 1980; 
*
2CF6:  MOVLW  BC
2CF8:  MOVLB  4
2CFA:  SUBWF  x87,W
2CFC:  MOVLB  5
2CFE:  MOVWF  x11
2D00:  MOVLW  07
2D02:  MOVLB  4
2D04:  SUBWFB x88,W
2D06:  MOVLB  5
2D08:  MOVWF  x12
....................    retval <<= 9; 
2D0A:  BCF    FD8.0
2D0C:  MOVFF  511,512
2D10:  CLRF   x11
2D12:  RLCF   x12,F
....................    retval |= ((int16)Time.Month << 5); 
2D14:  CLRF   x14
2D16:  MOVFF  489,513
2D1A:  RLCF   x13,W
2D1C:  MOVWF  02
2D1E:  RLCF   x14,W
2D20:  MOVWF  03
2D22:  RLCF   02,F
2D24:  RLCF   03,F
2D26:  RLCF   02,F
2D28:  RLCF   03,F
2D2A:  RLCF   02,F
2D2C:  RLCF   03,F
2D2E:  RLCF   02,F
2D30:  RLCF   03,F
2D32:  MOVLW  E0
2D34:  ANDWF  02,F
2D36:  MOVF   02,W
2D38:  IORWF  x11,F
2D3A:  MOVF   03,W
2D3C:  IORWF  x12,F
....................    retval |= (int16)Time.Day; 
2D3E:  CLRF   03
2D40:  MOVLB  4
2D42:  MOVF   x8A,W
2D44:  MOVLB  5
2D46:  IORWF  x11,F
2D48:  MOVF   03,W
2D4A:  IORWF  x12,F
....................    return retval; 
2D4C:  MOVFF  511,01
2D50:  MOVFF  512,02
.................... } 
2D54:  MOVLB  0
2D56:  RETLW  00
....................  
.................... // "Packed" Time: 
.................... // +-------+-------+--------+----------+ 
.................... // | BITS  | 15:11 |  10:5  |   4:0    | 
.................... // | VALUE | Hour  | Minute | Second/2 | 
.................... // +-------+-------+--------+----------+ 
.................... int16 GetCurrentDOSTime() 
.................... { 
....................    int16 retval; 
....................  
....................    retval = Time.Hour; 
2D58:  MOVLB  5
2D5A:  CLRF   x12
2D5C:  MOVFF  48B,511
....................    retval <<= 11; 
2D60:  MOVFF  511,512
2D64:  CLRF   x11
2D66:  RLCF   x12,F
2D68:  RLCF   x12,F
2D6A:  RLCF   x12,F
2D6C:  MOVLW  F8
2D6E:  ANDWF  x12,F
....................    retval |= ((int16)Time.Minute << 5); 
2D70:  CLRF   x14
2D72:  MOVFF  48C,513
2D76:  RLCF   x13,W
2D78:  MOVWF  02
2D7A:  RLCF   x14,W
2D7C:  MOVWF  03
2D7E:  RLCF   02,F
2D80:  RLCF   03,F
2D82:  RLCF   02,F
2D84:  RLCF   03,F
2D86:  RLCF   02,F
2D88:  RLCF   03,F
2D8A:  RLCF   02,F
2D8C:  RLCF   03,F
2D8E:  MOVLW  E0
2D90:  ANDWF  02,F
2D92:  MOVF   02,W
2D94:  IORWF  x11,F
2D96:  MOVF   03,W
2D98:  IORWF  x12,F
....................    retval |= (int16)Time.Second >> 1; 
2D9A:  CLRF   x14
2D9C:  MOVFF  48D,513
2DA0:  BCF    FD8.0
2DA2:  RRCF   x14,W
2DA4:  MOVWF  03
2DA6:  RRCF   x13,W
2DA8:  IORWF  x11,F
2DAA:  MOVF   03,W
2DAC:  IORWF  x12,F
....................    return retval; 
2DAE:  MOVFF  511,01
2DB2:  MOVFF  512,02
.................... } 
2DB6:  MOVLB  0
2DB8:  RETLW  00
....................  
.................... // Function: Reads a sector from MMC 
.................... MMCResponse ReadSector(int32 sector, char *hova) 
.................... { 
....................    char errs,response; 
....................    char cnt2,cnt3; 
....................  
....................    #byte sectorL = sector 
....................    #byte sectorH = sector+1 
....................    #byte sectorHL = sector+2 
....................  
....................    if (!CardInserted()) 
....................       return MMC_NO_CARD_INSERTED; 
....................    Disable_interrupts(GLOBAL); 
*
0234:  BCF    FF2.6
0236:  BCF    FF2.7
0238:  BTFSC  FF2.7
023A:  BRA    0236
....................    Restart_wdt(); 
023C:  CLRWDT
....................    MMCAddressL = 0; 
023E:  MOVLB  2
0240:  CLRF   x0C
....................    MMCAddressH = sectorL; 
0242:  MOVFF  53E,20D
....................    MMCAddressHL = sectorH; 
0246:  MOVFF  53F,20E
....................    MMCAddressHH = sectorHL; 
024A:  MOVFF  540,20F
....................    gFAT32Vars.MMCAddress <<= 1; 
024E:  BCF    FD8.0
0250:  RLCF   x0C,F
0252:  RLCF   x0D,F
0254:  RLCF   x0E,F
0256:  RLCF   x0F,F
....................  
....................    MMC_Select(); 
0258:  BCF    F8A.7
....................    MMCOut(0x51); 
025A:  MOVLW  51
025C:  MOVLB  5
025E:  MOVWF  x49
0260:  MOVLB  0
0262:  RCALL  00D4
....................    MMCOut(MMCAddressHH); 
0264:  MOVFF  20F,549
0268:  RCALL  00D4
....................    MMCOut(MMCAddressHL); 
026A:  MOVFF  20E,549
026E:  RCALL  00D4
....................    MMCOut(MMCAddressH & 0xFE); 
0270:  MOVLB  2
0272:  MOVF   x0D,W
0274:  ANDLW  FE
0276:  MOVLB  5
0278:  MOVWF  x48
027A:  MOVWF  x49
027C:  MOVLB  0
027E:  RCALL  00D4
....................    MMCOut(0); 
0280:  MOVLB  5
0282:  CLRF   x49
0284:  MOVLB  0
0286:  RCALL  00D4
....................    MMCOut(0x01); 
0288:  MOVLW  01
028A:  MOVLB  5
028C:  MOVWF  x49
028E:  MOVLB  0
0290:  RCALL  00D4
....................    errs = 8; 
0292:  MOVLW  08
0294:  MOVLB  5
0296:  MOVWF  x44
....................    do 
....................    { 
....................       response = MMCIn(); 
0298:  MOVLB  0
029A:  RCALL  011E
029C:  MOVFF  01,545
....................    } while (--errs && response==0xFF); 
02A0:  MOVLB  5
02A2:  DECF   x44,F
02A4:  BZ    02AC
02A6:  INCFSZ x45,W
02A8:  BRA    02AC
02AA:  BRA    0298
....................    errs = 50; 
02AC:  MOVLW  32
02AE:  MOVWF  x44
....................    do 
....................    { 
....................       response = MMCIn(); 
02B0:  MOVLB  0
02B2:  RCALL  011E
02B4:  MOVFF  01,545
....................       if (response == 0xFE) 
02B8:  MOVLB  5
02BA:  MOVF   x45,W
02BC:  SUBLW  FE
02BE:  BNZ   02C2
....................          break; 
02C0:  BRA    02D0
....................       delay_ms(1); 
02C2:  MOVLW  01
02C4:  MOVWF  x48
02C6:  MOVLB  0
02C8:  RCALL  00E4
....................    } while (--errs); 
02CA:  MOVLB  5
02CC:  DECFSZ x44,F
02CE:  BRA    02B0
....................    FSR0L = (int16)hova; // *0xFE9 
02D0:  MOVFF  543,FEA
02D4:  MOVFF  542,FE9
....................    cnt3 = 2; 
02D8:  MOVLW  02
02DA:  MOVWF  x47
....................    cnt2 = 0; 
02DC:  CLRF   x46
....................    do 
....................    { 
....................       do 
....................       { 
....................          #ifdef MMC_SPI_SOFTWARE 
....................             POSTINC0 = MMC_Xfer(0xFF); // *0xFEE 
02DE:  MOVLW  FF
02E0:  MOVWF  x4A
02E2:  MOVLW  08
02E4:  MOVWF  x4B
02E6:  MOVLB  0
02E8:  RCALL  009E
02EA:  MOVF   01,W
02EC:  MOVFF  01,FEE
....................          #else 
....................             SSPBUF=0xFF; // Writes 0xFF on SPI 
....................             while(!BF); // Wait until Transmitted/Received 
....................             POSTINC0 = SSPBUF; // Read the received byte and place it in adress oxFEE 
....................          #endif 
....................       } while (--cnt2); 
02F0:  MOVLB  5
02F2:  DECFSZ x46,F
02F4:  BRA    02DE
....................    } while (--cnt3); 
02F6:  DECFSZ x47,F
02F8:  BRA    02DE
....................    response = MMCIn(); 
02FA:  MOVLB  0
02FC:  RCALL  011E
02FE:  MOVFF  01,545
....................    response = MMCIn(); 
0302:  RCALL  011E
0304:  MOVFF  01,545
....................    MMC_Deselect(); 
0308:  BSF    F8A.7
....................    Enable_interrupts(GLOBAL); 
030A:  MOVLW  C0
030C:  IORWF  FF2,F
....................    return MMC_OK; 
030E:  MOVLW  00
0310:  MOVWF  01
.................... } 
0312:  RETLW  00
....................  
.................... // Writes a sector to MMC 
.................... MMCResponse WriteSector(int32 sector, char *honnan) 
.................... { 
....................    char errs,response; 
....................    char cnt2,cnt3; 
....................    #byte sectorL = sector 
....................    #byte sectorH = sector+1 
....................    #byte sectorHL = sector+2 
....................  
....................    if (!CardInserted()) 
....................       return MMC_NO_CARD_INSERTED; 
....................    Disable_interrupts(GLOBAL); 
*
298A:  BCF    FF2.6
298C:  BCF    FF2.7
298E:  BTFSC  FF2.7
2990:  BRA    298C
....................    Restart_wdt(); 
2992:  CLRWDT
....................    MMCAddressL = 0; 
2994:  MOVLB  2
2996:  CLRF   x0C
....................    MMCAddressH = sectorL; 
2998:  MOVFF  524,20D
....................    MMCAddressHL = sectorH; 
299C:  MOVFF  525,20E
....................    MMCAddressHH = sectorHL; 
29A0:  MOVFF  526,20F
....................    gFAT32Vars.MMCAddress <<= 1; 
29A4:  BCF    FD8.0
29A6:  RLCF   x0C,F
29A8:  RLCF   x0D,F
29AA:  RLCF   x0E,F
29AC:  RLCF   x0F,F
....................    response = 0; 
29AE:  MOVLB  5
29B0:  CLRF   x2B
....................    //output_low(ChipClk); 
....................    MMC_Select(); 
29B2:  BCF    F8A.7
....................    MMCOut(0x58); 
29B4:  MOVLW  58
29B6:  MOVWF  x49
29B8:  MOVLB  0
29BA:  CALL   00D4
....................    MMCOut(MMCAddressHH); 
29BE:  MOVFF  20F,549
29C2:  CALL   00D4
....................    MMCOut(MMCAddressHL); 
29C6:  MOVFF  20E,549
29CA:  CALL   00D4
....................    MMCOut(MMCAddressH & 0xFE); 
29CE:  MOVLB  2
29D0:  MOVF   x0D,W
29D2:  ANDLW  FE
29D4:  MOVLB  5
29D6:  MOVWF  x2E
29D8:  MOVWF  x49
29DA:  MOVLB  0
29DC:  CALL   00D4
....................    MMCOut(0); 
29E0:  MOVLB  5
29E2:  CLRF   x49
29E4:  MOVLB  0
29E6:  CALL   00D4
....................    MMCOut(0x01); 
29EA:  MOVLW  01
29EC:  MOVLB  5
29EE:  MOVWF  x49
29F0:  MOVLB  0
29F2:  CALL   00D4
....................    MMC8Clock(); 
29F6:  CALL   010E
....................    errs = 8; 
29FA:  MOVLW  08
29FC:  MOVLB  5
29FE:  MOVWF  x2A
....................    do 
....................    { 
....................       response = MMCIn(); 
2A00:  MOVLB  0
2A02:  CALL   011E
2A06:  MOVFF  01,52B
....................    } while (--errs && response==0xFF); 
2A0A:  MOVLB  5
2A0C:  DECF   x2A,F
2A0E:  BZ    2A16
2A10:  INCFSZ x2B,W
2A12:  BRA    2A16
2A14:  BRA    2A00
....................    if (response) 
2A16:  MOVF   x2B,F
2A18:  BZ    2A2C
....................    { 
....................       MMC_Deselect(); 
2A1A:  BSF    F8A.7
....................       //output_high(ChipClk); 
....................       MMC8Clock(); 
2A1C:  MOVLB  0
2A1E:  CALL   010E
....................       Enable_interrupts(GLOBAL); 
2A22:  MOVLW  C0
2A24:  IORWF  FF2,F
....................       return MMC_INVALID_RESPONSE; 
2A26:  MOVLW  A8
2A28:  MOVWF  01
2A2A:  BRA    2AB0
....................    } 
....................    MMC8Clock(); 
2A2C:  MOVLB  0
2A2E:  CALL   010E
....................    MMCOut(0xFE); 
2A32:  MOVLW  FE
2A34:  MOVLB  5
2A36:  MOVWF  x49
2A38:  MOVLB  0
2A3A:  CALL   00D4
....................    FSR0L = (int16)honnan; // *0xFE9 
2A3E:  MOVFF  529,FEA
2A42:  MOVFF  528,FE9
....................    cnt3 = 2; 
2A46:  MOVLW  02
2A48:  MOVLB  5
2A4A:  MOVWF  x2D
....................    cnt2 = 0; 
2A4C:  CLRF   x2C
....................    do 
....................    { 
....................       do 
....................       { /* 
....................  
....................         */ 
....................          #ifdef MMC_SPI_SOFTWARE 
....................               MMC_Xfer(POSTINC0); // *0xFEE 
2A4E:  MOVFF  FEE,54A
2A52:  MOVLW  08
2A54:  MOVWF  x4B
2A56:  MOVLB  0
2A58:  CALL   009E
....................          #else 
....................             SSPBUF=POSTINC0; // Write the byte on address oxFEE to SPI 
....................             while (!BF); 
....................             response = SSPBUF; // thanks to wielen 
....................          #endif 
....................       } while (--cnt2); 
2A5C:  MOVLB  5
2A5E:  DECFSZ x2C,F
2A60:  BRA    2A4E
....................    } while (--cnt3); 
2A62:  DECFSZ x2D,F
2A64:  BRA    2A4E
....................    MMCOut(0x00); 
2A66:  CLRF   x49
2A68:  MOVLB  0
2A6A:  CALL   00D4
....................    MMCOut(0x01); 
2A6E:  MOVLW  01
2A70:  MOVLB  5
2A72:  MOVWF  x49
2A74:  MOVLB  0
2A76:  CALL   00D4
....................    response = MMCIn(); 
2A7A:  CALL   011E
2A7E:  MOVFF  01,52B
....................    response ^= 0xE5; // Bitwise exclusive or assignment operator, x^=y, is the same as x=x^y 
2A82:  MOVLW  E5
2A84:  MOVLB  5
2A86:  XORWF  x2B,F
....................    if (response) 
2A88:  MOVF   x2B,F
2A8A:  BZ    2A8E
....................    { 
....................       goto endwr3; 
2A8C:  BRA    2AA0
....................    } 
....................    do 
....................    { 
....................       response = MMCIn(); 
2A8E:  MOVLB  0
2A90:  CALL   011E
2A94:  MOVFF  01,52B
....................    } while (response == 0); 
2A98:  MOVLB  5
2A9A:  MOVF   x2B,F
2A9C:  BZ    2A8E
....................    response = 0; 
2A9E:  CLRF   x2B
.................... endwr3: 
....................    MMC_Deselect(); 
2AA0:  BSF    F8A.7
....................    //output_high(ChipClk); 
....................    MMC8Clock(); 
2AA2:  MOVLB  0
2AA4:  CALL   010E
....................    Enable_interrupts(GLOBAL); 
2AA8:  MOVLW  C0
2AAA:  IORWF  FF2,F
....................    return MMC_OK; 
2AAC:  MOVLW  00
2AAE:  MOVWF  01
.................... } 
2AB0:  RETLW  00
....................  
.................... // Function: Initializes the FAT system 
.................... void InitFAT() 
.................... { 
....................    int32 actsector; 
....................    char i; 
....................  
....................    gFirstEmptyCluster = 0; 
*
0392:  MOVLB  2
0394:  CLRF   x0B
0396:  CLRF   x0A
0398:  CLRF   x09
039A:  CLRF   x08
....................    gFAT32Vars.gStartSector = 0; 
039C:  CLRF   x17
039E:  CLRF   x16
03A0:  CLRF   x15
03A2:  CLRF   x14
....................    ReadSector(gFAT32Vars.gStartSector,gFiles[MAXFILES-1].IOpuffer); 
03A4:  MOVFF  217,541
03A8:  MOVFF  216,540
03AC:  MOVFF  215,53F
03B0:  MOVFF  214,53E
03B4:  MOVLW  02
03B6:  MOVLB  5
03B8:  MOVWF  x43
03BA:  MOVLW  56
03BC:  MOVWF  x42
03BE:  MOVLB  0
03C0:  RCALL  0234
....................    if (gFiles[MAXFILES-1].IOpuffer[0] != 0xEB) 
03C2:  MOVLB  2
03C4:  MOVF   x56,W
03C6:  SUBLW  EB
03C8:  BZ    03F6
....................    { 
....................       gStartSectorL = gFiles[MAXFILES-1].IOpuffer[0x1C6]; 
03CA:  MOVFF  41C,214
....................       gStartSectorH = gFiles[MAXFILES-1].IOpuffer[0x1C7]; 
03CE:  MOVFF  41D,215
....................       gStartSectorHL = gFiles[MAXFILES-1].IOpuffer[0x1C8]; 
03D2:  MOVFF  41E,216
....................       ReadSector(gFAT32Vars.gStartSector,gFiles[MAXFILES-1].IOpuffer); 
03D6:  MOVFF  217,541
03DA:  MOVFF  216,540
03DE:  MOVFF  215,53F
03E2:  MOVFF  214,53E
03E6:  MOVLW  02
03E8:  MOVLB  5
03EA:  MOVWF  x43
03EC:  MOVLW  56
03EE:  MOVWF  x42
03F0:  MOVLB  0
03F2:  RCALL  0234
03F4:  MOVLB  2
....................    } 
....................    memcpy(&DiskInfo,gFiles[MAXFILES-1].IOpuffer,sizeof(DiskInfo)); 
03F6:  MOVLW  02
03F8:  MOVWF  FEA
03FA:  MOVLW  26
03FC:  MOVWF  FE9
03FE:  MOVLW  02
0400:  MOVWF  FE2
0402:  MOVLW  56
0404:  MOVWF  FE1
0406:  MOVLW  30
0408:  MOVWF  01
040A:  MOVFF  FE6,FEE
040E:  DECFSZ 01,F
0410:  BRA    040A
....................    actsector = gFAT32Vars.gStartSector+DiskInfo.Reserved1; 
0412:  MOVF   x34,W
0414:  ADDWF  x14,W
0416:  MOVLB  4
0418:  MOVWF  xEB
041A:  MOVLB  2
041C:  MOVF   x35,W
041E:  ADDWFC x15,W
0420:  MOVLB  4
0422:  MOVWF  xEC
0424:  MOVLW  00
0426:  MOVLB  2
0428:  ADDWFC x16,W
042A:  MOVLB  4
042C:  MOVWF  xED
042E:  MOVLW  00
0430:  MOVLB  2
0432:  ADDWFC x17,W
0434:  MOVLB  4
0436:  MOVWF  xEE
....................    ReadSector(actsector,FATTable); 
0438:  MOVFF  4EE,541
043C:  MOVFF  4ED,540
0440:  MOVFF  4EC,53F
0444:  MOVFF  4EB,53E
0448:  MOVLB  5
044A:  CLRF   x43
044C:  MOVLW  08
044E:  MOVWF  x42
0450:  MOVLB  0
0452:  RCALL  0234
....................    gFAT32Vars.FATstartidx = 0; 
0454:  MOVLB  2
0456:  CLRF   x13
0458:  CLRF   x12
045A:  CLRF   x11
045C:  CLRF   x10
....................    gFAT32Vars.gFirstDataSector = gFAT32Vars.gStartSector + DiskInfo.FATCopies*DiskInfo.hSectorsPerFat+DiskInfo.Reserved1 - 2; 
045E:  MOVLB  5
0460:  CLRF   x0F
0462:  CLRF   x0E
0464:  CLRF   x0D
0466:  MOVFF  236,50C
046A:  MOVFF  24D,513
046E:  MOVFF  24C,512
0472:  MOVFF  24B,511
0476:  MOVFF  24A,510
047A:  MOVLB  0
047C:  RCALL  0314
047E:  MOVF   00,W
0480:  MOVLB  2
0482:  ADDWF  x14,W
0484:  MOVLB  4
0486:  MOVWF  xF0
0488:  MOVF   01,W
048A:  MOVLB  2
048C:  ADDWFC x15,W
048E:  MOVLB  4
0490:  MOVWF  xF1
0492:  MOVF   02,W
0494:  MOVLB  2
0496:  ADDWFC x16,W
0498:  MOVLB  4
049A:  MOVWF  xF2
049C:  MOVF   03,W
049E:  MOVLB  2
04A0:  ADDWFC x17,W
04A2:  MOVLB  4
04A4:  MOVWF  xF3
04A6:  MOVLB  2
04A8:  MOVF   x34,W
04AA:  MOVLB  4
04AC:  ADDWF  xF0,F
04AE:  MOVLB  2
04B0:  MOVF   x35,W
04B2:  MOVLB  4
04B4:  ADDWFC xF1,F
04B6:  MOVLW  00
04B8:  ADDWFC xF2,F
04BA:  ADDWFC xF3,F
04BC:  MOVLW  02
04BE:  SUBWF  xF0,W
04C0:  MOVLB  2
04C2:  MOVWF  x18
04C4:  MOVLW  00
04C6:  MOVLB  4
04C8:  SUBWFB xF1,W
04CA:  MOVLB  2
04CC:  MOVWF  x19
04CE:  MOVLW  00
04D0:  MOVLB  4
04D2:  SUBWFB xF2,W
04D4:  MOVLB  2
04D6:  MOVWF  x1A
04D8:  MOVLW  00
04DA:  MOVLB  4
04DC:  SUBWFB xF3,W
04DE:  MOVLB  2
04E0:  MOVWF  x1B
....................  
....................    for (i=0;i<MAXFILES;i++) 
04E2:  MOVLB  4
04E4:  CLRF   xEF
04E6:  MOVF   xEF,F
04E8:  BNZ   0522
....................    { 
....................       gFiles[i].Free = TRUE; 
04EA:  MOVLB  5
04EC:  CLRF   x3F
04EE:  MOVFF  4EF,53E
04F2:  MOVLW  02
04F4:  MOVWF  x41
04F6:  MOVLW  31
04F8:  MOVWF  x40
04FA:  MOVLB  0
04FC:  RCALL  0370
04FE:  MOVFF  01,4F0
0502:  MOVLW  30
0504:  MOVLB  4
0506:  ADDWF  01,W
0508:  MOVWF  01
050A:  MOVLW  02
050C:  ADDWFC 02,W
050E:  MOVWF  03
0510:  MOVF   01,W
0512:  ADDLW  56
0514:  MOVWF  FE9
0516:  MOVLW  02
0518:  ADDWFC 03,W
051A:  MOVWF  FEA
051C:  BSF    FEF.0
....................    } 
051E:  INCF   xEF,F
0520:  BRA    04E6
....................    #ifdef ENABLE_FILELISTNG 
....................       // Code for initializing file-listing 
....................       for(i=0;i<MAX_FILE_LIST;i++) 
0522:  CLRF   xEF
0524:  MOVF   xEF,W
0526:  SUBLW  09
0528:  BNC   054A
....................          FileList[i].name = NULL; 
052A:  MOVF   xEF,W
052C:  MULLW  05
052E:  MOVF   FF3,W
0530:  CLRF   xF1
0532:  MOVWF  xF0
0534:  MOVLW  A1
0536:  ADDWF  xF0,W
0538:  MOVWF  FE9
053A:  MOVLW  04
053C:  ADDWFC xF1,W
053E:  MOVWF  FEA
0540:  CLRF   FEC
0542:  MOVF   FED,F
0544:  CLRF   FEF
0546:  INCF   xEF,F
0548:  BRA    0524
....................       changeList = TRUE; 
054A:  BSF    xA0.0
....................    #endif 
.................... //   MMC_Debug("-FATInit "); 
.................... } 
054C:  MOVLB  0
054E:  GOTO   410C (RETURN)
....................  
.................... int32 GetNextCluster(int32 curcluster) 
.................... { 
....................    int32 actsector; 
....................    int32 clpage; 
....................    char clpos; 
....................  
....................    clpage = curcluster >> 7; 
*
08F6:  MOVLB  5
08F8:  RRCF   x34,W
08FA:  MOVWF  x3C
08FC:  RRCF   x33,W
08FE:  MOVWF  x3B
0900:  RRCF   x32,W
0902:  MOVWF  x3A
0904:  RRCF   x31,W
0906:  MOVWF  x39
0908:  RRCF   x3C,F
090A:  RRCF   x3B,F
090C:  RRCF   x3A,F
090E:  RRCF   x39,F
0910:  RRCF   x3C,F
0912:  RRCF   x3B,F
0914:  RRCF   x3A,F
0916:  RRCF   x39,F
0918:  RRCF   x3C,F
091A:  RRCF   x3B,F
091C:  RRCF   x3A,F
091E:  RRCF   x39,F
0920:  RRCF   x3C,F
0922:  RRCF   x3B,F
0924:  RRCF   x3A,F
0926:  RRCF   x39,F
0928:  RRCF   x3C,F
092A:  RRCF   x3B,F
092C:  RRCF   x3A,F
092E:  RRCF   x39,F
0930:  RRCF   x3C,F
0932:  RRCF   x3B,F
0934:  RRCF   x3A,F
0936:  RRCF   x39,F
0938:  MOVLW  01
093A:  ANDWF  x3C,F
....................    clpos = curcluster & 0x7F; 
093C:  MOVF   x31,W
093E:  ANDLW  7F
0940:  MOVWF  x3D
....................    if (clpage != gFAT32Vars.FATstartidx) // read in the requested page 
0942:  MOVLB  2
0944:  MOVF   x10,W
0946:  MOVLB  5
0948:  SUBWF  x39,W
094A:  BNZ   096A
094C:  MOVLB  2
094E:  MOVF   x11,W
0950:  MOVLB  5
0952:  SUBWF  x3A,W
0954:  BNZ   096A
0956:  MOVLB  2
0958:  MOVF   x12,W
095A:  MOVLB  5
095C:  SUBWF  x3B,W
095E:  BNZ   096A
0960:  MOVLB  2
0962:  MOVF   x13,W
0964:  MOVLB  5
0966:  SUBWF  x3C,W
0968:  BZ    09D6
....................    { 
....................       actsector = gFAT32Vars.gStartSector+DiskInfo.Reserved1 + clpage; 
096A:  MOVLB  2
096C:  MOVF   x34,W
096E:  ADDWF  x14,W
0970:  MOVLB  5
0972:  MOVWF  x3E
0974:  MOVLB  2
0976:  MOVF   x35,W
0978:  ADDWFC x15,W
097A:  MOVLB  5
097C:  MOVWF  x3F
097E:  MOVLW  00
0980:  MOVLB  2
0982:  ADDWFC x16,W
0984:  MOVLB  5
0986:  MOVWF  x40
0988:  MOVLW  00
098A:  MOVLB  2
098C:  ADDWFC x17,W
098E:  MOVLB  5
0990:  MOVWF  x41
0992:  MOVF   x39,W
0994:  ADDWF  x3E,W
0996:  MOVWF  x35
0998:  MOVF   x3A,W
099A:  ADDWFC x3F,W
099C:  MOVWF  x36
099E:  MOVF   x3B,W
09A0:  ADDWFC x40,W
09A2:  MOVWF  x37
09A4:  MOVF   x3C,W
09A6:  ADDWFC x41,W
09A8:  MOVWF  x38
....................       ReadSector(actsector,FATTable); 
09AA:  MOVFF  538,541
09AE:  MOVFF  537,540
09B2:  MOVFF  536,53F
09B6:  MOVFF  535,53E
09BA:  CLRF   x43
09BC:  MOVLW  08
09BE:  MOVWF  x42
09C0:  MOVLB  0
09C2:  RCALL  0234
....................       gFAT32Vars.FATstartidx = clpage; 
09C4:  MOVFF  53C,213
09C8:  MOVFF  53B,212
09CC:  MOVFF  53A,211
09D0:  MOVFF  539,210
09D4:  MOVLB  5
....................    } 
....................    return (FATTable[clpos]); 
09D6:  CLRF   x3F
09D8:  MOVFF  53D,53E
09DC:  CLRF   x41
09DE:  MOVLW  04
09E0:  MOVWF  x40
09E2:  MOVLB  0
09E4:  RCALL  0370
09E6:  MOVFF  02,03
09EA:  MOVF   01,W
09EC:  ADDLW  08
09EE:  MOVWF  FE9
09F0:  MOVLW  00
09F2:  ADDWFC 02,W
09F4:  MOVWF  FEA
09F6:  MOVFF  FEF,00
09FA:  MOVFF  FEC,01
09FE:  MOVFF  FEC,02
0A02:  MOVFF  FEC,03
.................... } 
0A06:  RETLW  00
....................  
.................... void SetClusterEntry(int32 curcluster,int32 value) 
.................... { 
....................    int32 actsector; 
....................    int32 clpage; 
....................    char clpos; 
....................  
....................    clpage = curcluster >> 7; 
*
2AB2:  MOVLB  5
2AB4:  RRCF   x16,W
2AB6:  MOVWF  x22
2AB8:  RRCF   x15,W
2ABA:  MOVWF  x21
2ABC:  RRCF   x14,W
2ABE:  MOVWF  x20
2AC0:  RRCF   x13,W
2AC2:  MOVWF  x1F
2AC4:  RRCF   x22,F
2AC6:  RRCF   x21,F
2AC8:  RRCF   x20,F
2ACA:  RRCF   x1F,F
2ACC:  RRCF   x22,F
2ACE:  RRCF   x21,F
2AD0:  RRCF   x20,F
2AD2:  RRCF   x1F,F
2AD4:  RRCF   x22,F
2AD6:  RRCF   x21,F
2AD8:  RRCF   x20,F
2ADA:  RRCF   x1F,F
2ADC:  RRCF   x22,F
2ADE:  RRCF   x21,F
2AE0:  RRCF   x20,F
2AE2:  RRCF   x1F,F
2AE4:  RRCF   x22,F
2AE6:  RRCF   x21,F
2AE8:  RRCF   x20,F
2AEA:  RRCF   x1F,F
2AEC:  RRCF   x22,F
2AEE:  RRCF   x21,F
2AF0:  RRCF   x20,F
2AF2:  RRCF   x1F,F
2AF4:  MOVLW  01
2AF6:  ANDWF  x22,F
....................    clpos = curcluster & 0x7F; 
2AF8:  MOVF   x13,W
2AFA:  ANDLW  7F
2AFC:  MOVWF  x23
....................    actsector = gFAT32Vars.gStartSector+DiskInfo.Reserved1 + clpage; 
2AFE:  MOVLB  2
2B00:  MOVF   x34,W
2B02:  ADDWF  x14,W
2B04:  MOVLB  5
2B06:  MOVWF  x24
2B08:  MOVLB  2
2B0A:  MOVF   x35,W
2B0C:  ADDWFC x15,W
2B0E:  MOVLB  5
2B10:  MOVWF  x25
2B12:  MOVLW  00
2B14:  MOVLB  2
2B16:  ADDWFC x16,W
2B18:  MOVLB  5
2B1A:  MOVWF  x26
2B1C:  MOVLW  00
2B1E:  MOVLB  2
2B20:  ADDWFC x17,W
2B22:  MOVLB  5
2B24:  MOVWF  x27
2B26:  MOVF   x1F,W
2B28:  ADDWF  x24,W
2B2A:  MOVWF  x1B
2B2C:  MOVF   x20,W
2B2E:  ADDWFC x25,W
2B30:  MOVWF  x1C
2B32:  MOVF   x21,W
2B34:  ADDWFC x26,W
2B36:  MOVWF  x1D
2B38:  MOVF   x22,W
2B3A:  ADDWFC x27,W
2B3C:  MOVWF  x1E
....................    if (clpage != gFAT32Vars.FATstartidx) 
2B3E:  MOVLB  2
2B40:  MOVF   x10,W
2B42:  MOVLB  5
2B44:  SUBWF  x1F,W
2B46:  BNZ   2B66
2B48:  MOVLB  2
2B4A:  MOVF   x11,W
2B4C:  MOVLB  5
2B4E:  SUBWF  x20,W
2B50:  BNZ   2B66
2B52:  MOVLB  2
2B54:  MOVF   x12,W
2B56:  MOVLB  5
2B58:  SUBWF  x21,W
2B5A:  BNZ   2B66
2B5C:  MOVLB  2
2B5E:  MOVF   x13,W
2B60:  MOVLB  5
2B62:  SUBWF  x22,W
2B64:  BZ    2B94
....................    { 
....................       ReadSector(actsector,FATTable); 
2B66:  MOVFF  51E,541
2B6A:  MOVFF  51D,540
2B6E:  MOVFF  51C,53F
2B72:  MOVFF  51B,53E
2B76:  CLRF   x43
2B78:  MOVLW  08
2B7A:  MOVWF  x42
2B7C:  MOVLB  0
2B7E:  CALL   0234
....................       gFAT32Vars.FATstartidx = clpage; 
2B82:  MOVFF  522,213
2B86:  MOVFF  521,212
2B8A:  MOVFF  520,211
2B8E:  MOVFF  51F,210
2B92:  MOVLB  5
....................    } 
....................    FATTable[clpos] = value; 
2B94:  CLRF   x3F
2B96:  MOVFF  523,53E
2B9A:  CLRF   x41
2B9C:  MOVLW  04
2B9E:  MOVWF  x40
2BA0:  MOVLB  0
2BA2:  CALL   0370
2BA6:  MOVF   01,W
2BA8:  ADDLW  08
2BAA:  MOVWF  FE9
2BAC:  MOVLW  00
2BAE:  ADDWFC 02,W
2BB0:  MOVWF  FEA
2BB2:  MOVFF  517,FEF
2BB6:  MOVFF  518,FEC
2BBA:  MOVFF  519,FEC
2BBE:  MOVFF  51A,FEC
....................    WriteSector(actsector,FATTable); 
2BC2:  MOVFF  51E,527
2BC6:  MOVFF  51D,526
2BCA:  MOVFF  51C,525
2BCE:  MOVFF  51B,524
2BD2:  MOVLB  5
2BD4:  CLRF   x29
2BD6:  MOVLW  08
2BD8:  MOVWF  x28
2BDA:  MOVLB  0
2BDC:  RCALL  298A
....................    actsector += DiskInfo.hSectorsPerFat; 
2BDE:  MOVLB  2
2BE0:  MOVF   x4A,W
2BE2:  MOVLB  5
2BE4:  ADDWF  x1B,F
2BE6:  MOVLB  2
2BE8:  MOVF   x4B,W
2BEA:  MOVLB  5
2BEC:  ADDWFC x1C,F
2BEE:  MOVLB  2
2BF0:  MOVF   x4C,W
2BF2:  MOVLB  5
2BF4:  ADDWFC x1D,F
2BF6:  MOVLB  2
2BF8:  MOVF   x4D,W
2BFA:  MOVLB  5
2BFC:  ADDWFC x1E,F
....................    WriteSector(actsector,FATTable); 
2BFE:  MOVFF  51E,527
2C02:  MOVFF  51D,526
2C06:  MOVFF  51C,525
2C0A:  MOVFF  51B,524
2C0E:  CLRF   x29
2C10:  MOVLW  08
2C12:  MOVWF  x28
2C14:  MOVLB  0
2C16:  RCALL  298A
.................... } 
2C18:  RETLW  00
....................  
.................... void ClearClusterEntry(int32 curcluster) 
.................... { 
....................    int32 actsector; 
....................    int32 clpage; 
....................    char clpos; 
....................  
....................    clpage = curcluster >> 7; 
....................    clpos = curcluster & 0x7F; 
....................    if (clpage != gFAT32Vars.FATstartidx) 
....................    { 
....................       actsector = gFAT32Vars.gStartSector+DiskInfo.Reserved1 + gFAT32Vars.FATstartidx; 
....................       WriteSector(actsector,FATTable); 
....................       actsector += DiskInfo.hSectorsPerFat; 
....................       WriteSector(actsector,FATTable); 
....................       actsector = gFAT32Vars.gStartSector+DiskInfo.Reserved1 + clpage; 
....................       ReadSector(actsector,FATTable); 
....................       gFAT32Vars.FATstartidx = clpage; 
....................    } 
....................    FATTable[clpos] = 0; 
.................... } 
....................  
.................... int32 FindFirstFreeCluster() 
.................... { 
....................    int32 i,st,actsector,retval; 
....................    char j; 
....................  
....................    st = gFirstEmptyCluster; 
*
27B4:  MOVFF  20B,516
27B8:  MOVFF  20A,515
27BC:  MOVFF  209,514
27C0:  MOVFF  208,513
....................    for (i=st;i<DiskInfo.hSectorsPerFat;i++) 
27C4:  MOVFF  516,512
27C8:  MOVFF  515,511
27CC:  MOVFF  514,510
27D0:  MOVFF  513,50F
27D4:  MOVLB  5
27D6:  MOVF   x12,W
27D8:  MOVLB  2
27DA:  SUBWF  x4D,W
27DC:  BTFSS  FD8.0
27DE:  BRA    2978
27E0:  BNZ   280E
27E2:  MOVLB  5
27E4:  MOVF   x11,W
27E6:  MOVLB  2
27E8:  SUBWF  x4C,W
27EA:  BTFSS  FD8.0
27EC:  BRA    2978
27EE:  BNZ   280E
27F0:  MOVLB  5
27F2:  MOVF   x10,W
27F4:  MOVLB  2
27F6:  SUBWF  x4B,W
27F8:  BTFSS  FD8.0
27FA:  BRA    2978
27FC:  BNZ   280E
27FE:  MOVF   x4A,W
2800:  MOVLB  5
2802:  SUBWF  x0F,W
2804:  BTFSS  FD8.0
2806:  BRA    280C
2808:  MOVLB  2
280A:  BRA    2978
280C:  MOVLB  2
....................    { 
....................       if (i != gFAT32Vars.FATstartidx) 
280E:  MOVF   x10,W
2810:  MOVLB  5
2812:  SUBWF  x0F,W
2814:  BNZ   2834
2816:  MOVLB  2
2818:  MOVF   x11,W
281A:  MOVLB  5
281C:  SUBWF  x10,W
281E:  BNZ   2834
2820:  MOVLB  2
2822:  MOVF   x12,W
2824:  MOVLB  5
2826:  SUBWF  x11,W
2828:  BNZ   2834
282A:  MOVLB  2
282C:  MOVF   x13,W
282E:  MOVLB  5
2830:  SUBWF  x12,W
2832:  BZ    28B2
....................       { 
....................          actsector = gFAT32Vars.gStartSector+DiskInfo.Reserved1 + i; 
2834:  MOVLB  2
2836:  MOVF   x34,W
2838:  ADDWF  x14,W
283A:  MOVLB  5
283C:  MOVWF  x20
283E:  MOVLB  2
2840:  MOVF   x35,W
2842:  ADDWFC x15,W
2844:  MOVLB  5
2846:  MOVWF  x21
2848:  MOVLW  00
284A:  MOVLB  2
284C:  ADDWFC x16,W
284E:  MOVLB  5
2850:  MOVWF  x22
2852:  MOVLW  00
2854:  MOVLB  2
2856:  ADDWFC x17,W
2858:  MOVLB  5
285A:  MOVWF  x23
285C:  MOVF   x0F,W
285E:  ADDWF  x20,W
2860:  MOVWF  x17
2862:  MOVF   x10,W
2864:  ADDWFC x21,W
2866:  MOVWF  x18
2868:  MOVF   x11,W
286A:  ADDWFC x22,W
286C:  MOVWF  x19
286E:  MOVF   x12,W
2870:  ADDWFC x23,W
2872:  MOVWF  x1A
....................          ReadSector(actsector,FATTable); 
2874:  MOVFF  51A,541
2878:  MOVFF  519,540
287C:  MOVFF  518,53F
2880:  MOVFF  517,53E
2884:  CLRF   x43
2886:  MOVLW  08
2888:  MOVWF  x42
288A:  MOVLB  0
288C:  CALL   0234
....................          gFAT32Vars.FATstartidx = gFirstEmptyCluster = i; 
2890:  MOVFF  512,20B
2894:  MOVFF  511,20A
2898:  MOVFF  510,209
289C:  MOVFF  50F,208
28A0:  MOVFF  20B,213
28A4:  MOVFF  20A,212
28A8:  MOVFF  209,211
28AC:  MOVFF  208,210
28B0:  MOVLB  5
....................       } 
....................       for (j=0;j<128;j++) 
28B2:  CLRF   x1F
28B4:  MOVF   x1F,W
28B6:  SUBLW  7F
28B8:  BNC   2964
....................       { 
....................          if (FATTable[j] == 0) 
28BA:  CLRF   x3F
28BC:  MOVFF  51F,53E
28C0:  CLRF   x41
28C2:  MOVLW  04
28C4:  MOVWF  x40
28C6:  MOVLB  0
28C8:  CALL   0370
28CC:  MOVFF  02,03
28D0:  MOVF   01,W
28D2:  ADDLW  08
28D4:  MOVWF  FE9
28D6:  MOVLW  00
28D8:  ADDWFC 02,W
28DA:  MOVWF  FEA
28DC:  MOVFF  FEF,520
28E0:  MOVFF  FEC,521
28E4:  MOVFF  FEC,522
28E8:  MOVFF  FEC,523
28EC:  MOVLB  5
28EE:  MOVF   x20,F
28F0:  BNZ   2960
28F2:  MOVF   x21,F
28F4:  BNZ   2960
28F6:  MOVF   x22,F
28F8:  BNZ   2960
28FA:  MOVF   x23,F
28FC:  BNZ   2960
....................          { 
....................             retval = i; 
28FE:  MOVFF  512,51E
2902:  MOVFF  511,51D
2906:  MOVFF  510,51C
290A:  MOVFF  50F,51B
....................             retval <<= 7; 
290E:  RLCF   x1B,F
2910:  RLCF   x1C,F
2912:  RLCF   x1D,F
2914:  RLCF   x1E,F
2916:  RLCF   x1B,F
2918:  RLCF   x1C,F
291A:  RLCF   x1D,F
291C:  RLCF   x1E,F
291E:  RLCF   x1B,F
2920:  RLCF   x1C,F
2922:  RLCF   x1D,F
2924:  RLCF   x1E,F
2926:  RLCF   x1B,F
2928:  RLCF   x1C,F
292A:  RLCF   x1D,F
292C:  RLCF   x1E,F
292E:  RLCF   x1B,F
2930:  RLCF   x1C,F
2932:  RLCF   x1D,F
2934:  RLCF   x1E,F
2936:  RLCF   x1B,F
2938:  RLCF   x1C,F
293A:  RLCF   x1D,F
293C:  RLCF   x1E,F
293E:  RLCF   x1B,F
2940:  RLCF   x1C,F
2942:  RLCF   x1D,F
2944:  RLCF   x1E,F
2946:  MOVLW  80
2948:  ANDWF  x1B,F
....................             retval |= j; 
294A:  MOVF   x1F,W
294C:  IORWF  x1B,F
....................             return retval; 
294E:  MOVFF  51B,00
2952:  MOVFF  51C,01
2956:  MOVFF  51D,02
295A:  MOVFF  51E,03
295E:  BRA    2986
....................          } 
....................       } 
2960:  INCF   x1F,F
2962:  BRA    28B4
....................    } 
2964:  MOVLW  01
2966:  ADDWF  x0F,F
2968:  BTFSC  FD8.0
296A:  INCF   x10,F
296C:  BTFSC  FD8.2
296E:  INCF   x11,F
2970:  BTFSC  FD8.2
2972:  INCF   x12,F
2974:  BRA    27D6
2976:  MOVLB  2
....................    return 0x0FFFFFFF; 
2978:  MOVLW  FF
297A:  MOVWF  00
297C:  MOVWF  01
297E:  MOVWF  02
2980:  MOVLW  0F
2982:  MOVWF  03
2984:  MOVLB  5
.................... } 
2986:  MOVLB  0
2988:  RETLW  00
....................  
.................... // Function: Converts a dir-entry to a 8.3 filename 
.................... void ConvertFilename(DIR *beDir,char *name) 
.................... { 
....................    char i,j,c; 
....................  
....................    j = 0; 
*
07BE:  MOVLB  5
07C0:  CLRF   x32
....................    name[0] = 0; 
07C2:  MOVFF  52F,FE9
07C6:  MOVFF  530,FEA
07CA:  CLRF   FEF
....................    for (i=0;i<8;i++) 
07CC:  CLRF   x31
07CE:  MOVF   x31,W
07D0:  SUBLW  07
07D2:  BNC   0806
....................    { 
....................       c = beDir->sName[i]; 
07D4:  CLRF   03
07D6:  MOVF   x31,W
07D8:  ADDWF  x2D,W
07DA:  MOVWF  FE9
07DC:  MOVF   x2E,W
07DE:  ADDWFC 03,W
07E0:  MOVWF  FEA
07E2:  MOVFF  FEF,533
....................       if (c == ' ') 
07E6:  MOVF   x33,W
07E8:  SUBLW  20
07EA:  BNZ   07EE
....................          break; 
07EC:  BRA    0806
....................       name[j++] = c; 
07EE:  MOVF   x32,W
07F0:  INCF   x32,F
07F2:  CLRF   03
07F4:  ADDWF  x2F,W
07F6:  MOVWF  FE9
07F8:  MOVF   x30,W
07FA:  ADDWFC 03,W
07FC:  MOVWF  FEA
07FE:  MOVFF  533,FEF
....................    } 
0802:  INCF   x31,F
0804:  BRA    07CE
....................    for (i=0;i<3;i++) 
0806:  CLRF   x31
0808:  MOVF   x31,W
080A:  SUBLW  02
080C:  BNC   0866
....................    { 
....................       c = beDir->spam[i]; 
080E:  CLRF   03
0810:  MOVF   x31,W
0812:  ADDLW  08
0814:  MOVWF  01
0816:  MOVLW  00
0818:  ADDWFC 03,F
081A:  MOVF   01,W
081C:  ADDWF  x2D,W
081E:  MOVWF  FE9
0820:  MOVF   x2E,W
0822:  ADDWFC 03,W
0824:  MOVWF  FEA
0826:  MOVFF  FEF,533
....................       if (c == ' ' || c == 0) 
082A:  MOVF   x33,W
082C:  SUBLW  20
082E:  BZ    0834
0830:  MOVF   x33,F
0832:  BNZ   0836
....................          break; 
0834:  BRA    0866
....................       if (!i) 
0836:  MOVF   x31,F
0838:  BNZ   084E
....................          name[j++] = '.'; 
083A:  MOVF   x32,W
083C:  INCF   x32,F
083E:  CLRF   03
0840:  ADDWF  x2F,W
0842:  MOVWF  FE9
0844:  MOVF   x30,W
0846:  ADDWFC 03,W
0848:  MOVWF  FEA
084A:  MOVLW  2E
084C:  MOVWF  FEF
....................       name[j++] = c; 
084E:  MOVF   x32,W
0850:  INCF   x32,F
0852:  CLRF   03
0854:  ADDWF  x2F,W
0856:  MOVWF  FE9
0858:  MOVF   x30,W
085A:  ADDWFC 03,W
085C:  MOVWF  FEA
085E:  MOVFF  533,FEF
....................    } 
0862:  INCF   x31,F
0864:  BRA    0808
....................    name[j++] = 0; 
0866:  MOVF   x32,W
0868:  INCF   x32,F
086A:  CLRF   03
086C:  ADDWF  x2F,W
086E:  MOVWF  FE9
0870:  MOVF   x30,W
0872:  ADDWFC 03,W
0874:  MOVWF  FEA
0876:  CLRF   FEF
.................... } 
0878:  MOVLB  0
087A:  RETLW  00
....................  
.................... // Function: Converts a dir-entry to a (part of a) long filename. 
.................... //           One dir-entry can hold 13 unicode characters 
.................... void ConvertLongFilename(DIR *beDir,char *name) 
.................... { 
....................    char i,j,c; 
....................  
....................    j = 0; 
*
182E:  MOVLB  5
1830:  CLRF   x0E
....................    name[0] = 0; 
1832:  MOVFF  50B,FE9
1836:  MOVFF  50C,FEA
183A:  CLRF   FEF
....................    for (i=1;i<11;i+=2) 
183C:  MOVLW  01
183E:  MOVWF  x0D
1840:  MOVF   x0D,W
1842:  SUBLW  0A
1844:  BNC   187E
....................    { 
....................       c = (char)(*(((char*)beDir)+i)); 
1846:  MOVF   x0D,W
1848:  ADDWF  x09,W
184A:  MOVWF  01
184C:  MOVLW  00
184E:  ADDWFC x0A,W
1850:  MOVFF  01,FE9
1854:  MOVWF  FEA
1856:  MOVFF  FEF,50F
....................       if (c == 0x00 || c == 0xFF) 
185A:  MOVF   x0F,F
185C:  BZ    1862
185E:  INCFSZ x0F,W
1860:  BRA    1864
....................          break; 
1862:  BRA    187E
....................       name[j++] = c; 
1864:  MOVF   x0E,W
1866:  INCF   x0E,F
1868:  CLRF   03
186A:  ADDWF  x0B,W
186C:  MOVWF  FE9
186E:  MOVF   x0C,W
1870:  ADDWFC 03,W
1872:  MOVWF  FEA
1874:  MOVFF  50F,FEF
....................    } 
1878:  MOVLW  02
187A:  ADDWF  x0D,F
187C:  BRA    1840
....................    if(c!=0x00 && c!= 0xFF) 
187E:  MOVF   x0F,F
1880:  BZ    1916
1882:  INCFSZ x0F,W
1884:  BRA    1888
1886:  BRA    1916
....................    { 
....................       for (i=14;i<26;i+=2) 
1888:  MOVLW  0E
188A:  MOVWF  x0D
188C:  MOVF   x0D,W
188E:  SUBLW  19
1890:  BNC   18CA
....................       { 
....................          c = (char)(*(((char*)beDir)+i));; 
1892:  MOVF   x0D,W
1894:  ADDWF  x09,W
1896:  MOVWF  01
1898:  MOVLW  00
189A:  ADDWFC x0A,W
189C:  MOVFF  01,FE9
18A0:  MOVWF  FEA
18A2:  MOVFF  FEF,50F
....................          if (c == 0 || c == 0xFF) 
18A6:  MOVF   x0F,F
18A8:  BZ    18AE
18AA:  INCFSZ x0F,W
18AC:  BRA    18B0
....................             break; 
18AE:  BRA    18CA
....................          name[j++] = c; 
18B0:  MOVF   x0E,W
18B2:  INCF   x0E,F
18B4:  CLRF   03
18B6:  ADDWF  x0B,W
18B8:  MOVWF  FE9
18BA:  MOVF   x0C,W
18BC:  ADDWFC 03,W
18BE:  MOVWF  FEA
18C0:  MOVFF  50F,FEF
....................       } 
18C4:  MOVLW  02
18C6:  ADDWF  x0D,F
18C8:  BRA    188C
....................       if(c!=0x00 && c != 0xFF) 
18CA:  MOVF   x0F,F
18CC:  BZ    1916
18CE:  INCFSZ x0F,W
18D0:  BRA    18D4
18D2:  BRA    1916
....................       { 
....................          for (i=28;i<31;i+=2) 
18D4:  MOVLW  1C
18D6:  MOVWF  x0D
18D8:  MOVF   x0D,W
18DA:  SUBLW  1E
18DC:  BNC   1916
....................          { 
....................             c = (char)(*(((char*)beDir)+i)); 
18DE:  MOVF   x0D,W
18E0:  ADDWF  x09,W
18E2:  MOVWF  01
18E4:  MOVLW  00
18E6:  ADDWFC x0A,W
18E8:  MOVFF  01,FE9
18EC:  MOVWF  FEA
18EE:  MOVFF  FEF,50F
....................             if (c == 0 || c == 0xFF) 
18F2:  MOVF   x0F,F
18F4:  BZ    18FA
18F6:  INCFSZ x0F,W
18F8:  BRA    18FC
....................                break; 
18FA:  BRA    1916
....................             name[j++] = c; 
18FC:  MOVF   x0E,W
18FE:  INCF   x0E,F
1900:  CLRF   03
1902:  ADDWF  x0B,W
1904:  MOVWF  FE9
1906:  MOVF   x0C,W
1908:  ADDWFC 03,W
190A:  MOVWF  FEA
190C:  MOVFF  50F,FEF
....................          } 
1910:  MOVLW  02
1912:  ADDWF  x0D,F
1914:  BRA    18D8
....................       } 
....................    } 
....................    name[j++] = 0; 
1916:  MOVF   x0E,W
1918:  INCF   x0E,F
191A:  CLRF   03
191C:  ADDWF  x0B,W
191E:  MOVWF  FE9
1920:  MOVF   x0C,W
1922:  ADDWFC 03,W
1924:  MOVWF  FEA
1926:  CLRF   FEF
.................... } 
1928:  MOVLB  0
192A:  RETLW  00
....................  
.................... void GetDOSName(DIR *pDir, char *fname) 
.................... { 
....................    char i,j,leng,c,toext; 
....................  
....................    toext = FALSE; 
*
2C1A:  MOVLB  5
2C1C:  CLRF   x17
....................    j = 0; 
2C1E:  CLRF   x14
....................    leng = strlen(fname); 
2C20:  MOVFF  512,519
2C24:  MOVFF  511,518
2C28:  MOVLB  0
2C2A:  CALL   074E
2C2E:  MOVFF  01,515
....................    for (i=0;i<8;i++) 
2C32:  MOVLB  5
2C34:  CLRF   x13
2C36:  MOVF   x13,W
2C38:  SUBLW  07
2C3A:  BNC   2C52
....................       pDir->sName[i] = ' '; 
2C3C:  CLRF   03
2C3E:  MOVF   x13,W
2C40:  ADDWF  x0F,W
2C42:  MOVWF  FE9
2C44:  MOVF   x10,W
2C46:  ADDWFC 03,W
2C48:  MOVWF  FEA
2C4A:  MOVLW  20
2C4C:  MOVWF  FEF
2C4E:  INCF   x13,F
2C50:  BRA    2C36
....................    for (i=0;i<3;i++) 
2C52:  CLRF   x13
2C54:  MOVF   x13,W
2C56:  SUBLW  02
2C58:  BNC   2C7A
....................       pDir->spam[i] = ' '; 
2C5A:  CLRF   03
2C5C:  MOVF   x13,W
2C5E:  ADDLW  08
2C60:  MOVWF  01
2C62:  MOVLW  00
2C64:  ADDWFC 03,F
2C66:  MOVF   01,W
2C68:  ADDWF  x0F,W
2C6A:  MOVWF  FE9
2C6C:  MOVF   x10,W
2C6E:  ADDWFC 03,W
2C70:  MOVWF  FEA
2C72:  MOVLW  20
2C74:  MOVWF  FEF
2C76:  INCF   x13,F
2C78:  BRA    2C54
....................    for (i=0;i<leng;i++) 
2C7A:  CLRF   x13
2C7C:  MOVF   x15,W
2C7E:  SUBWF  x13,W
2C80:  BC    2CF0
....................    { 
....................       c = fname[i]; 
2C82:  CLRF   03
2C84:  MOVF   x13,W
2C86:  ADDWF  x11,W
2C88:  MOVWF  FE9
2C8A:  MOVF   x12,W
2C8C:  ADDWFC 03,W
2C8E:  MOVWF  FEA
2C90:  MOVFF  FEF,516
....................       c = toupper(c); 
2C94:  MOVF   x16,W
2C96:  SUBLW  60
2C98:  BC    2CA6
2C9A:  MOVF   x16,W
2C9C:  SUBLW  7A
2C9E:  BNC   2CA6
2CA0:  MOVF   x16,W
2CA2:  ANDLW  DF
2CA4:  BRA    2CA8
2CA6:  MOVF   x16,W
2CA8:  MOVWF  x16
....................       if (c == '.') 
2CAA:  MOVF   x16,W
2CAC:  SUBLW  2E
2CAE:  BNZ   2CB6
....................       { 
....................          toext = TRUE; 
2CB0:  MOVLW  01
2CB2:  MOVWF  x17
....................          continue; 
2CB4:  BRA    2CEC
....................       } 
....................       if (toext) 
2CB6:  MOVF   x17,F
2CB8:  BZ    2CDA
....................          pDir->spam[j++] = c; 
2CBA:  MOVF   x14,W
2CBC:  INCF   x14,F
2CBE:  CLRF   03
2CC0:  ADDLW  08
2CC2:  MOVWF  01
2CC4:  MOVLW  00
2CC6:  ADDWFC 03,F
2CC8:  MOVF   01,W
2CCA:  ADDWF  x0F,W
2CCC:  MOVWF  FE9
2CCE:  MOVF   x10,W
2CD0:  ADDWFC 03,W
2CD2:  MOVWF  FEA
2CD4:  MOVFF  516,FEF
....................       else 
2CD8:  BRA    2CEC
....................          pDir->sName[i] = c; 
2CDA:  CLRF   03
2CDC:  MOVF   x13,W
2CDE:  ADDWF  x0F,W
2CE0:  MOVWF  FE9
2CE2:  MOVF   x10,W
2CE4:  ADDWFC 03,W
2CE6:  MOVWF  FEA
2CE8:  MOVFF  516,FEF
....................    } 
2CEC:  INCF   x13,F
2CEE:  BRA    2C7C
.................... } 
2CF0:  MOVLB  0
2CF2:  GOTO   3088 (RETURN)
....................  
.................... // Function: Sets the file f to root dir 
.................... MMCResponse ReadRootDirectory(char fil) 
.................... { 
....................    int32 actsector; 
....................  
....................    if (fil > (MAXFILES-1)) 
*
0552:  MOVLB  5
0554:  MOVF   x07,F
0556:  BZ    055E
....................       return MMC_INVALID_FILE; 
0558:  MOVLW  88
055A:  MOVWF  01
055C:  BRA    0748
....................    actsector = gFAT32Vars.gStartSector + DiskInfo.FATCopies*DiskInfo.hSectorsPerFat+DiskInfo.Reserved1; 
055E:  CLRF   x0F
0560:  CLRF   x0E
0562:  CLRF   x0D
0564:  MOVFF  236,50C
0568:  MOVFF  24D,513
056C:  MOVFF  24C,512
0570:  MOVFF  24B,511
0574:  MOVFF  24A,510
0578:  MOVLB  0
057A:  RCALL  0314
057C:  MOVF   00,W
057E:  MOVLB  2
0580:  ADDWF  x14,W
0582:  MOVLB  5
0584:  MOVWF  x0C
0586:  MOVF   01,W
0588:  MOVLB  2
058A:  ADDWFC x15,W
058C:  MOVLB  5
058E:  MOVWF  x0D
0590:  MOVF   02,W
0592:  MOVLB  2
0594:  ADDWFC x16,W
0596:  MOVLB  5
0598:  MOVWF  x0E
059A:  MOVF   03,W
059C:  MOVLB  2
059E:  ADDWFC x17,W
05A0:  MOVLB  5
05A2:  MOVWF  x0F
05A4:  MOVLB  2
05A6:  MOVF   x34,W
05A8:  MOVLB  5
05AA:  ADDWF  x0C,W
05AC:  MOVWF  x08
05AE:  MOVLB  2
05B0:  MOVF   x35,W
05B2:  MOVLB  5
05B4:  ADDWFC x0D,W
05B6:  MOVWF  x09
05B8:  MOVLW  00
05BA:  ADDWFC x0E,W
05BC:  MOVWF  x0A
05BE:  MOVLW  00
05C0:  ADDWFC x0F,W
05C2:  MOVWF  x0B
....................    ReadSector(actsector,gFiles[fil].IOpuffer); 
05C4:  CLRF   x3F
05C6:  MOVFF  507,53E
05CA:  MOVLW  02
05CC:  MOVWF  x41
05CE:  MOVLW  31
05D0:  MOVWF  x40
05D2:  MOVLB  0
05D4:  RCALL  0370
05D6:  MOVFF  01,50C
05DA:  MOVLW  56
05DC:  MOVLB  5
05DE:  ADDWF  01,W
05E0:  MOVWF  01
05E2:  MOVLW  02
05E4:  ADDWFC 02,W
05E6:  MOVWF  03
05E8:  MOVFF  01,50C
05EC:  MOVWF  x0D
05EE:  MOVFF  50B,541
05F2:  MOVFF  50A,540
05F6:  MOVFF  509,53F
05FA:  MOVFF  508,53E
05FE:  MOVWF  x43
0600:  MOVFF  01,542
0604:  MOVLB  0
0606:  RCALL  0234
....................    gFAT32Vars.gDirEntrySector = actsector; 
0608:  MOVFF  50B,220
060C:  MOVFF  50A,21F
0610:  MOVFF  509,21E
0614:  MOVFF  508,21D
....................    gFiles[fil].dirSector = actsector; 
0618:  MOVLB  5
061A:  CLRF   x3F
061C:  MOVFF  507,53E
0620:  MOVLW  02
0622:  MOVWF  x41
0624:  MOVLW  31
0626:  MOVWF  x40
0628:  MOVLB  0
062A:  RCALL  0370
062C:  MOVFF  01,50C
0630:  MOVLW  2A
0632:  MOVLB  5
0634:  ADDWF  01,W
0636:  MOVWF  01
0638:  MOVLW  02
063A:  ADDWFC 02,W
063C:  MOVWF  03
063E:  MOVF   01,W
0640:  ADDLW  56
0642:  MOVWF  FE9
0644:  MOVLW  02
0646:  ADDWFC 03,W
0648:  MOVWF  FEA
064A:  MOVFF  508,FEF
064E:  MOVFF  509,FEC
0652:  MOVFF  50A,FEC
0656:  MOVFF  50B,FEC
....................    gFiles[fil].dirIdx = 0; 
065A:  CLRF   x3F
065C:  MOVFF  507,53E
0660:  MOVLW  02
0662:  MOVWF  x41
0664:  MOVLW  31
0666:  MOVWF  x40
0668:  MOVLB  0
066A:  RCALL  0370
066C:  MOVFF  01,50C
0670:  MOVLW  2E
0672:  MOVLB  5
0674:  ADDWF  01,W
0676:  MOVWF  01
0678:  MOVLW  02
067A:  ADDWFC 02,W
067C:  MOVWF  03
067E:  MOVF   01,W
0680:  ADDLW  56
0682:  MOVWF  FE9
0684:  MOVLW  02
0686:  ADDWFC 03,W
0688:  MOVWF  FEA
068A:  CLRF   FEF
....................    memcpy(&(gFiles[fil].DirEntry),gFiles[fil].IOpuffer,32); 
068C:  CLRF   x3F
068E:  MOVFF  507,53E
0692:  MOVLW  02
0694:  MOVWF  x41
0696:  MOVLW  31
0698:  MOVWF  x40
069A:  MOVLB  0
069C:  RCALL  0370
069E:  MOVFF  01,50C
06A2:  MOVLB  5
06A4:  MOVFF  01,01
06A8:  MOVLW  02
06AA:  ADDWF  02,W
06AC:  MOVWF  03
06AE:  MOVF   01,W
06B0:  ADDLW  56
06B2:  MOVWF  01
06B4:  MOVLW  02
06B6:  ADDWFC 03,F
06B8:  MOVFF  01,50C
06BC:  MOVFF  03,50D
06C0:  CLRF   x3F
06C2:  MOVFF  507,53E
06C6:  MOVLW  02
06C8:  MOVWF  x41
06CA:  MOVLW  31
06CC:  MOVWF  x40
06CE:  MOVLB  0
06D0:  RCALL  0370
06D2:  MOVFF  01,50E
06D6:  MOVLW  56
06D8:  MOVLB  5
06DA:  ADDWF  01,W
06DC:  MOVWF  01
06DE:  MOVLW  02
06E0:  ADDWFC 02,W
06E2:  MOVWF  03
06E4:  MOVFF  01,50E
06E8:  MOVWF  x0F
06EA:  MOVFF  50D,FEA
06EE:  MOVFF  50C,FE9
06F2:  MOVWF  FE2
06F4:  MOVFF  01,FE1
06F8:  MOVLW  20
06FA:  MOVWF  01
06FC:  MOVFF  FE6,FEE
0700:  DECFSZ 01,F
0702:  BRA    06FC
....................    gFiles[fil].CurrentCluster = DiskInfo.hRootStartCluster; 
0704:  CLRF   x3F
0706:  MOVFF  507,53E
070A:  MOVLW  02
070C:  MOVWF  x41
070E:  MOVLW  31
0710:  MOVWF  x40
0712:  MOVLB  0
0714:  RCALL  0370
0716:  MOVFF  01,50C
071A:  MOVLW  20
071C:  MOVLB  5
071E:  ADDWF  01,W
0720:  MOVWF  01
0722:  MOVLW  02
0724:  ADDWFC 02,W
0726:  MOVWF  03
0728:  MOVF   01,W
072A:  ADDLW  56
072C:  MOVWF  FE9
072E:  MOVLW  02
0730:  ADDWFC 03,W
0732:  MOVWF  FEA
0734:  MOVFF  252,FEF
0738:  MOVFF  253,FEC
073C:  MOVFF  254,FEC
0740:  MOVFF  255,FEC
....................    return MMC_OK; 
0744:  MOVLW  00
0746:  MOVWF  01
.................... } 
0748:  MOVLB  0
074A:  GOTO   105C (RETURN)
....................  
.................... // Funciton: Finds a file 
.................... char FindDirEntry(char *fname,char f) 
.................... { 
....................    DIR *pDir; 
....................    int16 i; 
....................    char filename[16]; 
....................    int32 nextcluster,actsector; 
....................  
....................    if (f > (MAXFILES-1)) 
*
0A08:  MOVLB  5
0A0A:  MOVF   x10,F
0A0C:  BZ    0A14
....................    { 
....................       return FALSE; 
0A0E:  MOVLW  00
0A10:  MOVWF  01
0A12:  BRA    0D88
....................    } 
....................    gFAT32Vars.gFirstEmptyDirEntry = 0xFF; 
0A14:  MOVLW  FF
0A16:  MOVLB  2
0A18:  MOVWF  x21
....................    gFAT32Vars.gFirstDirEntryCluster = 0x0FFFFFFF; 
0A1A:  MOVLW  0F
0A1C:  MOVWF  x25
0A1E:  MOVLW  FF
0A20:  MOVWF  x24
0A22:  MOVWF  x23
0A24:  MOVWF  x22
....................    do 
....................    { 
....................       pDir = (DIR*)(gFiles[f].IOpuffer); 
0A26:  MOVLB  5
0A28:  CLRF   x3F
0A2A:  MOVFF  510,53E
0A2E:  MOVLW  02
0A30:  MOVWF  x41
0A32:  MOVLW  31
0A34:  MOVWF  x40
0A36:  MOVLB  0
0A38:  RCALL  0370
0A3A:  MOVFF  01,52D
0A3E:  MOVLW  56
0A40:  MOVLB  5
0A42:  ADDWF  01,W
0A44:  MOVWF  01
0A46:  MOVLW  02
0A48:  ADDWFC 02,W
0A4A:  MOVFF  01,511
0A4E:  MOVWF  x12
....................       for (i=0;i<DIRENTRYS_PER_SECTOR;i++) 
0A50:  CLRF   x14
0A52:  CLRF   x13
0A54:  MOVF   x14,F
0A56:  BTFSS  FD8.2
0A58:  BRA    0BC6
0A5A:  MOVF   x13,W
0A5C:  SUBLW  0F
0A5E:  BTFSS  FD8.0
0A60:  BRA    0BC6
....................       { 
....................          if ((pDir->sName[0] == 0xE5 || pDir->sName[0] == 0) && gFAT32Vars.gFirstEmptyDirEntry == 0xFF) // store first free 
0A62:  MOVFF  511,FE9
0A66:  MOVFF  512,FEA
0A6A:  MOVF   FEF,W
0A6C:  SUBLW  E5
0A6E:  BZ    0A7C
0A70:  MOVFF  511,FE9
0A74:  MOVFF  512,FEA
0A78:  MOVF   FEF,F
0A7A:  BNZ   0AE2
0A7C:  MOVLB  2
0A7E:  INCFSZ x21,W
0A80:  BRA    0A84
0A82:  BRA    0A88
0A84:  MOVLB  5
0A86:  BRA    0AE2
....................          { 
....................             gFAT32Vars.gFirstEmptyDirEntry = i; 
0A88:  MOVFF  513,221
....................             gFAT32Vars.gFirstDirEntryCluster = gFiles[f].CurrentCluster; 
0A8C:  MOVLB  5
0A8E:  CLRF   x3F
0A90:  MOVFF  510,53E
0A94:  MOVLW  02
0A96:  MOVWF  x41
0A98:  MOVLW  31
0A9A:  MOVWF  x40
0A9C:  MOVLB  0
0A9E:  RCALL  0370
0AA0:  MOVFF  02,52E
0AA4:  MOVFF  01,52D
0AA8:  MOVLW  20
0AAA:  MOVLB  5
0AAC:  ADDWF  01,W
0AAE:  MOVWF  01
0AB0:  MOVLW  02
0AB2:  ADDWFC 02,W
0AB4:  MOVWF  03
0AB6:  MOVF   01,W
0AB8:  ADDLW  56
0ABA:  MOVWF  FE9
0ABC:  MOVLW  02
0ABE:  ADDWFC 03,W
0AC0:  MOVWF  FEA
0AC2:  MOVFF  FEF,00
0AC6:  MOVFF  FEC,01
0ACA:  MOVFF  FEC,02
0ACE:  MOVFF  FEC,03
0AD2:  MOVFF  03,225
0AD6:  MOVFF  02,224
0ADA:  MOVFF  01,223
0ADE:  MOVFF  00,222
....................          } 
....................          if (pDir->sName[0] == 0) 
0AE2:  MOVFF  511,FE9
0AE6:  MOVFF  512,FEA
0AEA:  MOVF   FEF,F
0AEC:  BNZ   0AF4
....................          { 
....................             return FALSE; 
0AEE:  MOVLW  00
0AF0:  MOVWF  01
0AF2:  BRA    0D88
....................          } 
....................          ConvertFilename(pDir,filename); 
0AF4:  MOVFF  512,52E
0AF8:  MOVFF  511,52D
0AFC:  MOVLW  05
0AFE:  MOVWF  x30
0B00:  MOVLW  15
0B02:  MOVWF  x2F
0B04:  MOVLB  0
0B06:  RCALL  07BE
....................          if (!strcmp(filename,fname)) 
0B08:  MOVLW  05
0B0A:  MOVLB  5
0B0C:  MOVWF  x2E
0B0E:  MOVLW  15
0B10:  MOVWF  x2D
0B12:  MOVFF  50F,530
0B16:  MOVFF  50E,52F
0B1A:  MOVLB  0
0B1C:  BRA    087C
0B1E:  MOVF   01,F
0B20:  BNZ   0BB4
....................          { 
....................             memcpy(&(gFiles[f].DirEntry),pDir,32); 
0B22:  MOVLB  5
0B24:  CLRF   x3F
0B26:  MOVFF  510,53E
0B2A:  MOVLW  02
0B2C:  MOVWF  x41
0B2E:  MOVLW  31
0B30:  MOVWF  x40
0B32:  MOVLB  0
0B34:  RCALL  0370
0B36:  MOVFF  01,52D
0B3A:  MOVLB  5
0B3C:  MOVFF  01,01
0B40:  MOVLW  02
0B42:  ADDWF  02,W
0B44:  MOVWF  03
0B46:  MOVF   01,W
0B48:  ADDLW  56
0B4A:  MOVWF  01
0B4C:  MOVLW  02
0B4E:  ADDWFC 03,F
0B50:  MOVFF  01,52D
0B54:  MOVFF  03,52E
0B58:  MOVFF  03,FEA
0B5C:  MOVFF  01,FE9
0B60:  MOVFF  512,FE2
0B64:  MOVFF  511,FE1
0B68:  MOVLW  20
0B6A:  MOVWF  01
0B6C:  MOVFF  FE6,FEE
0B70:  DECFSZ 01,F
0B72:  BRA    0B6C
....................             gFiles[f].dirIdx = i; 
0B74:  CLRF   x3F
0B76:  MOVFF  510,53E
0B7A:  MOVLW  02
0B7C:  MOVWF  x41
0B7E:  MOVLW  31
0B80:  MOVWF  x40
0B82:  MOVLB  0
0B84:  CALL   0370
0B88:  MOVFF  01,52D
0B8C:  MOVLW  2E
0B8E:  MOVLB  5
0B90:  ADDWF  01,W
0B92:  MOVWF  01
0B94:  MOVLW  02
0B96:  ADDWFC 02,W
0B98:  MOVWF  03
0B9A:  MOVF   01,W
0B9C:  ADDLW  56
0B9E:  MOVWF  FE9
0BA0:  MOVLW  02
0BA2:  ADDWFC 03,W
0BA4:  MOVWF  FEA
0BA6:  MOVFF  513,FEF
....................             gFAT32Vars.gDirEntryIdx = i; 
0BAA:  MOVFF  513,21C
....................             return TRUE; 
0BAE:  MOVLW  01
0BB0:  MOVWF  01
0BB2:  BRA    0D88
....................          } 
....................          pDir++; 
0BB4:  MOVLW  20
0BB6:  MOVLB  5
0BB8:  ADDWF  x11,F
0BBA:  BTFSC  FD8.0
0BBC:  INCF   x12,F
....................       } 
0BBE:  INCF   x13,F
0BC0:  BTFSC  FD8.2
0BC2:  INCF   x14,F
0BC4:  BRA    0A54
....................       nextcluster = GetNextCluster(gFiles[f].CurrentCluster); 
0BC6:  CLRF   x3F
0BC8:  MOVFF  510,53E
0BCC:  MOVLW  02
0BCE:  MOVWF  x41
0BD0:  MOVLW  31
0BD2:  MOVWF  x40
0BD4:  MOVLB  0
0BD6:  CALL   0370
0BDA:  MOVFF  01,52D
0BDE:  MOVLW  20
0BE0:  MOVLB  5
0BE2:  ADDWF  01,W
0BE4:  MOVWF  01
0BE6:  MOVLW  02
0BE8:  ADDWFC 02,W
0BEA:  MOVWF  03
0BEC:  MOVF   01,W
0BEE:  ADDLW  56
0BF0:  MOVWF  FE9
0BF2:  MOVLW  02
0BF4:  ADDWFC 03,W
0BF6:  MOVWF  FEA
0BF8:  MOVFF  FEF,52D
0BFC:  MOVFF  FEC,52E
0C00:  MOVFF  FEC,52F
0C04:  MOVFF  FEC,530
0C08:  MOVFF  530,534
0C0C:  MOVFF  52F,533
0C10:  MOVFF  52E,532
0C14:  MOVFF  52D,531
0C18:  MOVLB  0
0C1A:  RCALL  08F6
0C1C:  MOVFF  03,528
0C20:  MOVFF  02,527
0C24:  MOVFF  01,526
0C28:  MOVFF  00,525
....................       if (nextcluster != 0x0FFFFFFF && nextcluster != 0) 
0C2C:  MOVLB  5
0C2E:  INCFSZ x25,W
0C30:  BRA    0C42
0C32:  INCFSZ x26,W
0C34:  BRA    0C42
0C36:  INCFSZ x27,W
0C38:  BRA    0C42
0C3A:  MOVF   x28,W
0C3C:  SUBLW  0F
0C3E:  BTFSC  FD8.2
0C40:  BRA    0D5A
0C42:  MOVF   x25,F
0C44:  BNZ   0C54
0C46:  MOVF   x26,F
0C48:  BNZ   0C54
0C4A:  MOVF   x27,F
0C4C:  BNZ   0C54
0C4E:  MOVF   x28,F
0C50:  BTFSC  FD8.2
0C52:  BRA    0D5A
....................       { 
....................          actsector = nextcluster + gFAT32Vars.gFirstDataSector; 
0C54:  MOVLB  2
0C56:  MOVF   x18,W
0C58:  MOVLB  5
0C5A:  ADDWF  x25,W
0C5C:  MOVWF  x29
0C5E:  MOVLB  2
0C60:  MOVF   x19,W
0C62:  MOVLB  5
0C64:  ADDWFC x26,W
0C66:  MOVWF  x2A
0C68:  MOVLB  2
0C6A:  MOVF   x1A,W
0C6C:  MOVLB  5
0C6E:  ADDWFC x27,W
0C70:  MOVWF  x2B
0C72:  MOVLB  2
0C74:  MOVF   x1B,W
0C76:  MOVLB  5
0C78:  ADDWFC x28,W
0C7A:  MOVWF  x2C
....................          ReadSector(actsector,gFiles[f].IOpuffer); 
0C7C:  CLRF   x3F
0C7E:  MOVFF  510,53E
0C82:  MOVLW  02
0C84:  MOVWF  x41
0C86:  MOVLW  31
0C88:  MOVWF  x40
0C8A:  MOVLB  0
0C8C:  CALL   0370
0C90:  MOVFF  01,52D
0C94:  MOVLW  56
0C96:  MOVLB  5
0C98:  ADDWF  01,W
0C9A:  MOVWF  01
0C9C:  MOVLW  02
0C9E:  ADDWFC 02,W
0CA0:  MOVWF  03
0CA2:  MOVFF  01,52D
0CA6:  MOVWF  x2E
0CA8:  MOVFF  52C,541
0CAC:  MOVFF  52B,540
0CB0:  MOVFF  52A,53F
0CB4:  MOVFF  529,53E
0CB8:  MOVWF  x43
0CBA:  MOVFF  01,542
0CBE:  MOVLB  0
0CC0:  CALL   0234
....................          gFAT32Vars.gDirEntrySector = actsector; 
0CC4:  MOVFF  52C,220
0CC8:  MOVFF  52B,21F
0CCC:  MOVFF  52A,21E
0CD0:  MOVFF  529,21D
....................          gFiles[f].dirSector = actsector; 
0CD4:  MOVLB  5
0CD6:  CLRF   x3F
0CD8:  MOVFF  510,53E
0CDC:  MOVLW  02
0CDE:  MOVWF  x41
0CE0:  MOVLW  31
0CE2:  MOVWF  x40
0CE4:  MOVLB  0
0CE6:  CALL   0370
0CEA:  MOVFF  01,52D
0CEE:  MOVLW  2A
0CF0:  MOVLB  5
0CF2:  ADDWF  01,W
0CF4:  MOVWF  01
0CF6:  MOVLW  02
0CF8:  ADDWFC 02,W
0CFA:  MOVWF  03
0CFC:  MOVF   01,W
0CFE:  ADDLW  56
0D00:  MOVWF  FE9
0D02:  MOVLW  02
0D04:  ADDWFC 03,W
0D06:  MOVWF  FEA
0D08:  MOVFF  529,FEF
0D0C:  MOVFF  52A,FEC
0D10:  MOVFF  52B,FEC
0D14:  MOVFF  52C,FEC
....................          gFiles[f].CurrentCluster = nextcluster; 
0D18:  CLRF   x3F
0D1A:  MOVFF  510,53E
0D1E:  MOVLW  02
0D20:  MOVWF  x41
0D22:  MOVLW  31
0D24:  MOVWF  x40
0D26:  MOVLB  0
0D28:  CALL   0370
0D2C:  MOVFF  01,52D
0D30:  MOVLW  20
0D32:  MOVLB  5
0D34:  ADDWF  01,W
0D36:  MOVWF  01
0D38:  MOVLW  02
0D3A:  ADDWFC 02,W
0D3C:  MOVWF  03
0D3E:  MOVF   01,W
0D40:  ADDLW  56
0D42:  MOVWF  FE9
0D44:  MOVLW  02
0D46:  ADDWFC 03,W
0D48:  MOVWF  FEA
0D4A:  MOVFF  525,FEF
0D4E:  MOVFF  526,FEC
0D52:  MOVFF  527,FEC
0D56:  MOVFF  528,FEC
....................       } 
....................    } while (nextcluster != 0x0FFFFFFF && nextcluster != 0); 
0D5A:  INCFSZ x25,W
0D5C:  BRA    0D6C
0D5E:  INCFSZ x26,W
0D60:  BRA    0D6C
0D62:  INCFSZ x27,W
0D64:  BRA    0D6C
0D66:  MOVF   x28,W
0D68:  SUBLW  0F
0D6A:  BZ    0D84
0D6C:  MOVF   x25,F
0D6E:  BTFSS  FD8.2
0D70:  BRA    0A28
0D72:  MOVF   x26,F
0D74:  BTFSS  FD8.2
0D76:  BRA    0A28
0D78:  MOVF   x27,F
0D7A:  BTFSS  FD8.2
0D7C:  BRA    0A28
0D7E:  MOVF   x28,F
0D80:  BTFSS  FD8.2
0D82:  BRA    0A28
....................    return FALSE; 
0D84:  MOVLW  00
0D86:  MOVWF  01
.................... } 
0D88:  MOVLB  0
0D8A:  RETLW  00
....................  
.................... // Function: Assign a filenumber(f) and open the directory 
.................... //           where the file are and return the filename. 
.................... char* TryFile(char *fname, char *f) 
.................... { 
....................    char i,leng; 
....................    char *filename; 
....................  
....................    *f = 0xFF; 
*
0FCA:  MOVLB  5
0FCC:  MOVFF  500,FE9
0FD0:  MOVFF  501,FEA
0FD4:  MOVLW  FF
0FD6:  MOVWF  FEF
....................    for (i=0;i<MAXFILES;i++) 
0FD8:  CLRF   x02
0FDA:  MOVF   x02,F
0FDC:  BNZ   102A
....................    { 
....................       if (gFiles[i].Free) 
0FDE:  CLRF   x3F
0FE0:  MOVFF  502,53E
0FE4:  MOVLW  02
0FE6:  MOVWF  x41
0FE8:  MOVLW  31
0FEA:  MOVWF  x40
0FEC:  MOVLB  0
0FEE:  CALL   0370
0FF2:  MOVFF  02,507
0FF6:  MOVFF  01,506
0FFA:  MOVLW  30
0FFC:  MOVLB  5
0FFE:  ADDWF  01,W
1000:  MOVWF  01
1002:  MOVLW  02
1004:  ADDWFC 02,W
1006:  MOVWF  03
1008:  MOVF   01,W
100A:  ADDLW  56
100C:  MOVWF  FE9
100E:  MOVLW  02
1010:  ADDWFC 03,W
1012:  MOVWF  FEA
1014:  BTFSS  FEF.0
1016:  BRA    1026
....................       { 
....................          *f = i; 
1018:  MOVFF  500,FE9
101C:  MOVFF  501,FEA
1020:  MOVFF  502,FEF
....................          break; 
1024:  BRA    102A
....................       } 
....................    } 
1026:  INCF   x02,F
1028:  BRA    0FDA
....................    if (*f == 0xFF) 
102A:  MOVFF  501,03
102E:  MOVFF  500,FE9
1032:  MOVFF  501,FEA
1036:  INCFSZ FEF,W
1038:  BRA    1042
....................    { 
....................       return 0; 
103A:  MOVLW  00
103C:  MOVWF  01
103E:  MOVWF  02
1040:  BRA    1148
....................    } 
....................    ReadRootDirectory(*f); 
1042:  MOVFF  501,03
1046:  MOVFF  500,FE9
104A:  MOVFF  501,FEA
104E:  MOVFF  FEF,506
1052:  MOVFF  506,507
1056:  MOVLB  0
1058:  GOTO   0552
....................    filename = fname; 
105C:  MOVFF  4FF,505
1060:  MOVFF  4FE,504
....................    leng = strlen(fname); 
1064:  MOVFF  4FF,519
1068:  MOVFF  4FE,518
106C:  CALL   074E
1070:  MOVFF  01,503
....................    for (i=0;i<leng;i++) 
1074:  MOVLB  5
1076:  CLRF   x02
1078:  MOVF   x03,W
107A:  SUBWF  x02,W
107C:  BC    1140
....................    { 
....................       if (fname[i] == '/') 
107E:  CLRF   03
1080:  MOVF   x02,W
1082:  MOVLB  4
1084:  ADDWF  xFE,W
1086:  MOVWF  FE9
1088:  MOVF   xFF,W
108A:  ADDWFC 03,W
108C:  MOVWF  FEA
108E:  MOVF   FEF,W
1090:  SUBLW  2F
1092:  BNZ   113A
....................       { 
....................          fname[i] = 0; 
1094:  CLRF   03
1096:  MOVLB  5
1098:  MOVF   x02,W
109A:  MOVLB  4
109C:  ADDWF  xFE,W
109E:  MOVWF  FE9
10A0:  MOVF   xFF,W
10A2:  ADDWFC 03,W
10A4:  MOVWF  FEA
10A6:  CLRF   FEF
....................          if (!cwd(filename,*f)) 
10A8:  MOVFF  501,03
10AC:  MOVFF  500,FE9
10B0:  MOVFF  501,FEA
10B4:  MOVFF  FEF,506
10B8:  MOVFF  505,508
10BC:  MOVFF  504,507
10C0:  MOVFF  506,509
10C4:  MOVLB  0
10C6:  BRA    0E52
10C8:  MOVF   01,F
10CA:  BNZ   1116
....................          { 
....................             gFiles[*f].Free = TRUE; 
10CC:  MOVFF  501,03
10D0:  MOVLB  5
10D2:  MOVFF  500,FE9
10D6:  MOVFF  501,FEA
10DA:  CLRF   x3F
10DC:  MOVFF  FEF,53E
10E0:  MOVLW  02
10E2:  MOVWF  x41
10E4:  MOVLW  31
10E6:  MOVWF  x40
10E8:  MOVLB  0
10EA:  CALL   0370
10EE:  MOVFF  01,506
10F2:  MOVLW  30
10F4:  MOVLB  5
10F6:  ADDWF  01,W
10F8:  MOVWF  01
10FA:  MOVLW  02
10FC:  ADDWFC 02,W
10FE:  MOVWF  03
1100:  MOVF   01,W
1102:  ADDLW  56
1104:  MOVWF  FE9
1106:  MOVLW  02
1108:  ADDWFC 03,W
110A:  MOVWF  FEA
110C:  BSF    FEF.0
....................             return 0; 
110E:  MOVLW  00
1110:  MOVWF  01
1112:  MOVWF  02
1114:  BRA    1148
....................          } 
....................          filename = fname+i+1; 
1116:  MOVLB  5
1118:  MOVF   x02,W
111A:  MOVLB  4
111C:  ADDWF  xFE,W
111E:  MOVLB  5
1120:  MOVWF  x06
1122:  MOVLW  00
1124:  MOVLB  4
1126:  ADDWFC xFF,W
1128:  MOVLB  5
112A:  MOVWF  x07
112C:  MOVLW  01
112E:  ADDWF  x06,W
1130:  MOVWF  x04
1132:  MOVLW  00
1134:  ADDWFC x07,W
1136:  MOVWF  x05
1138:  MOVLB  4
....................       } 
....................    } 
113A:  MOVLB  5
113C:  INCF   x02,F
113E:  BRA    1078
....................    return filename; 
1140:  MOVFF  504,01
1144:  MOVFF  505,02
.................... } 
1148:  MOVLB  0
114A:  RETLW  00
....................  
.................... void strfill(char *dest,char *source,int position) 
.................... { 
....................    char *d; 
....................    for(d=dest+position; *source!=0; d++, source++) 
*
192C:  MOVLB  5
192E:  MOVF   x10,W
1930:  ADDWF  x0C,W
1932:  MOVWF  x11
1934:  MOVLW  00
1936:  ADDWFC x0D,W
1938:  MOVWF  x12
193A:  MOVFF  50F,03
193E:  MOVFF  50E,FE9
1942:  MOVFF  50F,FEA
1946:  MOVF   FEF,F
1948:  BZ    1976
....................    { 
....................       *d = *source; 
194A:  MOVFF  50E,FE9
194E:  MOVFF  50F,FEA
1952:  MOVFF  FEF,515
1956:  MOVFF  512,FEA
195A:  MOVFF  511,FE9
195E:  MOVFF  515,FEF
....................    } 
1962:  MOVFF  512,03
1966:  MOVF   x11,W
1968:  INCF   x11,F
196A:  BTFSC  FD8.2
196C:  INCF   x12,F
196E:  INCF   x0E,F
1970:  BTFSC  FD8.2
1972:  INCF   x0F,F
1974:  BRA    193A
.................... } 
1976:  MOVLB  0
1978:  RETLW  00
....................  
.................... // Parameters: path, the path to the directory you 
.................... //             want to view 
.................... // Function    : Initializes file/dir listing 
.................... // Examples: 
.................... // strcpy(path,""); // the "path" to the root directory 
.................... // f = InitList(path); 
.................... // ... 
.................... // strcpy(path,"DIR3/DIR32/"); 
.................... // f = InitList(path); 
.................... // if(InitList == MMC_OK) 
.................... // { 
.................... //   res = Listfiles(f); 
.................... //   CloseList(f); 
.................... // } 
.................... #ifdef ENABLE_FILELISTNG 
.................... MMCResponse InitList(char *path) 
.................... { 
....................    char f; 
....................    if(TryFile(path,&f) == 0) 
*
114C:  MOVFF  4EC,4FF
1150:  MOVFF  4EB,4FE
1154:  MOVLW  04
1156:  MOVLB  5
1158:  MOVWF  x01
115A:  MOVLW  ED
115C:  MOVWF  x00
115E:  MOVLB  0
1160:  RCALL  0FCA
1162:  MOVFF  02,4EF
1166:  MOVFF  01,4EE
116A:  MOVLB  4
116C:  MOVF   xEE,F
116E:  BNZ   117A
1170:  MOVF   xEF,F
1172:  BNZ   117A
....................    { 
....................       return MMC_NOT_FOUND; 
1174:  MOVLW  B0
1176:  MOVWF  01
1178:  BRA    1318
....................    } 
....................    gFiles[f].Free = FALSE;    
117A:  MOVLB  5
117C:  CLRF   x3F
117E:  MOVFF  4ED,53E
1182:  MOVLW  02
1184:  MOVWF  x41
1186:  MOVLW  31
1188:  MOVWF  x40
118A:  MOVLB  0
118C:  CALL   0370
1190:  MOVFF  01,4EE
1194:  MOVLW  30
1196:  MOVLB  4
1198:  ADDWF  01,W
119A:  MOVWF  01
119C:  MOVLW  02
119E:  ADDWFC 02,W
11A0:  MOVWF  03
11A2:  MOVF   01,W
11A4:  ADDLW  56
11A6:  MOVWF  FE9
11A8:  MOVLW  02
11AA:  ADDWFC 03,W
11AC:  MOVWF  FEA
11AE:  BCF    FEF.0
....................    StartList.dirSector = gFiles[f].dirSector; 
11B0:  MOVLB  5
11B2:  CLRF   x3F
11B4:  MOVFF  4ED,53E
11B8:  MOVLW  02
11BA:  MOVWF  x41
11BC:  MOVLW  31
11BE:  MOVWF  x40
11C0:  MOVLB  0
11C2:  CALL   0370
11C6:  MOVFF  02,4EF
11CA:  MOVFF  01,4EE
11CE:  MOVLW  2A
11D0:  MOVLB  4
11D2:  ADDWF  01,W
11D4:  MOVWF  01
11D6:  MOVLW  02
11D8:  ADDWFC 02,W
11DA:  MOVWF  03
11DC:  MOVF   01,W
11DE:  ADDLW  56
11E0:  MOVWF  FE9
11E2:  MOVLW  02
11E4:  ADDWFC 03,W
11E6:  MOVWF  FEA
11E8:  MOVFF  FEF,00
11EC:  MOVFF  FEC,01
11F0:  MOVFF  FEC,02
11F4:  MOVFF  FEC,03
11F8:  MOVFF  03,491
11FC:  MOVFF  02,490
1200:  MOVFF  01,48F
1204:  MOVFF  00,48E
....................    StartList.CurrentCluster = gFiles[f].CurrentCluster; 
1208:  MOVLB  5
120A:  CLRF   x3F
120C:  MOVFF  4ED,53E
1210:  MOVLW  02
1212:  MOVWF  x41
1214:  MOVLW  31
1216:  MOVWF  x40
1218:  MOVLB  0
121A:  CALL   0370
121E:  MOVFF  02,4EF
1222:  MOVFF  01,4EE
1226:  MOVLW  20
1228:  MOVLB  4
122A:  ADDWF  01,W
122C:  MOVWF  01
122E:  MOVLW  02
1230:  ADDWFC 02,W
1232:  MOVWF  03
1234:  MOVF   01,W
1236:  ADDLW  56
1238:  MOVWF  FE9
123A:  MOVLW  02
123C:  ADDWFC 03,W
123E:  MOVWF  FEA
1240:  MOVFF  FEF,00
1244:  MOVFF  FEC,01
1248:  MOVFF  FEC,02
124C:  MOVFF  FEC,03
1250:  MOVFF  03,495
1254:  MOVFF  02,494
1258:  MOVFF  01,493
125C:  MOVFF  00,492
....................    StartList.dirIdx = 0; 
1260:  CLRF   x96
....................    CurrentList.dirSector = gFiles[f].dirSector; 
1262:  MOVLB  5
1264:  CLRF   x3F
1266:  MOVFF  4ED,53E
126A:  MOVLW  02
126C:  MOVWF  x41
126E:  MOVLW  31
1270:  MOVWF  x40
1272:  MOVLB  0
1274:  CALL   0370
1278:  MOVFF  02,4EF
127C:  MOVFF  01,4EE
1280:  MOVLW  2A
1282:  MOVLB  4
1284:  ADDWF  01,W
1286:  MOVWF  01
1288:  MOVLW  02
128A:  ADDWFC 02,W
128C:  MOVWF  03
128E:  MOVF   01,W
1290:  ADDLW  56
1292:  MOVWF  FE9
1294:  MOVLW  02
1296:  ADDWFC 03,W
1298:  MOVWF  FEA
129A:  MOVFF  FEF,00
129E:  MOVFF  FEC,01
12A2:  MOVFF  FEC,02
12A6:  MOVFF  FEC,03
12AA:  MOVFF  03,49A
12AE:  MOVFF  02,499
12B2:  MOVFF  01,498
12B6:  MOVFF  00,497
....................    CurrentList.CurrentCluster = gFiles[f].CurrentCluster; 
12BA:  MOVLB  5
12BC:  CLRF   x3F
12BE:  MOVFF  4ED,53E
12C2:  MOVLW  02
12C4:  MOVWF  x41
12C6:  MOVLW  31
12C8:  MOVWF  x40
12CA:  MOVLB  0
12CC:  CALL   0370
12D0:  MOVFF  02,4EF
12D4:  MOVFF  01,4EE
12D8:  MOVLW  20
12DA:  MOVLB  4
12DC:  ADDWF  01,W
12DE:  MOVWF  01
12E0:  MOVLW  02
12E2:  ADDWFC 02,W
12E4:  MOVWF  03
12E6:  MOVF   01,W
12E8:  ADDLW  56
12EA:  MOVWF  FE9
12EC:  MOVLW  02
12EE:  ADDWFC 03,W
12F0:  MOVWF  FEA
12F2:  MOVFF  FEF,00
12F6:  MOVFF  FEC,01
12FA:  MOVFF  FEC,02
12FE:  MOVFF  FEC,03
1302:  MOVFF  03,49E
1306:  MOVFF  02,49D
130A:  MOVFF  01,49C
130E:  MOVFF  00,49B
....................    CurrentList.dirIdx = 0; 
1312:  CLRF   x9F
....................    return f; 
1314:  MOVFF  4ED,01
.................... } 
1318:  MOVLB  0
131A:  GOTO   4136 (RETURN)
....................  
.................... // Function: Lists a part (aka page) of the files in the directory 
.................... //           specified by InitList() 
.................... // Returns : The number of files/dirs that were listed 
.................... int8 ListFiles(char f) 
.................... { 
*
197A:  MOVLB  5
197C:  BCF    x00.0
....................    DIR *pDir; 
....................    char filename[(CHARACTERS_IN_LONG_FILENAMES+1)]; // should be enough with 13+1 
....................    char i,u,fni,len; 
....................    BOOLEAN isLongFileName = FALSE; 
....................    int32 nextcluster,actsector; 
....................  
....................    if (f > (MAXFILES-1)) 
197E:  MOVLB  4
1980:  MOVF   xEB,F
1982:  BZ    198C
....................       return 0; 
1984:  MOVLW  00
1986:  MOVWF  01
1988:  GOTO   2484
....................  
....................    if(changeList) 
198C:  BTFSS  xA0.0
198E:  BRA    1994
....................    { 
....................       FreeList(); 
1990:  MOVLB  0
1992:  BRA    155E
....................    } 
....................  
....................    if((gFiles[f].CurrentCluster != CurrentList.CurrentCluster) || (gFiles[f].dirSector != CurrentList.dirSector)) 
1994:  MOVLB  5
1996:  CLRF   x3F
1998:  MOVFF  4EB,53E
199C:  MOVLW  02
199E:  MOVWF  x41
19A0:  MOVLW  31
19A2:  MOVWF  x40
19A4:  MOVLB  0
19A6:  CALL   0370
19AA:  MOVFF  01,509
19AE:  MOVLW  20
19B0:  MOVLB  5
19B2:  ADDWF  01,W
19B4:  MOVWF  01
19B6:  MOVLW  02
19B8:  ADDWFC 02,W
19BA:  MOVWF  03
19BC:  MOVF   01,W
19BE:  ADDLW  56
19C0:  MOVWF  FE9
19C2:  MOVLW  02
19C4:  ADDWFC 03,W
19C6:  MOVWF  FEA
19C8:  MOVFF  FEF,509
19CC:  MOVFF  FEC,50A
19D0:  MOVFF  FEC,50B
19D4:  MOVFF  FEC,50C
19D8:  MOVLB  4
19DA:  MOVF   x9B,W
19DC:  MOVLB  5
19DE:  SUBWF  x09,W
19E0:  BNZ   1A6C
19E2:  MOVLB  4
19E4:  MOVF   x9C,W
19E6:  MOVLB  5
19E8:  SUBWF  x0A,W
19EA:  BNZ   1A6C
19EC:  MOVLB  4
19EE:  MOVF   x9D,W
19F0:  MOVLB  5
19F2:  SUBWF  x0B,W
19F4:  BNZ   1A6C
19F6:  MOVLB  4
19F8:  MOVF   x9E,W
19FA:  MOVLB  5
19FC:  SUBWF  x0C,W
19FE:  BNZ   1A6C
1A00:  CLRF   x3F
1A02:  MOVFF  4EB,53E
1A06:  MOVLW  02
1A08:  MOVWF  x41
1A0A:  MOVLW  31
1A0C:  MOVWF  x40
1A0E:  MOVLB  0
1A10:  CALL   0370
1A14:  MOVFF  01,509
1A18:  MOVLW  2A
1A1A:  MOVLB  5
1A1C:  ADDWF  01,W
1A1E:  MOVWF  01
1A20:  MOVLW  02
1A22:  ADDWFC 02,W
1A24:  MOVWF  03
1A26:  MOVF   01,W
1A28:  ADDLW  56
1A2A:  MOVWF  FE9
1A2C:  MOVLW  02
1A2E:  ADDWFC 03,W
1A30:  MOVWF  FEA
1A32:  MOVFF  FEF,509
1A36:  MOVFF  FEC,50A
1A3A:  MOVFF  FEC,50B
1A3E:  MOVFF  FEC,50C
1A42:  MOVLB  4
1A44:  MOVF   x97,W
1A46:  MOVLB  5
1A48:  SUBWF  x09,W
1A4A:  BNZ   1A6C
1A4C:  MOVLB  4
1A4E:  MOVF   x98,W
1A50:  MOVLB  5
1A52:  SUBWF  x0A,W
1A54:  BNZ   1A6C
1A56:  MOVLB  4
1A58:  MOVF   x99,W
1A5A:  MOVLB  5
1A5C:  SUBWF  x0B,W
1A5E:  BNZ   1A6C
1A60:  MOVLB  4
1A62:  MOVF   x9A,W
1A64:  MOVLB  5
1A66:  SUBWF  x0C,W
1A68:  BTFSC  FD8.2
1A6A:  BRA    1B7C
....................    { 
....................       gFiles[f].dirSector = CurrentList.dirSector; 
1A6C:  CLRF   x3F
1A6E:  MOVFF  4EB,53E
1A72:  MOVLW  02
1A74:  MOVWF  x41
1A76:  MOVLW  31
1A78:  MOVWF  x40
1A7A:  MOVLB  0
1A7C:  CALL   0370
1A80:  MOVFF  01,509
1A84:  MOVLW  2A
1A86:  MOVLB  5
1A88:  ADDWF  01,W
1A8A:  MOVWF  01
1A8C:  MOVLW  02
1A8E:  ADDWFC 02,W
1A90:  MOVWF  03
1A92:  MOVF   01,W
1A94:  ADDLW  56
1A96:  MOVWF  FE9
1A98:  MOVLW  02
1A9A:  ADDWFC 03,W
1A9C:  MOVWF  FEA
1A9E:  MOVFF  497,FEF
1AA2:  MOVFF  498,FEC
1AA6:  MOVFF  499,FEC
1AAA:  MOVFF  49A,FEC
....................       gFiles[f].CurrentCluster = CurrentList.CurrentCluster;    
1AAE:  CLRF   x3F
1AB0:  MOVFF  4EB,53E
1AB4:  MOVLW  02
1AB6:  MOVWF  x41
1AB8:  MOVLW  31
1ABA:  MOVWF  x40
1ABC:  MOVLB  0
1ABE:  CALL   0370
1AC2:  MOVFF  01,509
1AC6:  MOVLW  20
1AC8:  MOVLB  5
1ACA:  ADDWF  01,W
1ACC:  MOVWF  01
1ACE:  MOVLW  02
1AD0:  ADDWFC 02,W
1AD2:  MOVWF  03
1AD4:  MOVF   01,W
1AD6:  ADDLW  56
1AD8:  MOVWF  FE9
1ADA:  MOVLW  02
1ADC:  ADDWFC 03,W
1ADE:  MOVWF  FEA
1AE0:  MOVFF  49B,FEF
1AE4:  MOVFF  49C,FEC
1AE8:  MOVFF  49D,FEC
1AEC:  MOVFF  49E,FEC
....................       ReadSector(gFiles[f].dirSector,gFiles[f].IOpuffer); 
1AF0:  CLRF   x3F
1AF2:  MOVFF  4EB,53E
1AF6:  MOVLW  02
1AF8:  MOVWF  x41
1AFA:  MOVLW  31
1AFC:  MOVWF  x40
1AFE:  MOVLB  0
1B00:  CALL   0370
1B04:  MOVFF  01,509
1B08:  MOVLW  2A
1B0A:  MOVLB  5
1B0C:  ADDWF  01,W
1B0E:  MOVWF  01
1B10:  MOVLW  02
1B12:  ADDWFC 02,W
1B14:  MOVWF  03
1B16:  MOVF   01,W
1B18:  ADDLW  56
1B1A:  MOVWF  FE9
1B1C:  MOVLW  02
1B1E:  ADDWFC 03,W
1B20:  MOVWF  FEA
1B22:  MOVFF  FEF,509
1B26:  MOVFF  FEC,50A
1B2A:  MOVFF  FEC,50B
1B2E:  MOVFF  FEC,50C
1B32:  CLRF   x3F
1B34:  MOVFF  4EB,53E
1B38:  MOVLW  02
1B3A:  MOVWF  x41
1B3C:  MOVLW  31
1B3E:  MOVWF  x40
1B40:  MOVLB  0
1B42:  CALL   0370
1B46:  MOVFF  01,50D
1B4A:  MOVLW  56
1B4C:  MOVLB  5
1B4E:  ADDWF  01,W
1B50:  MOVWF  01
1B52:  MOVLW  02
1B54:  ADDWFC 02,W
1B56:  MOVWF  03
1B58:  MOVFF  01,50D
1B5C:  MOVWF  x0E
1B5E:  MOVFF  50C,541
1B62:  MOVFF  50B,540
1B66:  MOVFF  50A,53F
1B6A:  MOVFF  509,53E
1B6E:  MOVWF  x43
1B70:  MOVFF  01,542
1B74:  MOVLB  0
1B76:  CALL   0234
1B7A:  MOVLB  5
....................    } 
....................    gFiles[f].dirIdx = CurrentList.dirIdx; 
1B7C:  CLRF   x3F
1B7E:  MOVFF  4EB,53E
1B82:  MOVLW  02
1B84:  MOVWF  x41
1B86:  MOVLW  31
1B88:  MOVWF  x40
1B8A:  MOVLB  0
1B8C:  CALL   0370
1B90:  MOVFF  01,509
1B94:  MOVLW  2E
1B96:  MOVLB  5
1B98:  ADDWF  01,W
1B9A:  MOVWF  01
1B9C:  MOVLW  02
1B9E:  ADDWFC 02,W
1BA0:  MOVWF  03
1BA2:  MOVF   01,W
1BA4:  ADDLW  56
1BA6:  MOVWF  FE9
1BA8:  MOVLW  02
1BAA:  ADDWFC 03,W
1BAC:  MOVWF  FEA
1BAE:  MOVFF  49F,FEF
....................  
....................  
....................    u=0; 
1BB2:  MOVLB  4
1BB4:  CLRF   xFD
....................    do 
....................    { 
....................       pDir = (DIR*)(&(gFiles[f].IOpuffer[32*(int16)gFiles[f].dirIdx])); 
1BB6:  MOVLB  5
1BB8:  CLRF   x3F
1BBA:  MOVFF  4EB,53E
1BBE:  MOVLW  02
1BC0:  MOVWF  x41
1BC2:  MOVLW  31
1BC4:  MOVWF  x40
1BC6:  MOVLB  0
1BC8:  CALL   0370
1BCC:  MOVFF  02,50A
1BD0:  MOVFF  01,509
1BD4:  MOVLB  5
1BD6:  CLRF   x3F
1BD8:  MOVFF  4EB,53E
1BDC:  MOVLW  02
1BDE:  MOVWF  x41
1BE0:  MOVLW  31
1BE2:  MOVWF  x40
1BE4:  MOVLB  0
1BE6:  CALL   0370
1BEA:  MOVFF  02,50A
1BEE:  MOVFF  01,509
1BF2:  MOVLW  2E
1BF4:  MOVLB  5
1BF6:  ADDWF  01,W
1BF8:  MOVWF  01
1BFA:  MOVLW  02
1BFC:  ADDWFC 02,W
1BFE:  MOVWF  03
1C00:  MOVF   01,W
1C02:  ADDLW  56
1C04:  MOVWF  FE9
1C06:  MOVLW  02
1C08:  ADDWFC 03,W
1C0A:  MOVWF  FEA
1C0C:  MOVF   FEF,W
1C0E:  CLRF   03
1C10:  MOVWF  02
1C12:  RLCF   02,W
1C14:  MOVWF  x09
1C16:  RLCF   03,W
1C18:  MOVWF  x0A
1C1A:  RLCF   x09,F
1C1C:  RLCF   x0A,F
1C1E:  RLCF   x09,F
1C20:  RLCF   x0A,F
1C22:  RLCF   x09,F
1C24:  RLCF   x0A,F
1C26:  RLCF   x09,F
1C28:  RLCF   x0A,F
1C2A:  MOVLW  E0
1C2C:  ANDWF  x09,F
1C2E:  MOVF   x09,W
1C30:  ADDWF  x09,W
1C32:  MOVWF  01
1C34:  MOVF   x0A,W
1C36:  ADDWFC x0A,W
1C38:  MOVWF  03
1C3A:  MOVF   01,W
1C3C:  ADDLW  56
1C3E:  MOVWF  01
1C40:  MOVLW  02
1C42:  ADDWFC 03,F
1C44:  MOVFF  01,4EC
1C48:  MOVLB  4
1C4A:  MOVFF  03,4ED
....................       for (i=gFiles[f].dirIdx;i<DIRENTRYS_PER_SECTOR;i++) // loop throu all direntrys in the sector 
1C4E:  MOVLB  5
1C50:  CLRF   x3F
1C52:  MOVFF  4EB,53E
1C56:  MOVLW  02
1C58:  MOVWF  x41
1C5A:  MOVLW  31
1C5C:  MOVWF  x40
1C5E:  MOVLB  0
1C60:  CALL   0370
1C64:  MOVFF  02,50A
1C68:  MOVFF  01,509
1C6C:  MOVLW  2E
1C6E:  MOVLB  5
1C70:  ADDWF  01,W
1C72:  MOVWF  01
1C74:  MOVLW  02
1C76:  ADDWFC 02,W
1C78:  MOVWF  03
1C7A:  MOVF   01,W
1C7C:  ADDLW  56
1C7E:  MOVWF  FE9
1C80:  MOVLW  02
1C82:  ADDWFC 03,W
1C84:  MOVWF  FEA
1C86:  MOVFF  FEF,4FC
1C8A:  MOVLB  4
1C8C:  MOVF   xFC,W
1C8E:  SUBLW  0F
1C90:  BTFSS  FD8.0
1C92:  BRA    225A
....................       { 
....................          if ((pDir->sName[0] != 0xE5 && pDir->sName[0] != 0)) // if file/dir isn't deleted and isn't the end of the directory 
1C94:  MOVFF  4EC,FE9
1C98:  MOVFF  4ED,FEA
1C9C:  MOVF   FEF,W
1C9E:  SUBLW  E5
1CA0:  BTFSC  FD8.2
1CA2:  BRA    2202
1CA4:  MOVFF  4EC,FE9
1CA8:  MOVFF  4ED,FEA
1CAC:  MOVF   FEF,F
1CAE:  BTFSC  FD8.2
1CB0:  BRA    2202
....................          { 
....................             if(pDir->bAttr != 0x0F) // Normal filename (8.3) 
1CB2:  MOVLW  0B
1CB4:  ADDWF  xEC,W
1CB6:  MOVWF  FE9
1CB8:  MOVLW  00
1CBA:  ADDWFC xED,W
1CBC:  MOVWF  FEA
1CBE:  MOVF   FEF,W
1CC0:  SUBLW  0F
1CC2:  BTFSC  FD8.2
1CC4:  BRA    1FD0
....................             { 
....................                if(isLongFilename) // If this is the short version of the long filename, just save the number 
1CC6:  MOVLB  5
1CC8:  BTFSS  x00.0
1CCA:  BRA    1DF2
....................                { 
....................                   if(changeList) 
1CCC:  MOVLB  4
1CCE:  BTFSS  xA0.0
1CD0:  BRA    1D9E
....................                   { 
....................                      FileList[u].shortName = malloc(13); // 8.3 = 8chars + '.' + 3chars + 0x00 
1CD2:  MOVF   xFD,W
1CD4:  MULLW  05
1CD6:  MOVF   FF3,W
1CD8:  MOVLB  5
1CDA:  CLRF   x0A
1CDC:  MOVWF  x09
1CDE:  MOVLW  02
1CE0:  ADDWF  x09,W
1CE2:  MOVWF  01
1CE4:  MOVLW  00
1CE6:  ADDWFC x0A,W
1CE8:  MOVWF  03
1CEA:  MOVF   01,W
1CEC:  ADDLW  A1
1CEE:  MOVWF  01
1CF0:  MOVLW  04
1CF2:  ADDWFC 03,F
1CF4:  MOVFF  01,509
1CF8:  MOVFF  03,50A
1CFC:  MOVLW  0D
1CFE:  MOVWF  x0C
1D00:  MOVLB  0
1D02:  RCALL  16EE
1D04:  MOVFF  50A,FEA
1D08:  MOVFF  509,FE9
1D0C:  MOVFF  02,FEC
1D10:  MOVF   FED,F
1D12:  MOVFF  01,FEF
....................                      FileList[u].isLong = TRUE; 
1D16:  MOVLB  4
1D18:  MOVF   xFD,W
1D1A:  MULLW  05
1D1C:  MOVF   FF3,W
1D1E:  MOVLB  5
1D20:  CLRF   x0A
1D22:  MOVWF  x09
1D24:  MOVLW  04
1D26:  ADDWF  x09,W
1D28:  MOVWF  01
1D2A:  MOVLW  00
1D2C:  ADDWFC x0A,W
1D2E:  MOVWF  03
1D30:  MOVF   01,W
1D32:  ADDLW  A1
1D34:  MOVWF  FE9
1D36:  MOVLW  04
1D38:  ADDWFC 03,W
1D3A:  MOVWF  FEA
1D3C:  BSF    FEF.1
....................                      ConvertFilename(pDir,filename); 
1D3E:  MOVFF  4ED,52E
1D42:  MOVFF  4EC,52D
1D46:  MOVLW  04
1D48:  MOVWF  x30
1D4A:  MOVLW  EE
1D4C:  MOVWF  x2F
1D4E:  MOVLB  0
1D50:  CALL   07BE
....................                      strcpy(FileList[u].shortName,filename); // copy the 8.3 name of the file 
1D54:  MOVLB  4
1D56:  MOVF   xFD,W
1D58:  MULLW  05
1D5A:  MOVF   FF3,W
1D5C:  MOVLB  5
1D5E:  CLRF   x0A
1D60:  MOVWF  x09
1D62:  MOVLW  02
1D64:  ADDWF  x09,W
1D66:  MOVWF  01
1D68:  MOVLW  00
1D6A:  ADDWFC x0A,W
1D6C:  MOVWF  03
1D6E:  MOVF   01,W
1D70:  ADDLW  A1
1D72:  MOVWF  FE9
1D74:  MOVLW  04
1D76:  ADDWFC 03,W
1D78:  MOVWF  FEA
1D7A:  MOVFF  FEC,50A
1D7E:  MOVF   FED,F
1D80:  MOVFF  FEF,509
1D84:  MOVFF  50A,FEA
1D88:  MOVFF  509,FE9
1D8C:  MOVLW  04
1D8E:  MOVWF  FE2
1D90:  MOVLW  EE
1D92:  MOVWF  FE1
1D94:  MOVF   FE7,F
1D96:  MOVFF  FE6,FEE
1D9A:  BNZ   1D94
1D9C:  MOVLB  4
....................                   } 
....................                   u++; 
1D9E:  INCF   xFD,F
....................                   isLongFilename = FALSE; 
1DA0:  MOVLB  5
1DA2:  BCF    x00.0
....................                   if(u == MAX_FILE_LIST) 
1DA4:  MOVLB  4
1DA6:  MOVF   xFD,W
1DA8:  SUBLW  0A
1DAA:  BNZ   1DEE
....................                   { 
....................                      gFiles[f].dirIdx = i+1; 
1DAC:  MOVLB  5
1DAE:  CLRF   x3F
1DB0:  MOVFF  4EB,53E
1DB4:  MOVLW  02
1DB6:  MOVWF  x41
1DB8:  MOVLW  31
1DBA:  MOVWF  x40
1DBC:  MOVLB  0
1DBE:  CALL   0370
1DC2:  MOVFF  01,509
1DC6:  MOVLW  2E
1DC8:  MOVLB  5
1DCA:  ADDWF  01,W
1DCC:  MOVWF  01
1DCE:  MOVLW  02
1DD0:  ADDWFC 02,W
1DD2:  MOVWF  03
1DD4:  MOVF   01,W
1DD6:  ADDLW  56
1DD8:  MOVWF  FE9
1DDA:  MOVLW  02
1DDC:  ADDWFC 03,W
1DDE:  MOVWF  FEA
1DE0:  MOVLW  01
1DE2:  MOVLB  4
1DE4:  ADDWF  xFC,W
1DE6:  MOVWF  FEF
....................                      return u; 
1DE8:  MOVFF  4FD,01
1DEC:  BRA    2484
....................                   } 
....................                } 
....................                else // normal 8.3 filename 
1DEE:  BRA    1FCE
1DF0:  MOVLB  5
....................                { 
....................                   if(changeList) 
1DF2:  MOVLB  4
1DF4:  BTFSS  xA0.0
1DF6:  BRA    1F84
....................                   { 
....................                      ConvertFilename(pDir,filename); 
1DF8:  MOVFF  4ED,52E
1DFC:  MOVFF  4EC,52D
1E00:  MOVLW  04
1E02:  MOVLB  5
1E04:  MOVWF  x30
1E06:  MOVLW  EE
1E08:  MOVWF  x2F
1E0A:  MOVLB  0
1E0C:  CALL   07BE
....................                      FileList[u].name = malloc(strlen(filename)+1); // +1 for char 0x00 
1E10:  MOVLB  4
1E12:  MOVF   xFD,W
1E14:  MULLW  05
1E16:  MOVF   FF3,W
1E18:  MOVLB  5
1E1A:  CLRF   x0A
1E1C:  MOVWF  x09
1E1E:  MOVLW  A1
1E20:  ADDWF  x09,W
1E22:  MOVWF  01
1E24:  MOVLW  04
1E26:  ADDWFC x0A,W
1E28:  MOVWF  03
1E2A:  MOVFF  01,509
1E2E:  MOVWF  x0A
1E30:  MOVLW  04
1E32:  MOVWF  x19
1E34:  MOVLW  EE
1E36:  MOVWF  x18
1E38:  MOVLB  0
1E3A:  CALL   074E
1E3E:  MOVLW  01
1E40:  ADDWF  01,W
1E42:  MOVLB  5
1E44:  MOVWF  x0B
1E46:  MOVWF  x0C
1E48:  MOVLB  0
1E4A:  RCALL  16EE
1E4C:  MOVFF  50A,FEA
1E50:  MOVFF  509,FE9
1E54:  MOVFF  02,FEC
1E58:  MOVF   FED,F
1E5A:  MOVFF  01,FEF
....................                      strcpy(FileList[u].name,filename); 
1E5E:  MOVLB  4
1E60:  MOVF   xFD,W
1E62:  MULLW  05
1E64:  MOVF   FF3,W
1E66:  MOVLB  5
1E68:  CLRF   x0A
1E6A:  MOVWF  x09
1E6C:  MOVLW  A1
1E6E:  ADDWF  x09,W
1E70:  MOVWF  FE9
1E72:  MOVLW  04
1E74:  ADDWFC x0A,W
1E76:  MOVWF  FEA
1E78:  MOVFF  FEC,50A
1E7C:  MOVF   FED,F
1E7E:  MOVFF  FEF,509
1E82:  MOVFF  50A,FEA
1E86:  MOVFF  509,FE9
1E8A:  MOVLW  04
1E8C:  MOVWF  FE2
1E8E:  MOVLW  EE
1E90:  MOVWF  FE1
1E92:  MOVF   FE7,F
1E94:  MOVFF  FE6,FEE
1E98:  BNZ   1E92
....................                      FileList[u].shortName = FileList[u].name; // point to same string 
1E9A:  MOVLB  4
1E9C:  MOVF   xFD,W
1E9E:  MULLW  05
1EA0:  MOVF   FF3,W
1EA2:  MOVLB  5
1EA4:  CLRF   x0A
1EA6:  MOVWF  x09
1EA8:  MOVLW  02
1EAA:  ADDWF  x09,W
1EAC:  MOVWF  01
1EAE:  MOVLW  00
1EB0:  ADDWFC x0A,W
1EB2:  MOVWF  03
1EB4:  MOVF   01,W
1EB6:  ADDLW  A1
1EB8:  MOVWF  01
1EBA:  MOVLW  04
1EBC:  ADDWFC 03,F
1EBE:  MOVFF  03,50A
1EC2:  MOVLB  4
1EC4:  MOVF   xFD,W
1EC6:  MULLW  05
1EC8:  MOVF   FF3,W
1ECA:  MOVLB  5
1ECC:  CLRF   x0C
1ECE:  MOVWF  x0B
1ED0:  MOVLW  A1
1ED2:  ADDWF  x0B,W
1ED4:  MOVWF  FE9
1ED6:  MOVLW  04
1ED8:  ADDWFC x0C,W
1EDA:  MOVWF  FEA
1EDC:  MOVFF  FEC,03
1EE0:  MOVF   FED,F
1EE2:  MOVFF  FEF,50B
1EE6:  MOVFF  50A,FEA
1EEA:  MOVFF  01,FE9
1EEE:  MOVFF  03,FEC
1EF2:  MOVF   FED,F
1EF4:  MOVFF  50B,FEF
....................                      FileList[u].isLong = FALSE; 
1EF8:  MOVLB  4
1EFA:  MOVF   xFD,W
1EFC:  MULLW  05
1EFE:  MOVF   FF3,W
1F00:  MOVLB  5
1F02:  CLRF   x0A
1F04:  MOVWF  x09
1F06:  MOVLW  04
1F08:  ADDWF  x09,W
1F0A:  MOVWF  01
1F0C:  MOVLW  00
1F0E:  ADDWFC x0A,W
1F10:  MOVWF  03
1F12:  MOVF   01,W
1F14:  ADDLW  A1
1F16:  MOVWF  FE9
1F18:  MOVLW  04
1F1A:  ADDWFC 03,W
1F1C:  MOVWF  FEA
1F1E:  BCF    FEF.1
....................                      if(pDir->bAttr & 0x10) // is directory 
1F20:  MOVLW  0B
1F22:  MOVLB  4
1F24:  ADDWF  xEC,W
1F26:  MOVWF  FE9
1F28:  MOVLW  00
1F2A:  ADDWFC xED,W
1F2C:  MOVWF  FEA
1F2E:  BTFSS  FEF.4
1F30:  BRA    1F5C
....................                         FileList[u].isDir = TRUE; 
1F32:  MOVF   xFD,W
1F34:  MULLW  05
1F36:  MOVF   FF3,W
1F38:  MOVLB  5
1F3A:  CLRF   x0A
1F3C:  MOVWF  x09
1F3E:  MOVLW  04
1F40:  ADDWF  x09,W
1F42:  MOVWF  01
1F44:  MOVLW  00
1F46:  ADDWFC x0A,W
1F48:  MOVWF  03
1F4A:  MOVF   01,W
1F4C:  ADDLW  A1
1F4E:  MOVWF  FE9
1F50:  MOVLW  04
1F52:  ADDWFC 03,W
1F54:  MOVWF  FEA
1F56:  BSF    FEF.0
....................                      else 
1F58:  BRA    1F82
1F5A:  MOVLB  4
....................                         FileList[u].isDir = FALSE; 
1F5C:  MOVF   xFD,W
1F5E:  MULLW  05
1F60:  MOVF   FF3,W
1F62:  MOVLB  5
1F64:  CLRF   x0A
1F66:  MOVWF  x09
1F68:  MOVLW  04
1F6A:  ADDWF  x09,W
1F6C:  MOVWF  01
1F6E:  MOVLW  00
1F70:  ADDWFC x0A,W
1F72:  MOVWF  03
1F74:  MOVF   01,W
1F76:  ADDLW  A1
1F78:  MOVWF  FE9
1F7A:  MOVLW  04
1F7C:  ADDWFC 03,W
1F7E:  MOVWF  FEA
1F80:  BCF    FEF.0
1F82:  MOVLB  4
....................                   } 
....................  
....................                   u++; 
1F84:  INCF   xFD,F
....................                   if(u == MAX_FILE_LIST) 
1F86:  MOVF   xFD,W
1F88:  SUBLW  0A
1F8A:  BNZ   1FCE
....................                   { 
....................                      gFiles[f].dirIdx = i+1; 
1F8C:  MOVLB  5
1F8E:  CLRF   x3F
1F90:  MOVFF  4EB,53E
1F94:  MOVLW  02
1F96:  MOVWF  x41
1F98:  MOVLW  31
1F9A:  MOVWF  x40
1F9C:  MOVLB  0
1F9E:  CALL   0370
1FA2:  MOVFF  01,509
1FA6:  MOVLW  2E
1FA8:  MOVLB  5
1FAA:  ADDWF  01,W
1FAC:  MOVWF  01
1FAE:  MOVLW  02
1FB0:  ADDWFC 02,W
1FB2:  MOVWF  03
1FB4:  MOVF   01,W
1FB6:  ADDLW  56
1FB8:  MOVWF  FE9
1FBA:  MOVLW  02
1FBC:  ADDWFC 03,W
1FBE:  MOVWF  FEA
1FC0:  MOVLW  01
1FC2:  MOVLB  4
1FC4:  ADDWF  xFC,W
1FC6:  MOVWF  FEF
....................                      return u; 
1FC8:  MOVFF  4FD,01
1FCC:  BRA    2484
....................                   } 
....................                } 
....................             } 
....................             else if((pDir->bAttr & 0x0F) == 0x0F) // If it is a long filename entry 
1FCE:  BRA    2202
1FD0:  MOVLW  0B
1FD2:  ADDWF  xEC,W
1FD4:  MOVWF  FE9
1FD6:  MOVLW  00
1FD8:  ADDWFC xED,W
1FDA:  MOVWF  FEA
1FDC:  MOVF   FEF,W
1FDE:  ANDLW  0F
1FE0:  SUBLW  0F
1FE2:  BTFSS  FD8.2
1FE4:  BRA    2202
....................             { 
....................                fni = (pDir->sName[0] & 0x3F); // Filename Index 
1FE6:  MOVFF  4EC,FE9
1FEA:  MOVFF  4ED,FEA
1FEE:  MOVF   FEF,W
1FF0:  ANDLW  3F
1FF2:  MOVWF  xFE
....................                if((pDir->sName[0] & 0x40)) // First LongFilename entry, the last characters of a long filename 
1FF4:  MOVFF  4EC,FE9
1FF8:  MOVFF  4ED,FEA
1FFC:  BTFSS  FEF.6
1FFE:  BRA    216A
....................                { 
....................                   if(changeList) 
2000:  BTFSS  xA0.0
2002:  BRA    2162
....................                   { 
....................                      ConvertLongFilename(pDir,filename); 
2004:  MOVFF  4ED,50A
2008:  MOVFF  4EC,509
200C:  MOVLW  04
200E:  MOVLB  5
2010:  MOVWF  x0C
2012:  MOVLW  EE
2014:  MOVWF  x0B
2016:  MOVLB  0
2018:  RCALL  182E
....................                      len = strlen(filename)+CHARACTERS_IN_LONG_FILENAMES*(fni-1); // Length of the long filename 
201A:  MOVLW  04
201C:  MOVLB  5
201E:  MOVWF  x19
2020:  MOVLW  EE
2022:  MOVWF  x18
2024:  MOVLB  0
2026:  CALL   074E
202A:  MOVLW  01
202C:  MOVLB  4
202E:  SUBWF  xFE,W
2030:  MULLW  0D
2032:  MOVF   FF3,W
2034:  MOVLB  5
2036:  ADDWF  01,W
2038:  MOVLB  4
203A:  MOVWF  xFF
....................                      FileList[u].name = malloc(len+1);// number of chars in this strinng + 13 in each other long filname entry 
203C:  MOVF   xFD,W
203E:  MULLW  05
2040:  MOVF   FF3,W
2042:  MOVLB  5
2044:  CLRF   x0A
2046:  MOVWF  x09
2048:  MOVLW  A1
204A:  ADDWF  x09,W
204C:  MOVWF  01
204E:  MOVLW  04
2050:  ADDWFC x0A,W
2052:  MOVWF  03
2054:  MOVFF  01,509
2058:  MOVWF  x0A
205A:  MOVLW  01
205C:  MOVLB  4
205E:  ADDWF  xFF,W
2060:  MOVLB  5
2062:  MOVWF  x0B
2064:  MOVWF  x0C
2066:  MOVLB  0
2068:  CALL   16EE
206C:  MOVFF  50A,FEA
2070:  MOVFF  509,FE9
2074:  MOVFF  02,FEC
2078:  MOVF   FED,F
207A:  MOVFF  01,FEF
....................                      FileList[u].name[len] = 0x00; // set last char to 0 
207E:  MOVLB  4
2080:  MOVF   xFD,W
2082:  MULLW  05
2084:  MOVF   FF3,W
2086:  MOVLB  5
2088:  CLRF   x0A
208A:  MOVWF  x09
208C:  MOVLW  A1
208E:  ADDWF  x09,W
2090:  MOVWF  FE9
2092:  MOVLW  04
2094:  ADDWFC x0A,W
2096:  MOVWF  FEA
2098:  MOVFF  FEC,50A
209C:  MOVF   FED,F
209E:  MOVFF  FEF,509
20A2:  CLRF   03
20A4:  MOVLB  4
20A6:  MOVF   xFF,W
20A8:  MOVLB  5
20AA:  ADDWF  x09,W
20AC:  MOVWF  FE9
20AE:  MOVF   x0A,W
20B0:  ADDWFC 03,W
20B2:  MOVWF  FEA
20B4:  CLRF   FEF
....................                      strfill(FileList[u].name,filename,(fni-1)*CHARACTERS_IN_LONG_FILENAMES); //Fills the name from position (fni-1)*13 
20B6:  MOVLB  4
20B8:  MOVF   xFD,W
20BA:  MULLW  05
20BC:  MOVF   FF3,W
20BE:  MOVLB  5
20C0:  CLRF   x0A
20C2:  MOVWF  x09
20C4:  MOVLW  A1
20C6:  ADDWF  x09,W
20C8:  MOVWF  FE9
20CA:  MOVLW  04
20CC:  ADDWFC x0A,W
20CE:  MOVWF  FEA
20D0:  MOVFF  FEC,50A
20D4:  MOVF   FED,F
20D6:  MOVFF  FEF,509
20DA:  MOVLW  01
20DC:  MOVLB  4
20DE:  SUBWF  xFE,W
20E0:  MULLW  0D
20E2:  MOVFF  FF3,50B
20E6:  MOVLB  5
20E8:  MOVFF  50A,50D
20EC:  MOVFF  509,50C
20F0:  MOVLW  04
20F2:  MOVWF  x0F
20F4:  MOVLW  EE
20F6:  MOVWF  x0E
20F8:  MOVFF  50B,510
20FC:  MOVLB  0
20FE:  RCALL  192C
....................                      if(pDir->bAttr & 0x10) // is directory 
2100:  MOVLW  0B
2102:  MOVLB  4
2104:  ADDWF  xEC,W
2106:  MOVWF  FE9
2108:  MOVLW  00
210A:  ADDWFC xED,W
210C:  MOVWF  FEA
210E:  BTFSS  FEF.4
2110:  BRA    213C
....................                         FileList[u].isDir = TRUE; 
2112:  MOVF   xFD,W
2114:  MULLW  05
2116:  MOVF   FF3,W
2118:  MOVLB  5
211A:  CLRF   x0A
211C:  MOVWF  x09
211E:  MOVLW  04
2120:  ADDWF  x09,W
2122:  MOVWF  01
2124:  MOVLW  00
2126:  ADDWFC x0A,W
2128:  MOVWF  03
212A:  MOVF   01,W
212C:  ADDLW  A1
212E:  MOVWF  FE9
2130:  MOVLW  04
2132:  ADDWFC 03,W
2134:  MOVWF  FEA
2136:  BSF    FEF.0
....................                      else 
2138:  BRA    2162
213A:  MOVLB  4
....................                         FileList[u].isDir = FALSE; 
213C:  MOVF   xFD,W
213E:  MULLW  05
2140:  MOVF   FF3,W
2142:  MOVLB  5
2144:  CLRF   x0A
2146:  MOVWF  x09
2148:  MOVLW  04
214A:  ADDWF  x09,W
214C:  MOVWF  01
214E:  MOVLW  00
2150:  ADDWFC x0A,W
2152:  MOVWF  03
2154:  MOVF   01,W
2156:  ADDLW  A1
2158:  MOVWF  FE9
215A:  MOVLW  04
215C:  ADDWFC 03,W
215E:  MOVWF  FEA
2160:  BCF    FEF.0
....................                   } 
....................                   isLongFilename = TRUE; 
2162:  MOVLB  5
2164:  BSF    x00.0
....................                } 
....................                else if((pDir->sName[0] & 0x80) == 0) // If it is a long filname, but not deleted 
2166:  BRA    2200
2168:  MOVLB  4
216A:  MOVFF  4EC,FE9
216E:  MOVFF  4ED,FEA
2172:  MOVF   FEF,W
2174:  ANDLW  80
2176:  BNZ   21FE
....................                { 
....................                   if(isLongfilename && changeList) 
2178:  MOVLB  5
217A:  BTFSS  x00.0
217C:  BRA    21F0
217E:  MOVLB  4
2180:  BTFSC  xA0.0
2182:  BRA    2188
2184:  MOVLB  5
2186:  BRA    21F0
....................                   { 
....................                      ConvertLongFilename(pDir,filename); 
2188:  MOVFF  4ED,50A
218C:  MOVFF  4EC,509
2190:  MOVLW  04
2192:  MOVLB  5
2194:  MOVWF  x0C
2196:  MOVLW  EE
2198:  MOVWF  x0B
219A:  MOVLB  0
219C:  CALL   182E
....................                      strfill(FileList[u].name,filename,(fni-1)*CHARACTERS_IN_LONG_FILENAMES); //Fills the name from position (fni-1)*13 
21A0:  MOVLB  4
21A2:  MOVF   xFD,W
21A4:  MULLW  05
21A6:  MOVF   FF3,W
21A8:  MOVLB  5
21AA:  CLRF   x0A
21AC:  MOVWF  x09
21AE:  MOVLW  A1
21B0:  ADDWF  x09,W
21B2:  MOVWF  FE9
21B4:  MOVLW  04
21B6:  ADDWFC x0A,W
21B8:  MOVWF  FEA
21BA:  MOVFF  FEC,50A
21BE:  MOVF   FED,F
21C0:  MOVFF  FEF,509
21C4:  MOVLW  01
21C6:  MOVLB  4
21C8:  SUBWF  xFE,W
21CA:  MULLW  0D
21CC:  MOVFF  FF3,50B
21D0:  MOVLB  5
21D2:  MOVFF  50A,50D
21D6:  MOVFF  509,50C
21DA:  MOVLW  04
21DC:  MOVWF  x0F
21DE:  MOVLW  EE
21E0:  MOVWF  x0E
21E2:  MOVFF  50B,510
21E6:  MOVLB  0
21E8:  CALL   192C
....................                   } 
....................                   else 
21EC:  BRA    21FE
21EE:  MOVLB  5
....................                      printf("NoLongFileName!"); 
21F0:  MOVLW  1A
21F2:  MOVWF  FF6
21F4:  MOVLW  00
21F6:  MOVWF  FF7
21F8:  MOVLB  0
21FA:  CALL   0212
21FE:  MOVLB  5
2200:  MOVLB  4
....................                } 
....................             } 
....................          } 
....................          if (pDir->sName[0] == 0) 
2202:  MOVFF  4EC,FE9
2206:  MOVFF  4ED,FEA
220A:  MOVF   FEF,F
220C:  BNZ   224E
....................          { 
....................             gFiles[f].dirIdx = END_OF_DIR; 
220E:  MOVLB  5
2210:  CLRF   x3F
2212:  MOVFF  4EB,53E
2216:  MOVLW  02
2218:  MOVWF  x41
221A:  MOVLW  31
221C:  MOVWF  x40
221E:  MOVLB  0
2220:  CALL   0370
2224:  MOVFF  01,509
2228:  MOVLW  2E
222A:  MOVLB  5
222C:  ADDWF  01,W
222E:  MOVWF  01
2230:  MOVLW  02
2232:  ADDWFC 02,W
2234:  MOVWF  03
2236:  MOVF   01,W
2238:  ADDLW  56
223A:  MOVWF  FE9
223C:  MOVLW  02
223E:  ADDWFC 03,W
2240:  MOVWF  FEA
2242:  MOVLW  11
2244:  MOVWF  FEF
....................             return u; 
2246:  MOVLB  4
2248:  MOVFF  4FD,01
224C:  BRA    2484
....................          } 
....................          pDir++; 
224E:  MOVLW  20
2250:  ADDWF  xEC,F
2252:  BTFSC  FD8.0
2254:  INCF   xED,F
....................       } 
2256:  INCF   xFC,F
2258:  BRA    1C8C
....................       nextcluster = GetNextCluster(gFiles[f].CurrentCluster); 
225A:  MOVLB  5
225C:  CLRF   x3F
225E:  MOVFF  4EB,53E
2262:  MOVLW  02
2264:  MOVWF  x41
2266:  MOVLW  31
2268:  MOVWF  x40
226A:  MOVLB  0
226C:  CALL   0370
2270:  MOVFF  01,509
2274:  MOVLW  20
2276:  MOVLB  5
2278:  ADDWF  01,W
227A:  MOVWF  01
227C:  MOVLW  02
227E:  ADDWFC 02,W
2280:  MOVWF  03
2282:  MOVF   01,W
2284:  ADDLW  56
2286:  MOVWF  FE9
2288:  MOVLW  02
228A:  ADDWFC 03,W
228C:  MOVWF  FEA
228E:  MOVFF  FEF,509
2292:  MOVFF  FEC,50A
2296:  MOVFF  FEC,50B
229A:  MOVFF  FEC,50C
229E:  MOVFF  50C,534
22A2:  MOVFF  50B,533
22A6:  MOVFF  50A,532
22AA:  MOVFF  509,531
22AE:  MOVLB  0
22B0:  CALL   08F6
22B4:  MOVFF  03,504
22B8:  MOVFF  02,503
22BC:  MOVFF  01,502
22C0:  MOVFF  00,501
....................       if (nextcluster != 0x0FFFFFFF && nextcluster != 0) 
22C4:  MOVLB  5
22C6:  INCFSZ x01,W
22C8:  BRA    22DA
22CA:  INCFSZ x02,W
22CC:  BRA    22DA
22CE:  INCFSZ x03,W
22D0:  BRA    22DA
22D2:  MOVF   x04,W
22D4:  SUBLW  0F
22D6:  BTFSC  FD8.2
22D8:  BRA    2416
22DA:  MOVF   x01,F
22DC:  BNZ   22EC
22DE:  MOVF   x02,F
22E0:  BNZ   22EC
22E2:  MOVF   x03,F
22E4:  BNZ   22EC
22E6:  MOVF   x04,F
22E8:  BTFSC  FD8.2
22EA:  BRA    2416
....................       { 
....................          actsector = nextcluster + gFAT32Vars.gFirstDataSector; 
22EC:  MOVLB  2
22EE:  MOVF   x18,W
22F0:  MOVLB  5
22F2:  ADDWF  x01,W
22F4:  MOVWF  x05
22F6:  MOVLB  2
22F8:  MOVF   x19,W
22FA:  MOVLB  5
22FC:  ADDWFC x02,W
22FE:  MOVWF  x06
2300:  MOVLB  2
2302:  MOVF   x1A,W
2304:  MOVLB  5
2306:  ADDWFC x03,W
2308:  MOVWF  x07
230A:  MOVLB  2
230C:  MOVF   x1B,W
230E:  MOVLB  5
2310:  ADDWFC x04,W
2312:  MOVWF  x08
....................          ReadSector(actsector,gFiles[f].IOpuffer); 
2314:  CLRF   x3F
2316:  MOVFF  4EB,53E
231A:  MOVLW  02
231C:  MOVWF  x41
231E:  MOVLW  31
2320:  MOVWF  x40
2322:  MOVLB  0
2324:  CALL   0370
2328:  MOVFF  01,509
232C:  MOVLW  56
232E:  MOVLB  5
2330:  ADDWF  01,W
2332:  MOVWF  01
2334:  MOVLW  02
2336:  ADDWFC 02,W
2338:  MOVWF  03
233A:  MOVFF  01,509
233E:  MOVWF  x0A
2340:  MOVFF  508,541
2344:  MOVFF  507,540
2348:  MOVFF  506,53F
234C:  MOVFF  505,53E
2350:  MOVWF  x43
2352:  MOVFF  01,542
2356:  MOVLB  0
2358:  CALL   0234
....................          gFiles[f].dirSector = actsector; 
235C:  MOVLB  5
235E:  CLRF   x3F
2360:  MOVFF  4EB,53E
2364:  MOVLW  02
2366:  MOVWF  x41
2368:  MOVLW  31
236A:  MOVWF  x40
236C:  MOVLB  0
236E:  CALL   0370
2372:  MOVFF  01,509
2376:  MOVLW  2A
2378:  MOVLB  5
237A:  ADDWF  01,W
237C:  MOVWF  01
237E:  MOVLW  02
2380:  ADDWFC 02,W
2382:  MOVWF  03
2384:  MOVF   01,W
2386:  ADDLW  56
2388:  MOVWF  FE9
238A:  MOVLW  02
238C:  ADDWFC 03,W
238E:  MOVWF  FEA
2390:  MOVFF  505,FEF
2394:  MOVFF  506,FEC
2398:  MOVFF  507,FEC
239C:  MOVFF  508,FEC
....................          gFiles[f].CurrentCluster = nextcluster; 
23A0:  CLRF   x3F
23A2:  MOVFF  4EB,53E
23A6:  MOVLW  02
23A8:  MOVWF  x41
23AA:  MOVLW  31
23AC:  MOVWF  x40
23AE:  MOVLB  0
23B0:  CALL   0370
23B4:  MOVFF  01,509
23B8:  MOVLW  20
23BA:  MOVLB  5
23BC:  ADDWF  01,W
23BE:  MOVWF  01
23C0:  MOVLW  02
23C2:  ADDWFC 02,W
23C4:  MOVWF  03
23C6:  MOVF   01,W
23C8:  ADDLW  56
23CA:  MOVWF  FE9
23CC:  MOVLW  02
23CE:  ADDWFC 03,W
23D0:  MOVWF  FEA
23D2:  MOVFF  501,FEF
23D6:  MOVFF  502,FEC
23DA:  MOVFF  503,FEC
23DE:  MOVFF  504,FEC
....................          gFiles[f].dirIdx = 0; 
23E2:  CLRF   x3F
23E4:  MOVFF  4EB,53E
23E8:  MOVLW  02
23EA:  MOVWF  x41
23EC:  MOVLW  31
23EE:  MOVWF  x40
23F0:  MOVLB  0
23F2:  CALL   0370
23F6:  MOVFF  01,509
23FA:  MOVLW  2E
23FC:  MOVLB  5
23FE:  ADDWF  01,W
2400:  MOVWF  01
2402:  MOVLW  02
2404:  ADDWFC 02,W
2406:  MOVWF  03
2408:  MOVF   01,W
240A:  ADDLW  56
240C:  MOVWF  FE9
240E:  MOVLW  02
2410:  ADDWFC 03,W
2412:  MOVWF  FEA
2414:  CLRF   FEF
....................       } 
....................    } while (nextcluster != 0x0FFFFFFF && nextcluster != 0); 
2416:  INCFSZ x01,W
2418:  BRA    2428
241A:  INCFSZ x02,W
241C:  BRA    2428
241E:  INCFSZ x03,W
2420:  BRA    2428
2422:  MOVF   x04,W
2424:  SUBLW  0F
2426:  BZ    2448
2428:  MOVF   x01,F
242A:  BTFSS  FD8.2
242C:  GOTO   1BB8
2430:  MOVF   x02,F
2432:  BTFSS  FD8.2
2434:  GOTO   1BB8
2438:  MOVF   x03,F
243A:  BTFSS  FD8.2
243C:  GOTO   1BB8
2440:  MOVF   x04,F
2442:  BTFSS  FD8.2
2444:  GOTO   1BB8
....................    gFiles[f].dirIdx = END_OF_DIR; 
2448:  CLRF   x3F
244A:  MOVFF  4EB,53E
244E:  MOVLW  02
2450:  MOVWF  x41
2452:  MOVLW  31
2454:  MOVWF  x40
2456:  MOVLB  0
2458:  CALL   0370
245C:  MOVFF  01,509
2460:  MOVLW  2E
2462:  MOVLB  5
2464:  ADDWF  01,W
2466:  MOVWF  01
2468:  MOVLW  02
246A:  ADDWFC 02,W
246C:  MOVWF  03
246E:  MOVF   01,W
2470:  ADDLW  56
2472:  MOVWF  FE9
2474:  MOVLW  02
2476:  ADDWFC 03,W
2478:  MOVWF  FEA
247A:  MOVLW  11
247C:  MOVWF  FEF
....................    return u; 
247E:  MOVLB  4
2480:  MOVFF  4FD,01
.................... } 
2484:  MOVLB  0
2486:  GOTO   415C (RETURN)
....................  
.................... // Function: Go to next page in the file/dir list 
.................... // Returns : MMCResponse 
.................... MMCResponse NextPage(char f) 
.................... { 
....................    int32 nextcluster,actsector; 
....................    if (f > (MAXFILES-1)) 
*
24B0:  MOVLB  4
24B2:  MOVF   xEB,F
24B4:  BZ    24BC
....................       return MMC_INVALID_FILE; 
24B6:  MOVLW  88
24B8:  MOVWF  01
24BA:  BRA    2762
....................  
....................    CurrentList.dirSector = gFiles[f].dirSector; 
24BC:  MOVLB  5
24BE:  CLRF   x3F
24C0:  MOVFF  4EB,53E
24C4:  MOVLW  02
24C6:  MOVWF  x41
24C8:  MOVLW  31
24CA:  MOVWF  x40
24CC:  MOVLB  0
24CE:  CALL   0370
24D2:  MOVFF  02,4F5
24D6:  MOVFF  01,4F4
24DA:  MOVLW  2A
24DC:  MOVLB  4
24DE:  ADDWF  01,W
24E0:  MOVWF  01
24E2:  MOVLW  02
24E4:  ADDWFC 02,W
24E6:  MOVWF  03
24E8:  MOVF   01,W
24EA:  ADDLW  56
24EC:  MOVWF  FE9
24EE:  MOVLW  02
24F0:  ADDWFC 03,W
24F2:  MOVWF  FEA
24F4:  MOVFF  FEF,00
24F8:  MOVFF  FEC,01
24FC:  MOVFF  FEC,02
2500:  MOVFF  FEC,03
2504:  MOVFF  03,49A
2508:  MOVFF  02,499
250C:  MOVFF  01,498
2510:  MOVFF  00,497
....................    CurrentList.CurrentCluster = gFiles[f].CurrentCluster; 
2514:  MOVLB  5
2516:  CLRF   x3F
2518:  MOVFF  4EB,53E
251C:  MOVLW  02
251E:  MOVWF  x41
2520:  MOVLW  31
2522:  MOVWF  x40
2524:  MOVLB  0
2526:  CALL   0370
252A:  MOVFF  02,4F5
252E:  MOVFF  01,4F4
2532:  MOVLW  20
2534:  MOVLB  4
2536:  ADDWF  01,W
2538:  MOVWF  01
253A:  MOVLW  02
253C:  ADDWFC 02,W
253E:  MOVWF  03
2540:  MOVF   01,W
2542:  ADDLW  56
2544:  MOVWF  FE9
2546:  MOVLW  02
2548:  ADDWFC 03,W
254A:  MOVWF  FEA
254C:  MOVFF  FEF,00
2550:  MOVFF  FEC,01
2554:  MOVFF  FEC,02
2558:  MOVFF  FEC,03
255C:  MOVFF  03,49E
2560:  MOVFF  02,49D
2564:  MOVFF  01,49C
2568:  MOVFF  00,49B
....................  
....................    if(gFiles[f].dirIdx == DIRENTRYS_PER_SECTOR) 
256C:  MOVLB  5
256E:  CLRF   x3F
2570:  MOVFF  4EB,53E
2574:  MOVLW  02
2576:  MOVWF  x41
2578:  MOVLW  31
257A:  MOVWF  x40
257C:  MOVLB  0
257E:  CALL   0370
2582:  MOVFF  02,4F5
2586:  MOVFF  01,4F4
258A:  MOVLW  2E
258C:  MOVLB  4
258E:  ADDWF  01,W
2590:  MOVWF  01
2592:  MOVLW  02
2594:  ADDWFC 02,W
2596:  MOVWF  03
2598:  MOVF   01,W
259A:  ADDLW  56
259C:  MOVWF  FE9
259E:  MOVLW  02
25A0:  ADDWFC 03,W
25A2:  MOVWF  FEA
25A4:  MOVF   FEF,W
25A6:  SUBLW  10
25A8:  BTFSS  FD8.2
25AA:  BRA    26E0
....................    { 
....................       nextcluster = GetNextCluster(gFiles[f].CurrentCluster); 
25AC:  MOVLB  5
25AE:  CLRF   x3F
25B0:  MOVFF  4EB,53E
25B4:  MOVLW  02
25B6:  MOVWF  x41
25B8:  MOVLW  31
25BA:  MOVWF  x40
25BC:  MOVLB  0
25BE:  CALL   0370
25C2:  MOVFF  01,4F4
25C6:  MOVLW  20
25C8:  MOVLB  4
25CA:  ADDWF  01,W
25CC:  MOVWF  01
25CE:  MOVLW  02
25D0:  ADDWFC 02,W
25D2:  MOVWF  03
25D4:  MOVF   01,W
25D6:  ADDLW  56
25D8:  MOVWF  FE9
25DA:  MOVLW  02
25DC:  ADDWFC 03,W
25DE:  MOVWF  FEA
25E0:  MOVFF  FEF,4F4
25E4:  MOVFF  FEC,4F5
25E8:  MOVFF  FEC,4F6
25EC:  MOVFF  FEC,4F7
25F0:  MOVFF  4F7,534
25F4:  MOVFF  4F6,533
25F8:  MOVFF  4F5,532
25FC:  MOVFF  4F4,531
2600:  MOVLB  0
2602:  CALL   08F6
2606:  MOVFF  03,4EF
260A:  MOVFF  02,4EE
260E:  MOVFF  01,4ED
2612:  MOVFF  00,4EC
....................        if (nextcluster != 0x0FFFFFFF && nextcluster != 0) 
2616:  MOVLB  4
2618:  INCFSZ xEC,W
261A:  BRA    262A
261C:  INCFSZ xED,W
261E:  BRA    262A
2620:  INCFSZ xEE,W
2622:  BRA    262A
2624:  MOVF   xEF,W
2626:  SUBLW  0F
2628:  BZ    26D8
262A:  MOVF   xEC,F
262C:  BNZ   263A
262E:  MOVF   xED,F
2630:  BNZ   263A
2632:  MOVF   xEE,F
2634:  BNZ   263A
2636:  MOVF   xEF,F
2638:  BZ    26D8
....................       { 
....................          actsector = nextcluster + gFAT32Vars.gFirstDataSector; 
263A:  MOVLB  2
263C:  MOVF   x18,W
263E:  MOVLB  4
2640:  ADDWF  xEC,W
2642:  MOVWF  xF0
2644:  MOVLB  2
2646:  MOVF   x19,W
2648:  MOVLB  4
264A:  ADDWFC xED,W
264C:  MOVWF  xF1
264E:  MOVLB  2
2650:  MOVF   x1A,W
2652:  MOVLB  4
2654:  ADDWFC xEE,W
2656:  MOVWF  xF2
2658:  MOVLB  2
265A:  MOVF   x1B,W
265C:  MOVLB  4
265E:  ADDWFC xEF,W
2660:  MOVWF  xF3
....................          ReadSector(actsector,gFiles[f].IOpuffer); 
2662:  MOVLB  5
2664:  CLRF   x3F
2666:  MOVFF  4EB,53E
266A:  MOVLW  02
266C:  MOVWF  x41
266E:  MOVLW  31
2670:  MOVWF  x40
2672:  MOVLB  0
2674:  CALL   0370
2678:  MOVFF  01,4F4
267C:  MOVLW  56
267E:  MOVLB  4
2680:  ADDWF  01,W
2682:  MOVWF  01
2684:  MOVLW  02
2686:  ADDWFC 02,W
2688:  MOVWF  03
268A:  MOVFF  01,4F4
268E:  MOVWF  xF5
2690:  MOVFF  4F3,541
2694:  MOVFF  4F2,540
2698:  MOVFF  4F1,53F
269C:  MOVFF  4F0,53E
26A0:  MOVFF  FE8,543
26A4:  MOVFF  01,542
26A8:  MOVLB  0
26AA:  CALL   0234
....................  
....................          CurrentList.dirSector = actsector; 
26AE:  MOVFF  4F3,49A
26B2:  MOVFF  4F2,499
26B6:  MOVFF  4F1,498
26BA:  MOVFF  4F0,497
....................          CurrentList.CurrentCluster = nextcluster; 
26BE:  MOVFF  4EF,49E
26C2:  MOVFF  4EE,49D
26C6:  MOVFF  4ED,49C
26CA:  MOVFF  4EC,49B
....................          CurrentList.dirIdx = 0; 
26CE:  MOVLB  4
26D0:  CLRF   x9F
....................          return MMC_OK; 
26D2:  MOVLW  00
26D4:  MOVWF  01
26D6:  BRA    2762
....................        } 
....................       return MMC_INVALID_CLUSTER; 
26D8:  MOVLW  B8
26DA:  MOVWF  01
26DC:  BRA    2762
....................    } 
....................    else if(gFiles[f].dirIdx == END_OF_DIR) 
26DE:  BRA    275E
26E0:  MOVLB  5
26E2:  CLRF   x3F
26E4:  MOVFF  4EB,53E
26E8:  MOVLW  02
26EA:  MOVWF  x41
26EC:  MOVLW  31
26EE:  MOVWF  x40
26F0:  MOVLB  0
26F2:  CALL   0370
26F6:  MOVFF  02,4F5
26FA:  MOVFF  01,4F4
26FE:  MOVLW  2E
2700:  MOVLB  4
2702:  ADDWF  01,W
2704:  MOVWF  01
2706:  MOVLW  02
2708:  ADDWFC 02,W
270A:  MOVWF  03
270C:  MOVF   01,W
270E:  ADDLW  56
2710:  MOVWF  FE9
2712:  MOVLW  02
2714:  ADDWFC 03,W
2716:  MOVWF  FEA
2718:  MOVF   FEF,W
271A:  SUBLW  11
271C:  BNZ   2726
....................    { 
....................       return MMC_END_OF_DIR; // Last file/dir have already been listed by ListFiles 
271E:  MOVLW  C0
2720:  MOVWF  01
2722:  BRA    2762
....................    } 
....................    else 
2724:  BRA    275E
....................    { 
....................       CurrentList.dirIdx = gFiles[f].dirIdx; 
2726:  MOVLB  5
2728:  CLRF   x3F
272A:  MOVFF  4EB,53E
272E:  MOVLW  02
2730:  MOVWF  x41
2732:  MOVLW  31
2734:  MOVWF  x40
2736:  MOVLB  0
2738:  CALL   0370
273C:  MOVFF  01,4F4
2740:  MOVLW  2E
2742:  MOVLB  4
2744:  ADDWF  01,W
2746:  MOVWF  01
2748:  MOVLW  02
274A:  ADDWFC 02,W
274C:  MOVWF  03
274E:  MOVF   01,W
2750:  ADDLW  56
2752:  MOVWF  FE9
2754:  MOVLW  02
2756:  ADDWFC 03,W
2758:  MOVWF  FEA
275A:  MOVFF  FEF,49F
....................    } 
....................    return MMC_OK; 
275E:  MOVLW  00
2760:  MOVWF  01
.................... } 
2762:  MOVLB  0
2764:  GOTO   41F8 (RETURN)
....................  
.................... // Note: 0 = first page 
.................... MMCResponse SetPage(char f, int32 page) 
.................... { 
....................    int32 i; 
....................    MMCResponse res; 
....................    if (f > (MAXFILES-1)) 
....................       return MMC_INVALID_FILE; 
....................  
....................    CurrentList.dirSector = StartList.dirSector; 
....................    CurrentList.CurrentCluster = StartList.CurrentCluster; 
....................    CurrentList.dirIdx = StartList.dirIdx; // should always be 0 
....................  
....................    changeList = FALSE; // this tells the ListFiles function to not change the list, just loop through files 
....................    for(i=0;i<page;i++) 
....................    { 
....................       ListFiles(f); 
....................       res = NextPage(f); 
....................       if(res != MMC_OK) 
....................       { 
....................          changeList = TRUE; 
....................          return res; 
....................       } 
....................    } 
....................    changeList = TRUE; 
....................    return MMC_OK; 
.................... } 
....................  
.................... MMCResponse CloseList(char f) 
.................... { 
....................    if (f > (MAXFILES-1)) 
2768:  MOVLB  4
276A:  MOVF   xEB,F
276C:  BZ    2774
....................       return MMC_INVALID_FILE; 
276E:  MOVLW  88
2770:  MOVWF  01
2772:  BRA    27AE
....................    gFiles[f].Free = TRUE; 
2774:  MOVLB  5
2776:  CLRF   x3F
2778:  MOVFF  4EB,53E
277C:  MOVLW  02
277E:  MOVWF  x41
2780:  MOVLW  31
2782:  MOVWF  x40
2784:  MOVLB  0
2786:  CALL   0370
278A:  MOVFF  01,4EC
278E:  MOVLW  30
2790:  MOVLB  4
2792:  ADDWF  01,W
2794:  MOVWF  01
2796:  MOVLW  02
2798:  ADDWFC 02,W
279A:  MOVWF  03
279C:  MOVF   01,W
279E:  ADDLW  56
27A0:  MOVWF  FE9
27A2:  MOVLW  02
27A4:  ADDWFC 03,W
27A6:  MOVWF  FEA
27A8:  BSF    FEF.0
....................    return MMC_OK; 
27AA:  MOVLW  00
27AC:  MOVWF  01
.................... } 
27AE:  MOVLB  0
27B0:  GOTO   420A (RETURN)
....................  
.................... void FreeList() 
.................... { 
....................    int i; 
....................    for(i=0;i<MAX_FILE_LIST;i++) 
*
155E:  MOVLB  5
1560:  CLRF   x09
1562:  MOVF   x09,W
1564:  SUBLW  09
1566:  BNC   1626
....................    { 
....................       if(FileList[i].isLong)           // If it is a long filename, name and short name are different string 
1568:  MOVF   x09,W
156A:  MULLW  05
156C:  MOVF   FF3,W
156E:  CLRF   x0B
1570:  MOVWF  x0A
1572:  MOVLW  04
1574:  ADDWF  x0A,W
1576:  MOVWF  01
1578:  MOVLW  00
157A:  ADDWFC x0B,W
157C:  MOVWF  03
157E:  MOVF   01,W
1580:  ADDLW  A1
1582:  MOVWF  FE9
1584:  MOVLW  04
1586:  ADDWFC 03,W
1588:  MOVWF  FEA
158A:  BTFSS  FEF.1
158C:  BRA    15CA
....................          free(FileList[i].shortName); // then free both 
158E:  MOVF   x09,W
1590:  MULLW  05
1592:  MOVF   FF3,W
1594:  CLRF   x0B
1596:  MOVWF  x0A
1598:  MOVLW  02
159A:  ADDWF  x0A,W
159C:  MOVWF  01
159E:  MOVLW  00
15A0:  ADDWFC x0B,W
15A2:  MOVWF  03
15A4:  MOVF   01,W
15A6:  ADDLW  A1
15A8:  MOVWF  FE9
15AA:  MOVLW  04
15AC:  ADDWFC 03,W
15AE:  MOVWF  FEA
15B0:  MOVFF  FEC,50B
15B4:  MOVF   FED,F
15B6:  MOVFF  FEF,50A
15BA:  MOVFF  50B,50D
15BE:  MOVFF  50A,50C
15C2:  MOVLB  0
15C4:  RCALL  14E4
....................       else 
15C6:  BRA    15F2
15C8:  MOVLB  5
....................          FileList[i].shortName = NULL; 
15CA:  MOVF   x09,W
15CC:  MULLW  05
15CE:  MOVF   FF3,W
15D0:  CLRF   x0B
15D2:  MOVWF  x0A
15D4:  MOVLW  02
15D6:  ADDWF  x0A,W
15D8:  MOVWF  01
15DA:  MOVLW  00
15DC:  ADDWFC x0B,W
15DE:  MOVWF  03
15E0:  MOVF   01,W
15E2:  ADDLW  A1
15E4:  MOVWF  FE9
15E6:  MOVLW  04
15E8:  ADDWFC 03,W
15EA:  MOVWF  FEA
15EC:  CLRF   FEC
15EE:  MOVF   FED,F
15F0:  CLRF   FEF
....................       free(FileList[i].name);          // else free ONLY name(they point to same string..) 
15F2:  MOVLB  5
15F4:  MOVF   x09,W
15F6:  MULLW  05
15F8:  MOVF   FF3,W
15FA:  CLRF   x0B
15FC:  MOVWF  x0A
15FE:  MOVLW  A1
1600:  ADDWF  x0A,W
1602:  MOVWF  FE9
1604:  MOVLW  04
1606:  ADDWFC x0B,W
1608:  MOVWF  FEA
160A:  MOVFF  FEC,50B
160E:  MOVF   FED,F
1610:  MOVFF  FEF,50A
1614:  MOVFF  50B,50D
1618:  MOVFF  50A,50C
161C:  MOVLB  0
161E:  RCALL  14E4
....................    } 
1620:  MOVLB  5
1622:  INCF   x09,F
1624:  BRA    1562
.................... } 
1626:  MOVLB  0
1628:  GOTO   1994 (RETURN)
.................... #endif// ENABLE_FILELISTNG 
....................  
.................... // Function: Creates a file 
.................... MMCResponse fcreate(char f,char *fname) 
.................... { 
....................    DIR *pDir; 
....................    int32 actsector,actcl; 
....................    int16 i; 
....................  
....................    if (f > (MAXFILES-1)) 
*
2DBA:  MOVLB  4
2DBC:  MOVF   xFE,F
2DBE:  BZ    2DC6
....................    { 
....................       return MMC_INVALID_FILE; 
2DC0:  MOVLW  88
2DC2:  MOVWF  01
2DC4:  BRA    3252
....................    } 
....................    if (gFAT32Vars.gFirstDirEntryCluster == 0x0FFFFFFF) 
2DC6:  MOVLB  2
2DC8:  INCFSZ x22,W
2DCA:  BRA    2F34
2DCC:  INCFSZ x23,W
2DCE:  BRA    2F34
2DD0:  INCFSZ x24,W
2DD2:  BRA    2F34
2DD4:  MOVF   x25,W
2DD6:  SUBLW  0F
2DD8:  BTFSS  FD8.2
2DDA:  BRA    2F34
....................    { 
....................       // extend the directory file !!! 
....................       gFAT32Vars.gFirstDirEntryCluster = FindFirstFreeCluster(); 
2DDC:  MOVLB  0
2DDE:  RCALL  27B4
2DE0:  MOVFF  03,225
2DE4:  MOVFF  02,224
2DE8:  MOVFF  01,223
2DEC:  MOVFF  00,222
....................       gFAT32Vars.gFirstEmptyDirEntry = 0; 
2DF0:  MOVLB  2
2DF2:  CLRF   x21
....................       SetClusterEntry(gFiles[f].CurrentCluster,gFAT32Vars.gFirstDirEntryCluster); 
2DF4:  MOVLB  5
2DF6:  CLRF   x3F
2DF8:  MOVFF  4FE,53E
2DFC:  MOVLW  02
2DFE:  MOVWF  x41
2E00:  MOVLW  31
2E02:  MOVWF  x40
2E04:  MOVLB  0
2E06:  CALL   0370
2E0A:  MOVFF  01,50D
2E0E:  MOVLW  20
2E10:  MOVLB  5
2E12:  ADDWF  01,W
2E14:  MOVWF  01
2E16:  MOVLW  02
2E18:  ADDWFC 02,W
2E1A:  MOVWF  03
2E1C:  MOVF   01,W
2E1E:  ADDLW  56
2E20:  MOVWF  FE9
2E22:  MOVLW  02
2E24:  ADDWFC 03,W
2E26:  MOVWF  FEA
2E28:  MOVFF  FEF,50D
2E2C:  MOVFF  FEC,50E
2E30:  MOVFF  FEC,50F
2E34:  MOVFF  FEC,510
2E38:  MOVFF  510,516
2E3C:  MOVFF  50F,515
2E40:  MOVFF  50E,514
2E44:  MOVFF  50D,513
2E48:  MOVFF  225,51A
2E4C:  MOVFF  224,519
2E50:  MOVFF  223,518
2E54:  MOVFF  222,517
2E58:  MOVLB  0
2E5A:  RCALL  2AB2
....................       SetClusterEntry(gFAT32Vars.gFirstDirEntryCluster,0x0FFFFFFF); 
2E5C:  MOVFF  225,516
2E60:  MOVFF  224,515
2E64:  MOVFF  223,514
2E68:  MOVFF  222,513
2E6C:  MOVLW  0F
2E6E:  MOVLB  5
2E70:  MOVWF  x1A
2E72:  MOVLW  FF
2E74:  MOVWF  x19
2E76:  MOVWF  x18
2E78:  MOVWF  x17
2E7A:  MOVLB  0
2E7C:  RCALL  2AB2
....................       actsector = gFAT32Vars.gFirstDirEntryCluster + gFAT32Vars.gFirstDataSector; 
2E7E:  MOVLB  2
2E80:  MOVF   x18,W
2E82:  ADDWF  x22,W
2E84:  MOVLB  5
2E86:  MOVWF  x03
2E88:  MOVLB  2
2E8A:  MOVF   x19,W
2E8C:  ADDWFC x23,W
2E8E:  MOVLB  5
2E90:  MOVWF  x04
2E92:  MOVLB  2
2E94:  MOVF   x1A,W
2E96:  ADDWFC x24,W
2E98:  MOVLB  5
2E9A:  MOVWF  x05
2E9C:  MOVLB  2
2E9E:  MOVF   x1B,W
2EA0:  ADDWFC x25,W
2EA2:  MOVLB  5
2EA4:  MOVWF  x06
....................       for (i=0;i<512;i++) 
2EA6:  CLRF   x0C
2EA8:  CLRF   x0B
2EAA:  MOVF   x0C,W
2EAC:  SUBLW  01
2EAE:  BNC   2EEC
....................          gFiles[f].IOpuffer[i] = 0; 
2EB0:  CLRF   x3F
2EB2:  MOVFF  4FE,53E
2EB6:  MOVLW  02
2EB8:  MOVWF  x41
2EBA:  MOVLW  31
2EBC:  MOVWF  x40
2EBE:  MOVLB  0
2EC0:  CALL   0370
2EC4:  MOVFF  01,50D
2EC8:  MOVLB  5
2ECA:  MOVF   x0B,W
2ECC:  ADDWF  01,W
2ECE:  MOVWF  01
2ED0:  MOVF   x0C,W
2ED2:  ADDWFC 02,W
2ED4:  MOVWF  03
2ED6:  MOVF   01,W
2ED8:  ADDLW  56
2EDA:  MOVWF  FE9
2EDC:  MOVLW  02
2EDE:  ADDWFC 03,W
2EE0:  MOVWF  FEA
2EE2:  CLRF   FEF
2EE4:  INCF   x0B,F
2EE6:  BTFSC  FD8.2
2EE8:  INCF   x0C,F
2EEA:  BRA    2EAA
....................       WriteSector(actsector,gFiles[f].IOpuffer); 
2EEC:  CLRF   x3F
2EEE:  MOVFF  4FE,53E
2EF2:  MOVLW  02
2EF4:  MOVWF  x41
2EF6:  MOVLW  31
2EF8:  MOVWF  x40
2EFA:  MOVLB  0
2EFC:  CALL   0370
2F00:  MOVFF  01,50D
2F04:  MOVLW  56
2F06:  MOVLB  5
2F08:  ADDWF  01,W
2F0A:  MOVWF  01
2F0C:  MOVLW  02
2F0E:  ADDWFC 02,W
2F10:  MOVWF  03
2F12:  MOVFF  01,50D
2F16:  MOVWF  x0E
2F18:  MOVFF  506,527
2F1C:  MOVFF  505,526
2F20:  MOVFF  504,525
2F24:  MOVFF  503,524
2F28:  MOVWF  x29
2F2A:  MOVFF  01,528
2F2E:  MOVLB  0
2F30:  RCALL  298A
2F32:  MOVLB  2
....................    } 
....................    actsector = gFAT32Vars.gFirstDirEntryCluster + gFAT32Vars.gFirstDataSector; 
2F34:  MOVF   x18,W
2F36:  ADDWF  x22,W
2F38:  MOVLB  5
2F3A:  MOVWF  x03
2F3C:  MOVLB  2
2F3E:  MOVF   x19,W
2F40:  ADDWFC x23,W
2F42:  MOVLB  5
2F44:  MOVWF  x04
2F46:  MOVLB  2
2F48:  MOVF   x1A,W
2F4A:  ADDWFC x24,W
2F4C:  MOVLB  5
2F4E:  MOVWF  x05
2F50:  MOVLB  2
2F52:  MOVF   x1B,W
2F54:  ADDWFC x25,W
2F56:  MOVLB  5
2F58:  MOVWF  x06
....................    ReadSector(actsector,gFiles[f].IOpuffer); 
2F5A:  CLRF   x3F
2F5C:  MOVFF  4FE,53E
2F60:  MOVLW  02
2F62:  MOVWF  x41
2F64:  MOVLW  31
2F66:  MOVWF  x40
2F68:  MOVLB  0
2F6A:  CALL   0370
2F6E:  MOVFF  01,50D
2F72:  MOVLW  56
2F74:  MOVLB  5
2F76:  ADDWF  01,W
2F78:  MOVWF  01
2F7A:  MOVLW  02
2F7C:  ADDWFC 02,W
2F7E:  MOVWF  03
2F80:  MOVFF  01,50D
2F84:  MOVWF  x0E
2F86:  MOVFF  506,541
2F8A:  MOVFF  505,540
2F8E:  MOVFF  504,53F
2F92:  MOVFF  503,53E
2F96:  MOVWF  x43
2F98:  MOVFF  01,542
2F9C:  MOVLB  0
2F9E:  CALL   0234
....................    pDir = (DIR*)(&(gFiles[f].IOpuffer[32*(int16)gFAT32Vars.gFirstEmptyDirEntry])); 
2FA2:  MOVLB  5
2FA4:  CLRF   x3F
2FA6:  MOVFF  4FE,53E
2FAA:  MOVLW  02
2FAC:  MOVWF  x41
2FAE:  MOVLW  31
2FB0:  MOVWF  x40
2FB2:  MOVLB  0
2FB4:  CALL   0370
2FB8:  MOVFF  02,50E
2FBC:  CLRF   03
2FBE:  MOVLB  2
2FC0:  RLCF   x21,W
2FC2:  MOVLB  5
2FC4:  MOVWF  x0D
2FC6:  RLCF   03,W
2FC8:  MOVWF  x0E
2FCA:  RLCF   x0D,F
2FCC:  RLCF   x0E,F
2FCE:  RLCF   x0D,F
2FD0:  RLCF   x0E,F
2FD2:  RLCF   x0D,F
2FD4:  RLCF   x0E,F
2FD6:  RLCF   x0D,F
2FD8:  RLCF   x0E,F
2FDA:  MOVLW  E0
2FDC:  ANDWF  x0D,F
2FDE:  MOVF   x0D,W
2FE0:  ADDWF  x0D,W
2FE2:  MOVWF  01
2FE4:  MOVF   x0E,W
2FE6:  ADDWFC x0E,W
2FE8:  MOVWF  03
2FEA:  MOVF   01,W
2FEC:  ADDLW  56
2FEE:  MOVWF  01
2FF0:  MOVLW  02
2FF2:  ADDWFC 03,F
2FF4:  MOVFF  01,501
2FF8:  MOVFF  03,502
....................    gFiles[f].dirSector = actsector; 
2FFC:  CLRF   x3F
2FFE:  MOVFF  4FE,53E
3002:  MOVLW  02
3004:  MOVWF  x41
3006:  MOVLW  31
3008:  MOVWF  x40
300A:  MOVLB  0
300C:  CALL   0370
3010:  MOVFF  01,50D
3014:  MOVLW  2A
3016:  MOVLB  5
3018:  ADDWF  01,W
301A:  MOVWF  01
301C:  MOVLW  02
301E:  ADDWFC 02,W
3020:  MOVWF  03
3022:  MOVF   01,W
3024:  ADDLW  56
3026:  MOVWF  FE9
3028:  MOVLW  02
302A:  ADDWFC 03,W
302C:  MOVWF  FEA
302E:  MOVFF  503,FEF
3032:  MOVFF  504,FEC
3036:  MOVFF  505,FEC
303A:  MOVFF  506,FEC
....................    gFiles[f].dirIdx = gFAT32Vars.gFirstEmptyDirEntry; 
303E:  CLRF   x3F
3040:  MOVFF  4FE,53E
3044:  MOVLW  02
3046:  MOVWF  x41
3048:  MOVLW  31
304A:  MOVWF  x40
304C:  MOVLB  0
304E:  CALL   0370
3052:  MOVFF  01,50D
3056:  MOVLW  2E
3058:  MOVLB  5
305A:  ADDWF  01,W
305C:  MOVWF  01
305E:  MOVLW  02
3060:  ADDWFC 02,W
3062:  MOVWF  03
3064:  MOVF   01,W
3066:  ADDLW  56
3068:  MOVWF  FE9
306A:  MOVLW  02
306C:  ADDWFC 03,W
306E:  MOVWF  FEA
3070:  MOVFF  221,FEF
....................    GetDOSName(pDir,fname); 
3074:  MOVFF  502,510
3078:  MOVFF  501,50F
307C:  MOVFF  500,512
3080:  MOVFF  4FF,511
3084:  MOVLB  0
3086:  BRA    2C1A
....................    pDir->bAttr = 0; 
3088:  MOVLW  0B
308A:  MOVLB  5
308C:  ADDWF  x01,W
308E:  MOVWF  FE9
3090:  MOVLW  00
3092:  ADDWFC x02,W
3094:  MOVWF  FEA
3096:  CLRF   FEF
....................    actcl = FindFirstFreeCluster(); 
3098:  MOVLB  0
309A:  CALL   27B4
309E:  MOVFF  03,50A
30A2:  MOVFF  02,509
30A6:  MOVFF  01,508
30AA:  MOVFF  00,507
....................    pDir->hCluster = actcl & 0xFFFF; 
30AE:  MOVLW  1A
30B0:  MOVLB  5
30B2:  ADDWF  x01,W
30B4:  MOVWF  FE9
30B6:  MOVLW  00
30B8:  ADDWFC x02,W
30BA:  MOVWF  FEA
30BC:  MOVFF  507,FEF
30C0:  MOVFF  508,FEC
....................    pDir->hClusterH = actcl >> 16; 
30C4:  MOVLW  14
30C6:  ADDWF  x01,W
30C8:  MOVWF  FE9
30CA:  MOVLW  00
30CC:  ADDWFC x02,W
30CE:  MOVWF  FEA
30D0:  MOVFF  509,FEF
30D4:  MOVFF  50A,FEC
....................    SetClusterEntry(actcl,0x0FFFFFFF); 
30D8:  MOVFF  50A,516
30DC:  MOVFF  509,515
30E0:  MOVFF  508,514
30E4:  MOVFF  507,513
30E8:  MOVLW  0F
30EA:  MOVWF  x1A
30EC:  MOVLW  FF
30EE:  MOVWF  x19
30F0:  MOVWF  x18
30F2:  MOVWF  x17
30F4:  MOVLB  0
30F6:  RCALL  2AB2
....................    pDir->wSize = 0; 
30F8:  MOVLW  1C
30FA:  MOVLB  5
30FC:  ADDWF  x01,W
30FE:  MOVWF  FE9
3100:  MOVLW  00
3102:  ADDWFC x02,W
3104:  MOVWF  FEA
3106:  MOVF   FEE,F
3108:  MOVF   FEE,F
310A:  CLRF   FEC
310C:  MOVF   FED,F
310E:  CLRF   FEF
3110:  MOVF   FED,F
3112:  CLRF   FEF
3114:  MOVF   FED,F
3116:  CLRF   FEF
....................    gFiles[f].position = 0; 
3118:  CLRF   x3F
311A:  MOVFF  4FE,53E
311E:  MOVLW  02
3120:  MOVWF  x41
3122:  MOVLW  31
3124:  MOVWF  x40
3126:  MOVLB  0
3128:  CALL   0370
312C:  MOVFF  01,50D
3130:  MOVLW  26
3132:  MOVLB  5
3134:  ADDWF  01,W
3136:  MOVWF  01
3138:  MOVLW  02
313A:  ADDWFC 02,W
313C:  MOVWF  03
313E:  MOVF   01,W
3140:  ADDLW  56
3142:  MOVWF  FE9
3144:  MOVLW  02
3146:  ADDWFC 03,W
3148:  MOVWF  FEA
314A:  MOVF   FEE,F
314C:  MOVF   FEE,F
314E:  CLRF   FEC
3150:  MOVF   FED,F
3152:  CLRF   FEF
3154:  MOVF   FED,F
3156:  CLRF   FEF
3158:  MOVF   FED,F
315A:  CLRF   FEF
....................    pDir->hDate = GetCurrentDOSDate(); 
315C:  MOVLW  18
315E:  ADDWF  x01,W
3160:  MOVWF  01
3162:  MOVLW  00
3164:  ADDWFC x02,W
3166:  MOVWF  03
3168:  MOVFF  01,50D
316C:  MOVWF  x0E
316E:  MOVLB  0
3170:  RCALL  2CF6
3172:  MOVFF  50E,FEA
3176:  MOVFF  50D,FE9
317A:  MOVFF  02,FEC
317E:  MOVF   FED,F
3180:  MOVFF  01,FEF
....................    pDir->hTime = GetCurrentDOSTime(); 
3184:  MOVLW  16
3186:  MOVLB  5
3188:  ADDWF  x01,W
318A:  MOVWF  01
318C:  MOVLW  00
318E:  ADDWFC x02,W
3190:  MOVWF  03
3192:  MOVFF  01,50D
3196:  MOVWF  x0E
3198:  MOVLB  0
319A:  RCALL  2D58
319C:  MOVFF  50E,FEA
31A0:  MOVFF  50D,FE9
31A4:  MOVFF  02,FEC
31A8:  MOVF   FED,F
31AA:  MOVFF  01,FEF
....................    WriteSector(actsector,gFiles[f].IOpuffer); 
31AE:  MOVLB  5
31B0:  CLRF   x3F
31B2:  MOVFF  4FE,53E
31B6:  MOVLW  02
31B8:  MOVWF  x41
31BA:  MOVLW  31
31BC:  MOVWF  x40
31BE:  MOVLB  0
31C0:  CALL   0370
31C4:  MOVFF  01,50D
31C8:  MOVLW  56
31CA:  MOVLB  5
31CC:  ADDWF  01,W
31CE:  MOVWF  01
31D0:  MOVLW  02
31D2:  ADDWFC 02,W
31D4:  MOVWF  03
31D6:  MOVFF  01,50D
31DA:  MOVWF  x0E
31DC:  MOVFF  506,527
31E0:  MOVFF  505,526
31E4:  MOVFF  504,525
31E8:  MOVFF  503,524
31EC:  MOVWF  x29
31EE:  MOVFF  01,528
31F2:  MOVLB  0
31F4:  CALL   298A
....................    memcpy(&(gFiles[f].DirEntry),pDir,32); 
31F8:  MOVLB  5
31FA:  CLRF   x3F
31FC:  MOVFF  4FE,53E
3200:  MOVLW  02
3202:  MOVWF  x41
3204:  MOVLW  31
3206:  MOVWF  x40
3208:  MOVLB  0
320A:  CALL   0370
320E:  MOVFF  01,50D
3212:  MOVLB  5
3214:  MOVFF  01,01
3218:  MOVLW  02
321A:  ADDWF  02,W
321C:  MOVWF  03
321E:  MOVF   01,W
3220:  ADDLW  56
3222:  MOVWF  01
3224:  MOVLW  02
3226:  ADDWFC 03,F
3228:  MOVFF  01,50D
322C:  MOVFF  03,50E
3230:  MOVFF  03,FEA
3234:  MOVFF  01,FE9
3238:  MOVFF  502,FE2
323C:  MOVFF  501,FE1
3240:  MOVLW  20
3242:  MOVWF  01
3244:  MOVFF  FE6,FEE
3248:  DECFSZ 01,F
324A:  BRA    3244
....................    return MMC_OK; 
324C:  MOVLW  00
324E:  MOVWF  01
3250:  MOVLB  4
.................... } 
3252:  MOVLB  0
3254:  GOTO   32FA (RETURN)
....................  
.................... int32 ComposeCluster(char f) 
.................... { 
....................    int32 retval; 
....................  
....................    retval = gFiles[f].DirEntry.hClusterH; 
*
0D8C:  MOVLB  5
0D8E:  CLRF   x3F
0D90:  MOVFF  510,53E
0D94:  MOVLW  02
0D96:  MOVWF  x41
0D98:  MOVLW  31
0D9A:  MOVWF  x40
0D9C:  MOVLB  0
0D9E:  CALL   0370
0DA2:  MOVFF  02,516
0DA6:  MOVFF  01,515
0DAA:  MOVLW  02
0DAC:  MOVLB  5
0DAE:  ADDWF  x16,F
0DB0:  MOVLW  14
0DB2:  ADDWF  01,W
0DB4:  MOVWF  01
0DB6:  MOVLW  00
0DB8:  ADDWFC x16,W
0DBA:  MOVWF  03
0DBC:  MOVF   01,W
0DBE:  ADDLW  56
0DC0:  MOVWF  FE9
0DC2:  MOVLW  02
0DC4:  ADDWFC 03,W
0DC6:  MOVWF  FEA
0DC8:  MOVFF  FEC,03
0DCC:  MOVF   FED,F
0DCE:  MOVFF  FEF,00
0DD2:  MOVFF  03,01
0DD6:  CLRF   02
0DD8:  CLRF   03
0DDA:  MOVFF  03,514
0DDE:  MOVFF  02,513
0DE2:  MOVFF  01,512
0DE6:  MOVFF  00,511
....................    retval <<= 16; 
0DEA:  MOVFF  512,514
0DEE:  MOVFF  511,513
0DF2:  CLRF   x11
0DF4:  CLRF   x12
....................    retval |= gFiles[f].DirEntry.hCluster; 
0DF6:  CLRF   x3F
0DF8:  MOVFF  510,53E
0DFC:  MOVLW  02
0DFE:  MOVWF  x41
0E00:  MOVLW  31
0E02:  MOVWF  x40
0E04:  MOVLB  0
0E06:  CALL   0370
0E0A:  MOVFF  02,516
0E0E:  MOVFF  01,515
0E12:  MOVLW  02
0E14:  MOVLB  5
0E16:  ADDWF  x16,F
0E18:  MOVLW  1A
0E1A:  ADDWF  01,W
0E1C:  MOVWF  01
0E1E:  MOVLW  00
0E20:  ADDWFC x16,W
0E22:  MOVWF  03
0E24:  MOVF   01,W
0E26:  ADDLW  56
0E28:  MOVWF  FE9
0E2A:  MOVLW  02
0E2C:  ADDWFC 03,W
0E2E:  MOVWF  FEA
0E30:  MOVFF  FEC,03
0E34:  MOVF   FED,F
0E36:  MOVF   FEF,W
0E38:  IORWF  x11,F
0E3A:  MOVF   03,W
0E3C:  IORWF  x12,F
....................    return retval; 
0E3E:  MOVFF  511,00
0E42:  MOVFF  512,01
0E46:  MOVFF  513,02
0E4A:  MOVFF  514,03
.................... } 
0E4E:  MOVLB  0
0E50:  RETLW  00
....................  
.................... // Function: Opens a file with the specified mode 
.................... // Returns : A file handle or error code 
.................... MMCResponse fopen(char *fname, char mode) 
.................... { 
....................    char found; 
....................    char f; 
....................    int32 actsector,actcluster,nextcluster; 
....................    char *filename; 
....................  
....................    if (!CardInserted()) 
....................       return MMC_NO_CARD_INSERTED; 
....................  
....................    filename = TryFile(fname,&f); 
*
3258:  MOVFF  4EC,4FF
325C:  MOVFF  4EB,4FE
3260:  MOVLW  04
3262:  MOVLB  5
3264:  MOVWF  x01
3266:  MOVLW  EF
3268:  MOVWF  x00
326A:  MOVLB  0
326C:  CALL   0FCA
3270:  MOVFF  02,4FD
3274:  MOVFF  01,4FC
....................    if (filename == 0) 
3278:  MOVLB  4
327A:  MOVF   xFC,F
327C:  BNZ   3288
327E:  MOVF   xFD,F
3280:  BNZ   3288
....................    { 
....................       return MMC_NOT_FOUND; // probebly invalid directory 
3282:  MOVLW  B0
3284:  MOVWF  01
3286:  BRA    3858
....................    } 
....................    found = FALSE; 
3288:  CLRF   xEE
....................    found = FindDirEntry(filename,f); 
328A:  MOVFF  4FD,50F
328E:  MOVFF  4FC,50E
3292:  MOVFF  4EF,510
3296:  MOVLB  0
3298:  CALL   0A08
329C:  MOVFF  01,4EE
....................  
....................    if (!found) 
32A0:  MOVLB  4
32A2:  MOVF   xEE,F
32A4:  BNZ   330C
....................    { 
....................       if (mode == 'r') 
32A6:  MOVF   xED,W
32A8:  SUBLW  72
32AA:  BNZ   32EA
....................       { 
....................          gFiles[f].Free = TRUE; 
32AC:  MOVLB  5
32AE:  CLRF   x3F
32B0:  MOVFF  4EF,53E
32B4:  MOVLW  02
32B6:  MOVWF  x41
32B8:  MOVLW  31
32BA:  MOVWF  x40
32BC:  MOVLB  0
32BE:  CALL   0370
32C2:  MOVFF  01,4FE
32C6:  MOVLW  30
32C8:  MOVLB  4
32CA:  ADDWF  01,W
32CC:  MOVWF  01
32CE:  MOVLW  02
32D0:  ADDWFC 02,W
32D2:  MOVWF  03
32D4:  MOVF   01,W
32D6:  ADDLW  56
32D8:  MOVWF  FE9
32DA:  MOVLW  02
32DC:  ADDWFC 03,W
32DE:  MOVWF  FEA
32E0:  BSF    FEF.0
....................          return MMC_NOT_FOUND; 
32E2:  MOVLW  B0
32E4:  MOVWF  01
32E6:  BRA    3858
....................       } 
....................       else 
32E8:  BRA    330C
....................       { 
....................          if (fcreate(f,filename) != MMC_OK) 
32EA:  MOVFF  4EF,4FE
32EE:  MOVFF  4FD,500
32F2:  MOVFF  4FC,4FF
32F6:  MOVLB  0
32F8:  BRA    2DBA
32FA:  MOVF   01,F
32FC:  BZ    3306
....................             return MMC_NOT_FOUND; 
32FE:  MOVLW  B0
3300:  MOVWF  01
3302:  MOVLB  4
3304:  BRA    3858
....................          found = TRUE; 
3306:  MOVLW  01
3308:  MOVLB  4
330A:  MOVWF  xEE
....................       } 
....................    } 
....................    if (found) 
330C:  MOVF   xEE,F
330E:  BTFSC  FD8.2
3310:  BRA    3854
....................    { 
....................       gFiles[f].Free = FALSE; 
3312:  MOVLB  5
3314:  CLRF   x3F
3316:  MOVFF  4EF,53E
331A:  MOVLW  02
331C:  MOVWF  x41
331E:  MOVLW  31
3320:  MOVWF  x40
3322:  MOVLB  0
3324:  CALL   0370
3328:  MOVFF  01,4FE
332C:  MOVLW  30
332E:  MOVLB  4
3330:  ADDWF  01,W
3332:  MOVWF  01
3334:  MOVLW  02
3336:  ADDWFC 02,W
3338:  MOVWF  03
333A:  MOVF   01,W
333C:  ADDLW  56
333E:  MOVWF  FE9
3340:  MOVLW  02
3342:  ADDWFC 03,W
3344:  MOVWF  FEA
3346:  BCF    FEF.0
....................       gFiles[f].mode = mode; 
3348:  MOVLB  5
334A:  CLRF   x3F
334C:  MOVFF  4EF,53E
3350:  MOVLW  02
3352:  MOVWF  x41
3354:  MOVLW  31
3356:  MOVWF  x40
3358:  MOVLB  0
335A:  CALL   0370
335E:  MOVFF  01,4FE
3362:  MOVLW  2F
3364:  MOVLB  4
3366:  ADDWF  01,W
3368:  MOVWF  01
336A:  MOVLW  02
336C:  ADDWFC 02,W
336E:  MOVWF  03
3370:  MOVF   01,W
3372:  ADDLW  56
3374:  MOVWF  FE9
3376:  MOVLW  02
3378:  ADDWFC 03,W
337A:  MOVWF  FEA
337C:  MOVFF  4ED,FEF
....................       if  (mode == 'a') 
3380:  MOVF   xED,W
3382:  SUBLW  61
3384:  BTFSS  FD8.2
3386:  BRA    36F2
....................       { 
....................          gFiles[f].position = gFiles[f].DirEntry.wSize; 
3388:  MOVLB  5
338A:  CLRF   x3F
338C:  MOVFF  4EF,53E
3390:  MOVLW  02
3392:  MOVWF  x41
3394:  MOVLW  31
3396:  MOVWF  x40
3398:  MOVLB  0
339A:  CALL   0370
339E:  MOVFF  01,4FE
33A2:  MOVLW  26
33A4:  MOVLB  4
33A6:  ADDWF  01,W
33A8:  MOVWF  01
33AA:  MOVLW  02
33AC:  ADDWFC 02,W
33AE:  MOVWF  03
33B0:  MOVF   01,W
33B2:  ADDLW  56
33B4:  MOVWF  01
33B6:  MOVLW  02
33B8:  ADDWFC 03,F
33BA:  MOVFF  01,4FE
33BE:  MOVFF  03,4FF
33C2:  MOVLB  5
33C4:  CLRF   x3F
33C6:  MOVFF  4EF,53E
33CA:  MOVLW  02
33CC:  MOVWF  x41
33CE:  MOVLW  31
33D0:  MOVWF  x40
33D2:  MOVLB  0
33D4:  CALL   0370
33D8:  MOVFF  02,501
33DC:  MOVFF  01,500
33E0:  MOVLW  02
33E2:  MOVLB  5
33E4:  ADDWF  x01,F
33E6:  MOVLW  1C
33E8:  ADDWF  01,W
33EA:  MOVWF  01
33EC:  MOVLW  00
33EE:  ADDWFC x01,W
33F0:  MOVWF  03
33F2:  MOVF   01,W
33F4:  ADDLW  56
33F6:  MOVWF  FE9
33F8:  MOVLW  02
33FA:  ADDWFC 03,W
33FC:  MOVWF  FEA
33FE:  MOVFF  FEF,00
3402:  MOVFF  FEC,01
3406:  MOVFF  FEC,02
340A:  MOVFF  FEC,03
340E:  MOVFF  4FF,FEA
3412:  MOVFF  4FE,FE9
3416:  MOVFF  00,FEF
341A:  MOVFF  01,FEC
341E:  MOVFF  02,FEC
3422:  MOVFF  03,FEC
....................          actcluster = ComposeCluster(f); 
3426:  MOVFF  4EF,510
342A:  MOVLB  0
342C:  CALL   0D8C
3430:  MOVFF  03,4F7
3434:  MOVFF  02,4F6
3438:  MOVFF  01,4F5
343C:  MOVFF  00,4F4
....................          while (actcluster != 0x0FFFFFFF && nextcluster != 0) 
....................          { 
3440:  MOVLB  4
3442:  INCFSZ xF4,W
3444:  BRA    3454
3446:  INCFSZ xF5,W
3448:  BRA    3454
344A:  INCFSZ xF6,W
344C:  BRA    3454
344E:  MOVF   xF7,W
3450:  SUBLW  0F
3452:  BZ    34C2
3454:  MOVF   xF8,F
3456:  BNZ   3464
3458:  MOVF   xF9,F
345A:  BNZ   3464
345C:  MOVF   xFA,F
345E:  BNZ   3464
3460:  MOVF   xFB,F
3462:  BZ    34C2
....................             nextcluster = GetNextCluster(actcluster); 
3464:  MOVFF  4F7,534
3468:  MOVFF  4F6,533
346C:  MOVFF  4F5,532
3470:  MOVFF  4F4,531
3474:  MOVLB  0
3476:  CALL   08F6
347A:  MOVFF  03,4FB
347E:  MOVFF  02,4FA
3482:  MOVFF  01,4F9
3486:  MOVFF  00,4F8
....................             if (nextcluster == 0x0FFFFFFF || nextcluster == 0) 
348A:  MOVLB  4
348C:  INCFSZ xF8,W
348E:  BRA    349E
3490:  INCFSZ xF9,W
3492:  BRA    349E
3494:  INCFSZ xFA,W
3496:  BRA    349E
3498:  MOVF   xFB,W
349A:  SUBLW  0F
349C:  BZ    34AE
349E:  MOVF   xF8,F
34A0:  BNZ   34B0
34A2:  MOVF   xF9,F
34A4:  BNZ   34B0
34A6:  MOVF   xFA,F
34A8:  BNZ   34B0
34AA:  MOVF   xFB,F
34AC:  BNZ   34B0
....................                break; 
34AE:  BRA    34C2
....................             actcluster = nextcluster; 
34B0:  MOVFF  4FB,4F7
34B4:  MOVFF  4FA,4F6
34B8:  MOVFF  4F9,4F5
34BC:  MOVFF  4F8,4F4
....................          } 
34C0:  BRA    3442
....................          actsector = actcluster + gFAT32Vars.gFirstDataSector; 
34C2:  MOVLB  2
34C4:  MOVF   x18,W
34C6:  MOVLB  4
34C8:  ADDWF  xF4,W
34CA:  MOVWF  xF0
34CC:  MOVLB  2
34CE:  MOVF   x19,W
34D0:  MOVLB  4
34D2:  ADDWFC xF5,W
34D4:  MOVWF  xF1
34D6:  MOVLB  2
34D8:  MOVF   x1A,W
34DA:  MOVLB  4
34DC:  ADDWFC xF6,W
34DE:  MOVWF  xF2
34E0:  MOVLB  2
34E2:  MOVF   x1B,W
34E4:  MOVLB  4
34E6:  ADDWFC xF7,W
34E8:  MOVWF  xF3
....................          ReadSector(actsector,gFiles[f].IOpuffer); 
34EA:  MOVLB  5
34EC:  CLRF   x3F
34EE:  MOVFF  4EF,53E
34F2:  MOVLW  02
34F4:  MOVWF  x41
34F6:  MOVLW  31
34F8:  MOVWF  x40
34FA:  MOVLB  0
34FC:  CALL   0370
3500:  MOVFF  01,4FE
3504:  MOVLW  56
3506:  MOVLB  4
3508:  ADDWF  01,W
350A:  MOVWF  01
350C:  MOVLW  02
350E:  ADDWFC 02,W
3510:  MOVWF  03
3512:  MOVFF  01,4FE
3516:  MOVWF  xFF
3518:  MOVFF  4F3,541
351C:  MOVFF  4F2,540
3520:  MOVFF  4F1,53F
3524:  MOVFF  4F0,53E
3528:  MOVFF  FE8,543
352C:  MOVFF  01,542
3530:  MOVLB  0
3532:  CALL   0234
....................          gFiles[f].CurrentCluster = actcluster; 
3536:  MOVLB  5
3538:  CLRF   x3F
353A:  MOVFF  4EF,53E
353E:  MOVLW  02
3540:  MOVWF  x41
3542:  MOVLW  31
3544:  MOVWF  x40
3546:  MOVLB  0
3548:  CALL   0370
354C:  MOVFF  01,4FE
3550:  MOVLW  20
3552:  MOVLB  4
3554:  ADDWF  01,W
3556:  MOVWF  01
3558:  MOVLW  02
355A:  ADDWFC 02,W
355C:  MOVWF  03
355E:  MOVF   01,W
3560:  ADDLW  56
3562:  MOVWF  FE9
3564:  MOVLW  02
3566:  ADDWFC 03,W
3568:  MOVWF  FEA
356A:  MOVFF  4F4,FEF
356E:  MOVFF  4F5,FEC
3572:  MOVFF  4F6,FEC
3576:  MOVFF  4F7,FEC
....................          gFiles[f].posinsector = gFiles[f].position & 0x01FF; 
357A:  MOVLB  5
357C:  CLRF   x3F
357E:  MOVFF  4EF,53E
3582:  MOVLW  02
3584:  MOVWF  x41
3586:  MOVLW  31
3588:  MOVWF  x40
358A:  MOVLB  0
358C:  CALL   0370
3590:  MOVFF  01,4FE
3594:  MOVLW  24
3596:  MOVLB  4
3598:  ADDWF  01,W
359A:  MOVWF  01
359C:  MOVLW  02
359E:  ADDWFC 02,W
35A0:  MOVWF  03
35A2:  MOVF   01,W
35A4:  ADDLW  56
35A6:  MOVWF  01
35A8:  MOVLW  02
35AA:  ADDWFC 03,F
35AC:  MOVFF  01,4FE
35B0:  MOVFF  03,4FF
35B4:  MOVLB  5
35B6:  CLRF   x3F
35B8:  MOVFF  4EF,53E
35BC:  MOVLW  02
35BE:  MOVWF  x41
35C0:  MOVLW  31
35C2:  MOVWF  x40
35C4:  MOVLB  0
35C6:  CALL   0370
35CA:  MOVFF  01,500
35CE:  MOVLW  26
35D0:  MOVLB  5
35D2:  ADDWF  01,W
35D4:  MOVWF  01
35D6:  MOVLW  02
35D8:  ADDWFC 02,W
35DA:  MOVWF  03
35DC:  MOVF   01,W
35DE:  ADDLW  56
35E0:  MOVWF  FE9
35E2:  MOVLW  02
35E4:  ADDWFC 03,W
35E6:  MOVWF  FEA
35E8:  MOVFF  FEF,500
35EC:  MOVFF  FEC,501
35F0:  MOVFF  FEC,502
35F4:  MOVFF  FEC,503
35F8:  MOVFF  500,00
35FC:  MOVF   x01,W
35FE:  ANDLW  01
3600:  MOVFF  4FF,FEA
3604:  MOVFF  4FE,FE9
3608:  MOVFF  500,FEF
360C:  MOVWF  FEC
....................          if (gFiles[f].posinsector == 0 && gFiles[f].position != 0) 
360E:  CLRF   x3F
3610:  MOVFF  4EF,53E
3614:  MOVLW  02
3616:  MOVWF  x41
3618:  MOVLW  31
361A:  MOVWF  x40
361C:  MOVLB  0
361E:  CALL   0370
3622:  MOVFF  01,4FE
3626:  MOVLW  24
3628:  MOVLB  4
362A:  ADDWF  01,W
362C:  MOVWF  01
362E:  MOVLW  02
3630:  ADDWFC 02,W
3632:  MOVWF  03
3634:  MOVF   01,W
3636:  ADDLW  56
3638:  MOVWF  FE9
363A:  MOVLW  02
363C:  ADDWFC 03,W
363E:  MOVWF  FEA
3640:  MOVFF  FEC,4FF
3644:  MOVF   FED,F
3646:  MOVFF  FEF,4FE
364A:  MOVF   xFE,F
364C:  BNZ   36F0
364E:  MOVF   xFF,F
3650:  BNZ   36F0
3652:  MOVLB  5
3654:  CLRF   x3F
3656:  MOVFF  4EF,53E
365A:  MOVLW  02
365C:  MOVWF  x41
365E:  MOVLW  31
3660:  MOVWF  x40
3662:  MOVLB  0
3664:  CALL   0370
3668:  MOVFF  01,4FE
366C:  MOVLW  26
366E:  MOVLB  4
3670:  ADDWF  01,W
3672:  MOVWF  01
3674:  MOVLW  02
3676:  ADDWFC 02,W
3678:  MOVWF  03
367A:  MOVF   01,W
367C:  ADDLW  56
367E:  MOVWF  FE9
3680:  MOVLW  02
3682:  ADDWFC 03,W
3684:  MOVWF  FEA
3686:  MOVFF  FEF,4FE
368A:  MOVFF  FEC,4FF
368E:  MOVFF  FEC,500
3692:  MOVFF  FEC,501
3696:  MOVF   xFE,F
3698:  BNZ   36B4
369A:  MOVF   xFF,F
369C:  BNZ   36B4
369E:  MOVLB  5
36A0:  MOVF   x00,F
36A2:  BTFSC  FD8.2
36A4:  BRA    36AA
36A6:  MOVLB  4
36A8:  BRA    36B4
36AA:  MOVF   x01,F
36AC:  BTFSS  FD8.2
36AE:  BRA    36B4
36B0:  MOVLB  4
36B2:  BRA    36F0
....................             gFiles[f].posinsector = 512; 
36B4:  MOVLB  5
36B6:  CLRF   x3F
36B8:  MOVFF  4EF,53E
36BC:  MOVLW  02
36BE:  MOVWF  x41
36C0:  MOVLW  31
36C2:  MOVWF  x40
36C4:  MOVLB  0
36C6:  CALL   0370
36CA:  MOVFF  01,4FE
36CE:  MOVLW  24
36D0:  MOVLB  4
36D2:  ADDWF  01,W
36D4:  MOVWF  01
36D6:  MOVLW  02
36D8:  ADDWFC 02,W
36DA:  MOVWF  03
36DC:  MOVF   01,W
36DE:  ADDLW  56
36E0:  MOVWF  FE9
36E2:  MOVLW  02
36E4:  ADDWFC 03,W
36E6:  MOVWF  FEA
36E8:  MOVLW  02
36EA:  MOVWF  FEC
36EC:  MOVF   FED,F
36EE:  CLRF   FEF
....................       } 
....................       else 
36F0:  BRA    3854
....................       { 
....................          gFiles[f].position = 0; 
36F2:  MOVLB  5
36F4:  CLRF   x3F
36F6:  MOVFF  4EF,53E
36FA:  MOVLW  02
36FC:  MOVWF  x41
36FE:  MOVLW  31
3700:  MOVWF  x40
3702:  MOVLB  0
3704:  CALL   0370
3708:  MOVFF  01,4FE
370C:  MOVLW  26
370E:  MOVLB  4
3710:  ADDWF  01,W
3712:  MOVWF  01
3714:  MOVLW  02
3716:  ADDWFC 02,W
3718:  MOVWF  03
371A:  MOVF   01,W
371C:  ADDLW  56
371E:  MOVWF  FE9
3720:  MOVLW  02
3722:  ADDWFC 03,W
3724:  MOVWF  FEA
3726:  MOVF   FEE,F
3728:  MOVF   FEE,F
372A:  CLRF   FEC
372C:  MOVF   FED,F
372E:  CLRF   FEF
3730:  MOVF   FED,F
3732:  CLRF   FEF
3734:  MOVF   FED,F
3736:  CLRF   FEF
....................          actsector = ComposeCluster(f); 
3738:  MOVFF  4EF,510
373C:  MOVLB  0
373E:  CALL   0D8C
3742:  MOVFF  03,4F3
3746:  MOVFF  02,4F2
374A:  MOVFF  01,4F1
374E:  MOVFF  00,4F0
....................          actsector += gFAT32Vars.gFirstDataSector; 
3752:  MOVLB  2
3754:  MOVF   x18,W
3756:  MOVLB  4
3758:  ADDWF  xF0,F
375A:  MOVLB  2
375C:  MOVF   x19,W
375E:  MOVLB  4
3760:  ADDWFC xF1,F
3762:  MOVLB  2
3764:  MOVF   x1A,W
3766:  MOVLB  4
3768:  ADDWFC xF2,F
376A:  MOVLB  2
376C:  MOVF   x1B,W
376E:  MOVLB  4
3770:  ADDWFC xF3,F
....................          ReadSector(actsector,gFiles[f].IOpuffer); 
3772:  MOVLB  5
3774:  CLRF   x3F
3776:  MOVFF  4EF,53E
377A:  MOVLW  02
377C:  MOVWF  x41
377E:  MOVLW  31
3780:  MOVWF  x40
3782:  MOVLB  0
3784:  CALL   0370
3788:  MOVFF  01,4FE
378C:  MOVLW  56
378E:  MOVLB  4
3790:  ADDWF  01,W
3792:  MOVWF  01
3794:  MOVLW  02
3796:  ADDWFC 02,W
3798:  MOVWF  03
379A:  MOVFF  01,4FE
379E:  MOVWF  xFF
37A0:  MOVFF  4F3,541
37A4:  MOVFF  4F2,540
37A8:  MOVFF  4F1,53F
37AC:  MOVFF  4F0,53E
37B0:  MOVFF  FE8,543
37B4:  MOVFF  01,542
37B8:  MOVLB  0
37BA:  CALL   0234
....................          gFiles[f].CurrentCluster = ComposeCluster(f); 
37BE:  MOVLB  5
37C0:  CLRF   x3F
37C2:  MOVFF  4EF,53E
37C6:  MOVLW  02
37C8:  MOVWF  x41
37CA:  MOVLW  31
37CC:  MOVWF  x40
37CE:  MOVLB  0
37D0:  CALL   0370
37D4:  MOVFF  01,4FE
37D8:  MOVLW  20
37DA:  MOVLB  4
37DC:  ADDWF  01,W
37DE:  MOVWF  01
37E0:  MOVLW  02
37E2:  ADDWFC 02,W
37E4:  MOVWF  03
37E6:  MOVF   01,W
37E8:  ADDLW  56
37EA:  MOVWF  01
37EC:  MOVLW  02
37EE:  ADDWFC 03,F
37F0:  MOVFF  01,4FE
37F4:  MOVFF  03,4FF
37F8:  MOVFF  4EF,510
37FC:  MOVLB  0
37FE:  CALL   0D8C
3802:  MOVFF  4FF,FEA
3806:  MOVFF  4FE,FE9
380A:  MOVFF  00,FEF
380E:  MOVFF  01,FEC
3812:  MOVFF  02,FEC
3816:  MOVFF  03,FEC
....................          gFiles[f].posinsector = 0; 
381A:  MOVLB  5
381C:  CLRF   x3F
381E:  MOVFF  4EF,53E
3822:  MOVLW  02
3824:  MOVWF  x41
3826:  MOVLW  31
3828:  MOVWF  x40
382A:  MOVLB  0
382C:  CALL   0370
3830:  MOVFF  01,4FE
3834:  MOVLW  24
3836:  MOVLB  4
3838:  ADDWF  01,W
383A:  MOVWF  01
383C:  MOVLW  02
383E:  ADDWFC 02,W
3840:  MOVWF  03
3842:  MOVF   01,W
3844:  ADDLW  56
3846:  MOVWF  FE9
3848:  MOVLW  02
384A:  ADDWFC 03,W
384C:  MOVWF  FEA
384E:  CLRF   FEC
3850:  MOVF   FED,F
3852:  CLRF   FEF
....................       } 
....................    } 
....................    return f; 
3854:  MOVFF  4EF,01
.................... } 
3858:  MOVLB  0
385A:  GOTO   4236 (RETURN)
....................  
.................... // Function: closes a open file and makes it avavible for a new file 
.................... MMCResponse fclose(char f) 
.................... { 
....................    if (f > (MAXFILES-1)) 
*
3FDE:  MOVLB  4
3FE0:  MOVF   xEB,F
3FE2:  BZ    3FEA
....................       return MMC_INVALID_FILE; 
3FE4:  MOVLW  88
3FE6:  MOVWF  01
3FE8:  BRA    40A8
....................    if ((gFiles[f].mode == 'a') || (gFiles[f].mode == 'w')) 
3FEA:  MOVLB  5
3FEC:  CLRF   x3F
3FEE:  MOVFF  4EB,53E
3FF2:  MOVLW  02
3FF4:  MOVWF  x41
3FF6:  MOVLW  31
3FF8:  MOVWF  x40
3FFA:  MOVLB  0
3FFC:  CALL   0370
4000:  MOVFF  02,4ED
4004:  MOVFF  01,4EC
4008:  MOVLW  2F
400A:  MOVLB  4
400C:  ADDWF  01,W
400E:  MOVWF  01
4010:  MOVLW  02
4012:  ADDWFC 02,W
4014:  MOVWF  03
4016:  MOVF   01,W
4018:  ADDLW  56
401A:  MOVWF  FE9
401C:  MOVLW  02
401E:  ADDWFC 03,W
4020:  MOVWF  FEA
4022:  MOVF   FEF,W
4024:  SUBLW  61
4026:  BZ    4066
4028:  MOVLB  5
402A:  CLRF   x3F
402C:  MOVFF  4EB,53E
4030:  MOVLW  02
4032:  MOVWF  x41
4034:  MOVLW  31
4036:  MOVWF  x40
4038:  MOVLB  0
403A:  CALL   0370
403E:  MOVFF  02,4ED
4042:  MOVFF  01,4EC
4046:  MOVLW  2F
4048:  MOVLB  4
404A:  ADDWF  01,W
404C:  MOVWF  01
404E:  MOVLW  02
4050:  ADDWFC 02,W
4052:  MOVWF  03
4054:  MOVF   01,W
4056:  ADDLW  56
4058:  MOVWF  FE9
405A:  MOVLW  02
405C:  ADDWFC 03,W
405E:  MOVWF  FEA
4060:  MOVF   FEF,W
4062:  SUBLW  77
4064:  BNZ   406E
....................       fflush(f); 
4066:  MOVFF  4EB,4EC
406A:  MOVLB  0
406C:  BRA    3C06
....................    gFiles[f].Free = TRUE; 
406E:  MOVLB  5
4070:  CLRF   x3F
4072:  MOVFF  4EB,53E
4076:  MOVLW  02
4078:  MOVWF  x41
407A:  MOVLW  31
407C:  MOVWF  x40
407E:  MOVLB  0
4080:  CALL   0370
4084:  MOVFF  01,4EC
4088:  MOVLW  30
408A:  MOVLB  4
408C:  ADDWF  01,W
408E:  MOVWF  01
4090:  MOVLW  02
4092:  ADDWFC 02,W
4094:  MOVWF  03
4096:  MOVF   01,W
4098:  ADDLW  56
409A:  MOVWF  FE9
409C:  MOVLW  02
409E:  ADDWFC 03,W
40A0:  MOVWF  FEA
40A2:  BSF    FEF.0
....................    return MMC_OK; 
40A4:  MOVLW  00
40A6:  MOVWF  01
.................... } 
40A8:  MOVLB  0
40AA:  GOTO   426E (RETURN)
....................  
.................... // Function: writes the chach to the MMC 
.................... MMCResponse fflush(char f) 
.................... { 
....................    int32 actsector; 
....................    DIR *pDir; 
....................  
....................    if (f > (MAXFILES-1)) 
*
3C06:  MOVLB  4
3C08:  MOVF   xEC,F
3C0A:  BZ    3C12
....................       return MMC_INVALID_FILE; 
3C0C:  MOVLW  88
3C0E:  MOVWF  01
3C10:  BRA    3FD8
....................    actsector = gFiles[f].CurrentCluster + gFAT32Vars.gFirstDataSector; 
3C12:  MOVLB  5
3C14:  CLRF   x3F
3C16:  MOVFF  4EC,53E
3C1A:  MOVLW  02
3C1C:  MOVWF  x41
3C1E:  MOVLW  31
3C20:  MOVWF  x40
3C22:  MOVLB  0
3C24:  CALL   0370
3C28:  MOVFF  01,4F3
3C2C:  MOVLW  20
3C2E:  MOVLB  4
3C30:  ADDWF  01,W
3C32:  MOVWF  01
3C34:  MOVLW  02
3C36:  ADDWFC 02,W
3C38:  MOVWF  03
3C3A:  MOVF   01,W
3C3C:  ADDLW  56
3C3E:  MOVWF  FE9
3C40:  MOVLW  02
3C42:  ADDWFC 03,W
3C44:  MOVWF  FEA
3C46:  MOVFF  FEF,4F3
3C4A:  MOVFF  FEC,4F4
3C4E:  MOVFF  FEC,4F5
3C52:  MOVFF  FEC,4F6
3C56:  MOVLB  2
3C58:  MOVF   x18,W
3C5A:  MOVLB  4
3C5C:  ADDWF  xF3,W
3C5E:  MOVWF  xED
3C60:  MOVLB  2
3C62:  MOVF   x19,W
3C64:  MOVLB  4
3C66:  ADDWFC xF4,W
3C68:  MOVWF  xEE
3C6A:  MOVLB  2
3C6C:  MOVF   x1A,W
3C6E:  MOVLB  4
3C70:  ADDWFC xF5,W
3C72:  MOVWF  xEF
3C74:  MOVLB  2
3C76:  MOVF   x1B,W
3C78:  MOVLB  4
3C7A:  ADDWFC xF6,W
3C7C:  MOVWF  xF0
....................    WriteSector(actsector,gFiles[f].IOpuffer); 
3C7E:  MOVLB  5
3C80:  CLRF   x3F
3C82:  MOVFF  4EC,53E
3C86:  MOVLW  02
3C88:  MOVWF  x41
3C8A:  MOVLW  31
3C8C:  MOVWF  x40
3C8E:  MOVLB  0
3C90:  CALL   0370
3C94:  MOVFF  01,4F3
3C98:  MOVLW  56
3C9A:  MOVLB  4
3C9C:  ADDWF  01,W
3C9E:  MOVWF  01
3CA0:  MOVLW  02
3CA2:  ADDWFC 02,W
3CA4:  MOVWF  03
3CA6:  MOVFF  01,4F3
3CAA:  MOVWF  xF4
3CAC:  MOVFF  4F0,527
3CB0:  MOVFF  4EF,526
3CB4:  MOVFF  4EE,525
3CB8:  MOVFF  4ED,524
3CBC:  MOVFF  FE8,529
3CC0:  MOVFF  01,528
3CC4:  MOVLB  0
3CC6:  CALL   298A
....................    ReadSector(gFiles[f].dirSector,gFiles[f].IOpuffer); 
3CCA:  MOVLB  5
3CCC:  CLRF   x3F
3CCE:  MOVFF  4EC,53E
3CD2:  MOVLW  02
3CD4:  MOVWF  x41
3CD6:  MOVLW  31
3CD8:  MOVWF  x40
3CDA:  MOVLB  0
3CDC:  CALL   0370
3CE0:  MOVFF  01,4F3
3CE4:  MOVLW  2A
3CE6:  MOVLB  4
3CE8:  ADDWF  01,W
3CEA:  MOVWF  01
3CEC:  MOVLW  02
3CEE:  ADDWFC 02,W
3CF0:  MOVWF  03
3CF2:  MOVF   01,W
3CF4:  ADDLW  56
3CF6:  MOVWF  FE9
3CF8:  MOVLW  02
3CFA:  ADDWFC 03,W
3CFC:  MOVWF  FEA
3CFE:  MOVFF  FEF,4F3
3D02:  MOVFF  FEC,4F4
3D06:  MOVFF  FEC,4F5
3D0A:  MOVFF  FEC,4F6
3D0E:  MOVLB  5
3D10:  CLRF   x3F
3D12:  MOVFF  4EC,53E
3D16:  MOVLW  02
3D18:  MOVWF  x41
3D1A:  MOVLW  31
3D1C:  MOVWF  x40
3D1E:  MOVLB  0
3D20:  CALL   0370
3D24:  MOVFF  01,4F7
3D28:  MOVLW  56
3D2A:  MOVLB  4
3D2C:  ADDWF  01,W
3D2E:  MOVWF  01
3D30:  MOVLW  02
3D32:  ADDWFC 02,W
3D34:  MOVWF  03
3D36:  MOVFF  01,4F7
3D3A:  MOVWF  xF8
3D3C:  MOVFF  4F6,541
3D40:  MOVFF  4F5,540
3D44:  MOVFF  4F4,53F
3D48:  MOVFF  4F3,53E
3D4C:  MOVFF  FE8,543
3D50:  MOVFF  01,542
3D54:  MOVLB  0
3D56:  CALL   0234
....................    pDir = (DIR*)(&(gFiles[f].IOpuffer[32*gFiles[f].dirIdx])); 
3D5A:  MOVLB  5
3D5C:  CLRF   x3F
3D5E:  MOVFF  4EC,53E
3D62:  MOVLW  02
3D64:  MOVWF  x41
3D66:  MOVLW  31
3D68:  MOVWF  x40
3D6A:  MOVLB  0
3D6C:  CALL   0370
3D70:  MOVFF  02,4F4
3D74:  MOVFF  01,4F3
3D78:  MOVLB  5
3D7A:  CLRF   x3F
3D7C:  MOVFF  4EC,53E
3D80:  MOVLW  02
3D82:  MOVWF  x41
3D84:  MOVLW  31
3D86:  MOVWF  x40
3D88:  MOVLB  0
3D8A:  CALL   0370
3D8E:  MOVFF  01,4F3
3D92:  MOVLW  2E
3D94:  MOVLB  4
3D96:  ADDWF  01,W
3D98:  MOVWF  01
3D9A:  MOVLW  02
3D9C:  ADDWFC 02,W
3D9E:  MOVWF  03
3DA0:  MOVF   01,W
3DA2:  ADDLW  56
3DA4:  MOVWF  FE9
3DA6:  MOVLW  02
3DA8:  ADDWFC 03,W
3DAA:  MOVWF  FEA
3DAC:  MOVF   FEF,W
3DAE:  MULLW  20
3DB0:  MOVF   FF3,W
3DB2:  ADDWF  xF3,W
3DB4:  MOVWF  01
3DB6:  MOVLW  00
3DB8:  ADDWFC 02,W
3DBA:  MOVWF  03
3DBC:  MOVF   01,W
3DBE:  ADDLW  56
3DC0:  MOVWF  01
3DC2:  MOVLW  02
3DC4:  ADDWFC 03,F
3DC6:  MOVFF  01,4F1
3DCA:  MOVFF  03,4F2
....................    if (gFiles[f].DirEntry.bAttr & 0x10)  // if it is a directory 
3DCE:  MOVLB  5
3DD0:  CLRF   x3F
3DD2:  MOVFF  4EC,53E
3DD6:  MOVLW  02
3DD8:  MOVWF  x41
3DDA:  MOVLW  31
3DDC:  MOVWF  x40
3DDE:  MOVLB  0
3DE0:  CALL   0370
3DE4:  MOVFF  02,4F4
3DE8:  MOVFF  01,4F3
3DEC:  MOVLW  02
3DEE:  MOVLB  4
3DF0:  ADDWF  xF4,F
3DF2:  MOVLW  0B
3DF4:  ADDWF  01,W
3DF6:  MOVWF  01
3DF8:  MOVLW  00
3DFA:  ADDWFC xF4,W
3DFC:  MOVWF  03
3DFE:  MOVF   01,W
3E00:  ADDLW  56
3E02:  MOVWF  FE9
3E04:  MOVLW  02
3E06:  ADDWFC 03,W
3E08:  MOVWF  FEA
3E0A:  BTFSS  FEF.4
3E0C:  BRA    3E2E
....................       pDir->wSize = 0; 
3E0E:  MOVLW  1C
3E10:  ADDWF  xF1,W
3E12:  MOVWF  FE9
3E14:  MOVLW  00
3E16:  ADDWFC xF2,W
3E18:  MOVWF  FEA
3E1A:  MOVF   FEE,F
3E1C:  MOVF   FEE,F
3E1E:  CLRF   FEC
3E20:  MOVF   FED,F
3E22:  CLRF   FEF
3E24:  MOVF   FED,F
3E26:  CLRF   FEF
3E28:  MOVF   FED,F
3E2A:  CLRF   FEF
....................    else 
3E2C:  BRA    3EA0
....................       pDir->wSize = gFiles[f].position; 
3E2E:  MOVLW  1C
3E30:  ADDWF  xF1,W
3E32:  MOVWF  01
3E34:  MOVLW  00
3E36:  ADDWFC xF2,W
3E38:  MOVWF  03
3E3A:  MOVFF  01,4F3
3E3E:  MOVWF  xF4
3E40:  MOVLB  5
3E42:  CLRF   x3F
3E44:  MOVFF  4EC,53E
3E48:  MOVLW  02
3E4A:  MOVWF  x41
3E4C:  MOVLW  31
3E4E:  MOVWF  x40
3E50:  MOVLB  0
3E52:  CALL   0370
3E56:  MOVFF  02,4F6
3E5A:  MOVFF  01,4F5
3E5E:  MOVLW  26
3E60:  MOVLB  4
3E62:  ADDWF  01,W
3E64:  MOVWF  01
3E66:  MOVLW  02
3E68:  ADDWFC 02,W
3E6A:  MOVWF  03
3E6C:  MOVF   01,W
3E6E:  ADDLW  56
3E70:  MOVWF  FE9
3E72:  MOVLW  02
3E74:  ADDWFC 03,W
3E76:  MOVWF  FEA
3E78:  MOVFF  FEF,00
3E7C:  MOVFF  FEC,01
3E80:  MOVFF  FEC,02
3E84:  MOVFF  FEC,03
3E88:  MOVFF  4F4,FEA
3E8C:  MOVFF  4F3,FE9
3E90:  MOVFF  00,FEF
3E94:  MOVFF  01,FEC
3E98:  MOVFF  02,FEC
3E9C:  MOVFF  03,FEC
....................    pDir->hDate = GetCurrentDOSDate(); 
3EA0:  MOVLW  18
3EA2:  ADDWF  xF1,W
3EA4:  MOVWF  01
3EA6:  MOVLW  00
3EA8:  ADDWFC xF2,W
3EAA:  MOVWF  03
3EAC:  MOVFF  01,4F3
3EB0:  MOVWF  xF4
3EB2:  MOVLB  0
3EB4:  CALL   2CF6
3EB8:  MOVFF  4F4,FEA
3EBC:  MOVFF  4F3,FE9
3EC0:  MOVFF  02,FEC
3EC4:  MOVF   FED,F
3EC6:  MOVFF  01,FEF
....................    pDir->hTime = GetCurrentDOSTime(); 
3ECA:  MOVLW  16
3ECC:  MOVLB  4
3ECE:  ADDWF  xF1,W
3ED0:  MOVWF  01
3ED2:  MOVLW  00
3ED4:  ADDWFC xF2,W
3ED6:  MOVWF  03
3ED8:  MOVFF  01,4F3
3EDC:  MOVWF  xF4
3EDE:  MOVLB  0
3EE0:  CALL   2D58
3EE4:  MOVFF  4F4,FEA
3EE8:  MOVFF  4F3,FE9
3EEC:  MOVFF  02,FEC
3EF0:  MOVF   FED,F
3EF2:  MOVFF  01,FEF
....................    WriteSector(gFiles[f].dirSector,gFiles[f].IOpuffer); 
3EF6:  MOVLB  5
3EF8:  CLRF   x3F
3EFA:  MOVFF  4EC,53E
3EFE:  MOVLW  02
3F00:  MOVWF  x41
3F02:  MOVLW  31
3F04:  MOVWF  x40
3F06:  MOVLB  0
3F08:  CALL   0370
3F0C:  MOVFF  01,4F3
3F10:  MOVLW  2A
3F12:  MOVLB  4
3F14:  ADDWF  01,W
3F16:  MOVWF  01
3F18:  MOVLW  02
3F1A:  ADDWFC 02,W
3F1C:  MOVWF  03
3F1E:  MOVF   01,W
3F20:  ADDLW  56
3F22:  MOVWF  FE9
3F24:  MOVLW  02
3F26:  ADDWFC 03,W
3F28:  MOVWF  FEA
3F2A:  MOVFF  FEF,4F3
3F2E:  MOVFF  FEC,4F4
3F32:  MOVFF  FEC,4F5
3F36:  MOVFF  FEC,4F6
3F3A:  MOVLB  5
3F3C:  CLRF   x3F
3F3E:  MOVFF  4EC,53E
3F42:  MOVLW  02
3F44:  MOVWF  x41
3F46:  MOVLW  31
3F48:  MOVWF  x40
3F4A:  MOVLB  0
3F4C:  CALL   0370
3F50:  MOVFF  01,4F7
3F54:  MOVLW  56
3F56:  MOVLB  4
3F58:  ADDWF  01,W
3F5A:  MOVWF  01
3F5C:  MOVLW  02
3F5E:  ADDWFC 02,W
3F60:  MOVWF  03
3F62:  MOVFF  01,4F7
3F66:  MOVWF  xF8
3F68:  MOVFF  4F6,527
3F6C:  MOVFF  4F5,526
3F70:  MOVFF  4F4,525
3F74:  MOVFF  4F3,524
3F78:  MOVFF  FE8,529
3F7C:  MOVFF  01,528
3F80:  MOVLB  0
3F82:  CALL   298A
....................    ReadSector(actsector,gFiles[f].IOpuffer); 
3F86:  MOVLB  5
3F88:  CLRF   x3F
3F8A:  MOVFF  4EC,53E
3F8E:  MOVLW  02
3F90:  MOVWF  x41
3F92:  MOVLW  31
3F94:  MOVWF  x40
3F96:  MOVLB  0
3F98:  CALL   0370
3F9C:  MOVFF  01,4F3
3FA0:  MOVLW  56
3FA2:  MOVLB  4
3FA4:  ADDWF  01,W
3FA6:  MOVWF  01
3FA8:  MOVLW  02
3FAA:  ADDWFC 02,W
3FAC:  MOVWF  03
3FAE:  MOVFF  01,4F3
3FB2:  MOVWF  xF4
3FB4:  MOVFF  4F0,541
3FB8:  MOVFF  4EF,540
3FBC:  MOVFF  4EE,53F
3FC0:  MOVFF  4ED,53E
3FC4:  MOVFF  FE8,543
3FC8:  MOVFF  01,542
3FCC:  MOVLB  0
3FCE:  CALL   0234
....................    return MMC_OK; 
3FD2:  MOVLW  00
3FD4:  MOVWF  01
3FD6:  MOVLB  4
.................... } 
3FD8:  MOVLB  0
3FDA:  GOTO   406E (RETURN)
....................  
.................... // Function: Enter a specified directory 
.................... char cwd(char *fname, char f) 
.................... { 
....................    int32 actsector; 
....................    if (f > (MAXFILES-1)) 
*
0E52:  MOVLB  5
0E54:  MOVF   x09,F
0E56:  BZ    0E5E
....................    { 
....................       return FALSE; // just in case of overaddressing 
0E58:  MOVLW  00
0E5A:  MOVWF  01
0E5C:  BRA    0FC4
....................    } 
....................    if (IsSelfDir(fname)) 
0E5E:  MOVFF  508,50F
0E62:  MOVFF  507,50E
0E66:  MOVLB  0
0E68:  BRA    0788
0E6A:  MOVF   01,F
0E6C:  BZ    0E78
....................    { 
....................       return TRUE; // already in Root dir 
0E6E:  MOVLW  01
0E70:  MOVWF  01
0E72:  MOVLB  5
0E74:  BRA    0FC4
0E76:  MOVLB  0
....................    } 
....................    if (!FindDirEntry(fname,f)) 
0E78:  MOVFF  508,50F
0E7C:  MOVFF  507,50E
0E80:  MOVFF  509,510
0E84:  RCALL  0A08
0E86:  MOVF   01,F
0E88:  BNZ   0E94
....................    { 
....................       return FALSE; // not found 
0E8A:  MOVLW  00
0E8C:  MOVWF  01
0E8E:  MOVLB  5
0E90:  BRA    0FC4
0E92:  MOVLB  0
....................    } 
....................  
....................    actsector = ComposeCluster(f); 
0E94:  MOVFF  509,510
0E98:  RCALL  0D8C
0E9A:  MOVFF  03,50D
0E9E:  MOVFF  02,50C
0EA2:  MOVFF  01,50B
0EA6:  MOVFF  00,50A
....................    actsector += gFAT32Vars.gFirstDataSector; // read current dir 
0EAA:  MOVLB  2
0EAC:  MOVF   x18,W
0EAE:  MOVLB  5
0EB0:  ADDWF  x0A,F
0EB2:  MOVLB  2
0EB4:  MOVF   x19,W
0EB6:  MOVLB  5
0EB8:  ADDWFC x0B,F
0EBA:  MOVLB  2
0EBC:  MOVF   x1A,W
0EBE:  MOVLB  5
0EC0:  ADDWFC x0C,F
0EC2:  MOVLB  2
0EC4:  MOVF   x1B,W
0EC6:  MOVLB  5
0EC8:  ADDWFC x0D,F
....................    ReadSector(actsector,gFiles[f].IOpuffer); 
0ECA:  CLRF   x3F
0ECC:  MOVFF  509,53E
0ED0:  MOVLW  02
0ED2:  MOVWF  x41
0ED4:  MOVLW  31
0ED6:  MOVWF  x40
0ED8:  MOVLB  0
0EDA:  CALL   0370
0EDE:  MOVFF  01,50E
0EE2:  MOVLW  56
0EE4:  MOVLB  5
0EE6:  ADDWF  01,W
0EE8:  MOVWF  01
0EEA:  MOVLW  02
0EEC:  ADDWFC 02,W
0EEE:  MOVWF  03
0EF0:  MOVFF  01,50E
0EF4:  MOVWF  x0F
0EF6:  MOVFF  50D,541
0EFA:  MOVFF  50C,540
0EFE:  MOVFF  50B,53F
0F02:  MOVFF  50A,53E
0F06:  MOVWF  x43
0F08:  MOVFF  01,542
0F0C:  MOVLB  0
0F0E:  CALL   0234
....................    gFAT32Vars.gDirEntrySector = actsector; 
0F12:  MOVFF  50D,220
0F16:  MOVFF  50C,21F
0F1A:  MOVFF  50B,21E
0F1E:  MOVFF  50A,21D
....................    gFiles[f].dirSector = actsector; 
0F22:  MOVLB  5
0F24:  CLRF   x3F
0F26:  MOVFF  509,53E
0F2A:  MOVLW  02
0F2C:  MOVWF  x41
0F2E:  MOVLW  31
0F30:  MOVWF  x40
0F32:  MOVLB  0
0F34:  CALL   0370
0F38:  MOVFF  01,50E
0F3C:  MOVLW  2A
0F3E:  MOVLB  5
0F40:  ADDWF  01,W
0F42:  MOVWF  01
0F44:  MOVLW  02
0F46:  ADDWFC 02,W
0F48:  MOVWF  03
0F4A:  MOVF   01,W
0F4C:  ADDLW  56
0F4E:  MOVWF  FE9
0F50:  MOVLW  02
0F52:  ADDWFC 03,W
0F54:  MOVWF  FEA
0F56:  MOVFF  50A,FEF
0F5A:  MOVFF  50B,FEC
0F5E:  MOVFF  50C,FEC
0F62:  MOVFF  50D,FEC
....................    gFiles[f].CurrentCluster = ComposeCluster(f); 
0F66:  CLRF   x3F
0F68:  MOVFF  509,53E
0F6C:  MOVLW  02
0F6E:  MOVWF  x41
0F70:  MOVLW  31
0F72:  MOVWF  x40
0F74:  MOVLB  0
0F76:  CALL   0370
0F7A:  MOVFF  01,50E
0F7E:  MOVLW  20
0F80:  MOVLB  5
0F82:  ADDWF  01,W
0F84:  MOVWF  01
0F86:  MOVLW  02
0F88:  ADDWFC 02,W
0F8A:  MOVWF  03
0F8C:  MOVF   01,W
0F8E:  ADDLW  56
0F90:  MOVWF  01
0F92:  MOVLW  02
0F94:  ADDWFC 03,F
0F96:  MOVFF  01,50E
0F9A:  MOVFF  03,50F
0F9E:  MOVFF  509,510
0FA2:  MOVLB  0
0FA4:  RCALL  0D8C
0FA6:  MOVFF  50F,FEA
0FAA:  MOVFF  50E,FE9
0FAE:  MOVFF  00,FEF
0FB2:  MOVFF  01,FEC
0FB6:  MOVFF  02,FEC
0FBA:  MOVFF  03,FEC
....................  
....................    return TRUE; 
0FBE:  MOVLW  01
0FC0:  MOVWF  01
0FC2:  MOVLB  5
.................... } 
0FC4:  MOVLB  0
0FC6:  GOTO   10C8 (RETURN)
....................  
.................... // Function: Put a char to the open file 
.................... MMCResponse fputch(char be, char f) 
.................... { 
....................    int32 nextcluster,actsector; 
....................  
....................    if (f > (MAXFILES-1)) 
....................       return MMC_INVALID_FILE; 
....................    if (gFiles[f].posinsector == 512) 
....................    { 
....................       actsector = gFiles[f].CurrentCluster + gFAT32Vars.gFirstDataSector; 
....................       WriteSector(actsector,gFiles[f].IOpuffer); 
....................       nextcluster = FindFirstFreeCluster(); 
....................       if (nextcluster != 0x0FFFFFFF && nextcluster != 0) 
....................       { 
....................          SetClusterEntry(gFiles[f].CurrentCluster,nextcluster); 
....................          SetClusterEntry(nextcluster,0x0FFFFFFF); 
....................          actsector = nextcluster + gFAT32Vars.gFirstDataSector; 
....................          ReadSector(actsector,gFiles[f].IOpuffer); 
....................          gFiles[f].CurrentCluster = nextcluster; 
....................          gFiles[f].posinsector = 0; 
....................       } 
....................    } 
....................    gFiles[f].IOpuffer[gFiles[f].posinsector] = be; 
....................    gFiles[f].posinsector++; 
....................    gFiles[f].position++; 
....................    return MMC_OK; 
.................... } 
....................  
.................... // Function: Puts a string to the open file 
.................... MMCResponse fputstring(char *be, char f) 
.................... { 
....................    int16 leng,i; 
....................  
....................    if (f > (MAXFILES-1)) 
....................       return MMC_INVALID_FILE; 
....................    leng = strlen(be); 
....................    for (i=0;i<leng;i++) 
....................       fputch(be[i],f); 
....................    return MMC_OK; 
.................... } 
....................  
.................... // Function: Read a buffer from the open file 
.................... int16 fread(char *buffer, int16 leng, char f) 
.................... { 
....................    int16 i,retv; 
....................    char c,v; 
....................  
....................    if (f > (MAXFILES-1)) 
....................       return 0; 
....................    retv = 0; 
....................    for (i=0;i<leng;i++) 
....................    { 
....................       v = fgetch(&c,f); 
....................       if (v == MMC_OK) 
....................       { 
....................          buffer[i] = c; 
....................          retv++; 
....................       } 
....................       else 
....................          break; 
....................    } 
....................    return retv; 
.................... } 
....................  
.................... // Function: Write a buffer to the open file 
.................... MMCResponse fwrite(char *buffer, int16 leng, char f) 
.................... { 
....................    int16 i; 
....................  
....................    if (f > (MAXFILES-1)) 
....................       return MMC_INVALID_FILE; 
....................    for (i=0;i<leng;i++) 
....................       fputch(buffer[i],f); 
....................    return MMC_OK; 
.................... } 
....................  
.................... // Function: Read a char from the open file 
.................... MMCResponse fgetch(char *ki,char f) 
.................... { 
....................    int32 nextcluster,actsector; 
....................  
....................    if (f > (MAXFILES-1)) 
*
385E:  MOVLB  4
3860:  MOVF   xED,F
3862:  BZ    386A
....................       return MMC_INVALID_FILE; 
3864:  MOVLW  88
3866:  MOVWF  01
3868:  BRA    3C00
....................    if (gFiles[f].position >= gFiles[f].DirEntry.wSize) 
386A:  MOVLB  5
386C:  CLRF   x3F
386E:  MOVFF  4ED,53E
3872:  MOVLW  02
3874:  MOVWF  x41
3876:  MOVLW  31
3878:  MOVWF  x40
387A:  MOVLB  0
387C:  CALL   0370
3880:  MOVFF  01,4F6
3884:  MOVLW  26
3886:  MOVLB  4
3888:  ADDWF  01,W
388A:  MOVWF  01
388C:  MOVLW  02
388E:  ADDWFC 02,W
3890:  MOVWF  03
3892:  MOVF   01,W
3894:  ADDLW  56
3896:  MOVWF  FE9
3898:  MOVLW  02
389A:  ADDWFC 03,W
389C:  MOVWF  FEA
389E:  MOVFF  FEF,4F6
38A2:  MOVFF  FEC,4F7
38A6:  MOVFF  FEC,4F8
38AA:  MOVFF  FEC,4F9
38AE:  MOVLB  5
38B0:  CLRF   x3F
38B2:  MOVFF  4ED,53E
38B6:  MOVLW  02
38B8:  MOVWF  x41
38BA:  MOVLW  31
38BC:  MOVWF  x40
38BE:  MOVLB  0
38C0:  CALL   0370
38C4:  MOVFF  02,4FB
38C8:  MOVFF  01,4FA
38CC:  MOVLW  02
38CE:  MOVLB  4
38D0:  ADDWF  xFB,F
38D2:  MOVLW  1C
38D4:  ADDWF  01,W
38D6:  MOVWF  01
38D8:  MOVLW  00
38DA:  ADDWFC xFB,W
38DC:  MOVWF  03
38DE:  MOVF   01,W
38E0:  ADDLW  56
38E2:  MOVWF  FE9
38E4:  MOVLW  02
38E6:  ADDWFC 03,W
38E8:  MOVWF  FEA
38EA:  MOVFF  FEF,00
38EE:  MOVFF  FEC,01
38F2:  MOVFF  FEC,02
38F6:  MOVFF  FEC,03
38FA:  MOVF   03,W
38FC:  SUBWF  xF9,W
38FE:  BNC   391E
3900:  BNZ   3918
3902:  MOVF   02,W
3904:  SUBWF  xF8,W
3906:  BNC   391E
3908:  BNZ   3918
390A:  MOVF   01,W
390C:  SUBWF  xF7,W
390E:  BNC   391E
3910:  BNZ   3918
3912:  MOVF   00,W
3914:  SUBWF  xF6,W
3916:  BNC   391E
....................       return MMC_INVALID_POSITION; 
3918:  MOVLW  C8
391A:  MOVWF  01
391C:  BRA    3C00
....................    *ki = gFiles[f].IOpuffer[gFiles[f].posinsector]; 
391E:  MOVFF  4EC,03
3922:  MOVFF  4EB,4F6
3926:  MOVFF  4EC,4F7
392A:  MOVLB  5
392C:  CLRF   x3F
392E:  MOVFF  4ED,53E
3932:  MOVLW  02
3934:  MOVWF  x41
3936:  MOVLW  31
3938:  MOVWF  x40
393A:  MOVLB  0
393C:  CALL   0370
3940:  MOVFF  02,4F9
3944:  MOVFF  01,4F8
3948:  MOVLB  5
394A:  CLRF   x3F
394C:  MOVFF  4ED,53E
3950:  MOVLW  02
3952:  MOVWF  x41
3954:  MOVLW  31
3956:  MOVWF  x40
3958:  MOVLB  0
395A:  CALL   0370
395E:  MOVFF  01,4F8
3962:  MOVLW  24
3964:  MOVLB  4
3966:  ADDWF  01,W
3968:  MOVWF  01
396A:  MOVLW  02
396C:  ADDWFC 02,W
396E:  MOVWF  03
3970:  MOVF   01,W
3972:  ADDLW  56
3974:  MOVWF  FE9
3976:  MOVLW  02
3978:  ADDWFC 03,W
397A:  MOVWF  FEA
397C:  MOVFF  FEC,4F9
3980:  MOVF   FED,F
3982:  MOVFF  FEF,4F8
3986:  MOVF   xF8,W
3988:  ADDWF  xF8,W
398A:  MOVWF  01
398C:  MOVF   xF9,W
398E:  ADDWFC xF9,W
3990:  MOVWF  03
3992:  MOVF   01,W
3994:  ADDLW  56
3996:  MOVWF  FE9
3998:  MOVLW  02
399A:  ADDWFC 03,W
399C:  MOVWF  FEA
399E:  MOVFF  FEF,4F8
39A2:  MOVFF  4F7,FEA
39A6:  MOVFF  4F6,FE9
39AA:  MOVFF  4F8,FEF
....................    gFiles[f].posinsector++; 
39AE:  MOVLB  5
39B0:  CLRF   x3F
39B2:  MOVFF  4ED,53E
39B6:  MOVLW  02
39B8:  MOVWF  x41
39BA:  MOVLW  31
39BC:  MOVWF  x40
39BE:  MOVLB  0
39C0:  CALL   0370
39C4:  MOVFF  02,4F7
39C8:  MOVFF  01,4F6
39CC:  MOVLW  24
39CE:  MOVLB  4
39D0:  ADDWF  01,W
39D2:  MOVWF  01
39D4:  MOVLW  02
39D6:  ADDWFC 02,W
39D8:  MOVWF  03
39DA:  MOVF   01,W
39DC:  ADDLW  56
39DE:  MOVWF  FE9
39E0:  MOVLW  02
39E2:  ADDWFC 03,W
39E4:  MOVWF  FEA
39E6:  MOVLW  01
39E8:  ADDWF  FEE,F
39EA:  BNC   39EE
39EC:  INCF   FEF,F
....................    gFiles[f].position++; 
39EE:  MOVLB  5
39F0:  CLRF   x3F
39F2:  MOVFF  4ED,53E
39F6:  MOVLW  02
39F8:  MOVWF  x41
39FA:  MOVLW  31
39FC:  MOVWF  x40
39FE:  MOVLB  0
3A00:  CALL   0370
3A04:  MOVFF  01,4F6
3A08:  MOVLW  26
3A0A:  MOVLB  4
3A0C:  ADDWF  01,W
3A0E:  MOVWF  01
3A10:  MOVLW  02
3A12:  ADDWFC 02,W
3A14:  MOVWF  03
3A16:  MOVF   01,W
3A18:  ADDLW  56
3A1A:  MOVWF  FE9
3A1C:  MOVLW  02
3A1E:  ADDWFC 03,W
3A20:  MOVWF  FEA
3A22:  MOVLW  01
3A24:  ADDWF  FEE,F
3A26:  MOVLW  00
3A28:  ADDWFC FEE,F
3A2A:  ADDWFC FEE,F
3A2C:  ADDWFC FED,F
....................    if (gFiles[f].posinsector == 512) 
3A2E:  MOVLB  5
3A30:  CLRF   x3F
3A32:  MOVFF  4ED,53E
3A36:  MOVLW  02
3A38:  MOVWF  x41
3A3A:  MOVLW  31
3A3C:  MOVWF  x40
3A3E:  MOVLB  0
3A40:  CALL   0370
3A44:  MOVFF  01,4F6
3A48:  MOVLW  24
3A4A:  MOVLB  4
3A4C:  ADDWF  01,W
3A4E:  MOVWF  01
3A50:  MOVLW  02
3A52:  ADDWFC 02,W
3A54:  MOVWF  03
3A56:  MOVF   01,W
3A58:  ADDLW  56
3A5A:  MOVWF  FE9
3A5C:  MOVLW  02
3A5E:  ADDWFC 03,W
3A60:  MOVWF  FEA
3A62:  MOVFF  FEC,4F7
3A66:  MOVF   FED,F
3A68:  MOVFF  FEF,4F6
3A6C:  MOVF   xF6,F
3A6E:  BTFSS  FD8.2
3A70:  BRA    3BFC
3A72:  MOVF   xF7,W
3A74:  SUBLW  02
3A76:  BTFSS  FD8.2
3A78:  BRA    3BFC
....................    { 
....................       nextcluster = GetNextCluster(gFiles[f].CurrentCluster); 
3A7A:  MOVLB  5
3A7C:  CLRF   x3F
3A7E:  MOVFF  4ED,53E
3A82:  MOVLW  02
3A84:  MOVWF  x41
3A86:  MOVLW  31
3A88:  MOVWF  x40
3A8A:  MOVLB  0
3A8C:  CALL   0370
3A90:  MOVFF  01,4F6
3A94:  MOVLW  20
3A96:  MOVLB  4
3A98:  ADDWF  01,W
3A9A:  MOVWF  01
3A9C:  MOVLW  02
3A9E:  ADDWFC 02,W
3AA0:  MOVWF  03
3AA2:  MOVF   01,W
3AA4:  ADDLW  56
3AA6:  MOVWF  FE9
3AA8:  MOVLW  02
3AAA:  ADDWFC 03,W
3AAC:  MOVWF  FEA
3AAE:  MOVFF  FEF,4F6
3AB2:  MOVFF  FEC,4F7
3AB6:  MOVFF  FEC,4F8
3ABA:  MOVFF  FEC,4F9
3ABE:  MOVFF  4F9,534
3AC2:  MOVFF  4F8,533
3AC6:  MOVFF  4F7,532
3ACA:  MOVFF  4F6,531
3ACE:  MOVLB  0
3AD0:  CALL   08F6
3AD4:  MOVFF  03,4F1
3AD8:  MOVFF  02,4F0
3ADC:  MOVFF  01,4EF
3AE0:  MOVFF  00,4EE
....................       if (nextcluster != 0x0FFFFFFF && nextcluster != 0) 
3AE4:  MOVLB  4
3AE6:  INCFSZ xEE,W
3AE8:  BRA    3AFA
3AEA:  INCFSZ xEF,W
3AEC:  BRA    3AFA
3AEE:  INCFSZ xF0,W
3AF0:  BRA    3AFA
3AF2:  MOVF   xF1,W
3AF4:  SUBLW  0F
3AF6:  BTFSC  FD8.2
3AF8:  BRA    3BFC
3AFA:  MOVF   xEE,F
3AFC:  BNZ   3B0A
3AFE:  MOVF   xEF,F
3B00:  BNZ   3B0A
3B02:  MOVF   xF0,F
3B04:  BNZ   3B0A
3B06:  MOVF   xF1,F
3B08:  BZ    3BFC
....................       { 
....................          actsector = nextcluster + gFAT32Vars.gFirstDataSector; 
3B0A:  MOVLB  2
3B0C:  MOVF   x18,W
3B0E:  MOVLB  4
3B10:  ADDWF  xEE,W
3B12:  MOVWF  xF2
3B14:  MOVLB  2
3B16:  MOVF   x19,W
3B18:  MOVLB  4
3B1A:  ADDWFC xEF,W
3B1C:  MOVWF  xF3
3B1E:  MOVLB  2
3B20:  MOVF   x1A,W
3B22:  MOVLB  4
3B24:  ADDWFC xF0,W
3B26:  MOVWF  xF4
3B28:  MOVLB  2
3B2A:  MOVF   x1B,W
3B2C:  MOVLB  4
3B2E:  ADDWFC xF1,W
3B30:  MOVWF  xF5
....................          ReadSector(actsector,gFiles[f].IOpuffer); 
3B32:  MOVLB  5
3B34:  CLRF   x3F
3B36:  MOVFF  4ED,53E
3B3A:  MOVLW  02
3B3C:  MOVWF  x41
3B3E:  MOVLW  31
3B40:  MOVWF  x40
3B42:  MOVLB  0
3B44:  CALL   0370
3B48:  MOVFF  01,4F6
3B4C:  MOVLW  56
3B4E:  MOVLB  4
3B50:  ADDWF  01,W
3B52:  MOVWF  01
3B54:  MOVLW  02
3B56:  ADDWFC 02,W
3B58:  MOVWF  03
3B5A:  MOVFF  01,4F6
3B5E:  MOVWF  xF7
3B60:  MOVFF  4F5,541
3B64:  MOVFF  4F4,540
3B68:  MOVFF  4F3,53F
3B6C:  MOVFF  4F2,53E
3B70:  MOVFF  FE8,543
3B74:  MOVFF  01,542
3B78:  MOVLB  0
3B7A:  CALL   0234
....................          gFiles[f].CurrentCluster = nextcluster; 
3B7E:  MOVLB  5
3B80:  CLRF   x3F
3B82:  MOVFF  4ED,53E
3B86:  MOVLW  02
3B88:  MOVWF  x41
3B8A:  MOVLW  31
3B8C:  MOVWF  x40
3B8E:  MOVLB  0
3B90:  CALL   0370
3B94:  MOVFF  01,4F6
3B98:  MOVLW  20
3B9A:  MOVLB  4
3B9C:  ADDWF  01,W
3B9E:  MOVWF  01
3BA0:  MOVLW  02
3BA2:  ADDWFC 02,W
3BA4:  MOVWF  03
3BA6:  MOVF   01,W
3BA8:  ADDLW  56
3BAA:  MOVWF  FE9
3BAC:  MOVLW  02
3BAE:  ADDWFC 03,W
3BB0:  MOVWF  FEA
3BB2:  MOVFF  4EE,FEF
3BB6:  MOVFF  4EF,FEC
3BBA:  MOVFF  4F0,FEC
3BBE:  MOVFF  4F1,FEC
....................          gFiles[f].posinsector = 0; 
3BC2:  MOVLB  5
3BC4:  CLRF   x3F
3BC6:  MOVFF  4ED,53E
3BCA:  MOVLW  02
3BCC:  MOVWF  x41
3BCE:  MOVLW  31
3BD0:  MOVWF  x40
3BD2:  MOVLB  0
3BD4:  CALL   0370
3BD8:  MOVFF  01,4F6
3BDC:  MOVLW  24
3BDE:  MOVLB  4
3BE0:  ADDWF  01,W
3BE2:  MOVWF  01
3BE4:  MOVLW  02
3BE6:  ADDWFC 02,W
3BE8:  MOVWF  03
3BEA:  MOVF   01,W
3BEC:  ADDLW  56
3BEE:  MOVWF  FE9
3BF0:  MOVLW  02
3BF2:  ADDWFC 03,W
3BF4:  MOVWF  FEA
3BF6:  CLRF   FEC
3BF8:  MOVF   FED,F
3BFA:  CLRF   FEF
....................       } 
....................    } 
....................    return MMC_OK; 
3BFC:  MOVLW  00
3BFE:  MOVWF  01
.................... } 
3C00:  MOVLB  0
3C02:  GOTO   4254 (RETURN)
....................  
.................... // Function: Removes a file 
.................... MMCResponse remove(char *fname) 
.................... { 
....................    char i,found; 
....................    char f; 
....................    DIR *pDir; 
....................    int32 nextcluster,currentcluster; 
....................    char *filename; 
....................  
....................    filename = TryFile(fname,&f); 
....................    if (filename == 0) 
....................       return MMC_NOT_FOUND; 
....................    found = FindDirEntry(filename,f); 
....................    if (!found) 
....................    { 
....................       gFiles[f].Free = TRUE; 
....................       return MMC_NOT_FOUND; 
....................    } 
....................  
....................    pDir = (DIR*)(&(gFiles[f].IOpuffer[32*(int16)gFAT32Vars.gDirEntryIdx])); 
....................    pDir->sName[0] = 0xE5; 
....................    for (i=1;i<8;i++) 
....................       pDir->sName[i] = ' '; 
....................    for (i=0;i<3;i++) 
....................       pDir->spam[i] = ' '; 
....................    WriteSector(gFAT32Vars.gDirEntrySector,gFiles[f].IOpuffer); 
....................    currentcluster = ComposeCluster(f); 
....................    while (currentcluster != 0x0FFFFFFF && nextcluster != 0) 
....................    { 
....................       nextcluster = GetNextCluster(currentcluster); 
....................       ClearClusterEntry(currentcluster); 
....................       currentcluster = nextcluster; 
....................    } 
....................    ClearClusterEntry(currentcluster); 
....................    SetClusterEntry(currentcluster,0); 
....................    currentcluster = gFAT32Vars.gStartSector+DiskInfo.Reserved1 + gFAT32Vars.FATstartidx; 
....................    WriteSector(currentcluster,FATTable); 
....................    currentcluster += DiskInfo.hSectorsPerFat; 
....................    WriteSector(currentcluster,FATTable); 
....................    gFiles[f].Free = TRUE; 
....................  
....................    return MMC_OK; 
.................... } 
....................  
....................  
.................... // Function: Gets the size of a file 
.................... MMCResponse getfsize(char *fname, int32 *fsiz) 
.................... { 
....................    char found; 
....................    char f; 
....................    DIR *pDir; 
....................    char *filename; 
....................  
....................    filename = TryFile(fname,&f); 
....................    if (filename == 0) 
....................       return MMC_NOT_FOUND; 
....................    found = FindDirEntry(filename,f); 
....................    if (!found) 
....................    { 
....................       gFiles[f].Free = TRUE; 
....................       return MMC_NOT_FOUND; 
....................    } 
....................    pDir = (DIR*)(&(gFiles[f].IOpuffer[32*(Int16)gFAT32Vars.gDirEntryIdx])); 
....................    gFiles[f].Free = TRUE; 
....................    *fsiz = pDir->wSize; 
....................    return MMC_OK; 
.................... } 
....................  
....................  
.................... void main(void) 
.................... { 
*
40AE:  CLRF   FF8
40B0:  BCF    FD0.7
40B2:  MOVLW  05
40B4:  MOVWF  07
40B6:  MOVLW  4E
40B8:  MOVWF  06
40BA:  MOVLW  02
40BC:  MOVLB  5
40BE:  MOVWF  x4F
40C0:  MOVLW  AE
40C2:  MOVWF  x4E
40C4:  CLRF   x51
40C6:  CLRF   x50
40C8:  MOVLB  0
40CA:  CLRF   FEA
40CC:  CLRF   FE9
40CE:  BSF    FB8.3
40D0:  MOVLW  70
40D2:  MOVWF  FAF
40D4:  MOVLW  02
40D6:  MOVWF  FB0
40D8:  MOVLW  A6
40DA:  MOVWF  FAC
40DC:  MOVLW  90
40DE:  MOVWF  FAB
40E0:  BSF    F8A.5
40E2:  MOVF   FC1,W
40E4:  ANDLW  C0
40E6:  IORLW  0F
40E8:  MOVWF  FC1
40EA:  MOVLW  07
40EC:  MOVWF  FB4
40EE:  CLRF   04
40F0:  CLRF   05
.................... 	char f,filename[20],res,i,c; 
.................... 	 
.................... 	while(TRUE) 
.................... 	{ 
....................     if(MMCInit() == MMC_OK) 
40F2:  GOTO   0130
40F6:  MOVF   01,F
40F8:  BTFSS  FD8.2
40FA:  BRA    429C
....................     { 
.................... 		printf("MMC initialized\r\n"); 
40FC:  MOVLW  2A
40FE:  MOVWF  FF6
4100:  MOVLW  00
4102:  MOVWF  FF7
4104:  CALL   0212
.................... 		InitFAT(); 
4108:  GOTO   0392
.................... 		strcpy(filename,"DIR/"); 
410C:  MOVLW  04
410E:  MOVWF  FEA
4110:  MOVLW  D4
4112:  MOVWF  FE9
4114:  MOVLW  00
4116:  CALL   0004
411A:  TBLRD*-
411C:  TBLRD*+
411E:  MOVF   FF5,W
4120:  MOVWF  FEE
4122:  IORLW  00
4124:  BNZ   411C
.................... 		f = InitList(filename); 
4126:  MOVLW  04
4128:  MOVLB  4
412A:  MOVWF  xEC
412C:  MOVLW  D4
412E:  MOVWF  xEB
4130:  MOVLB  0
4132:  GOTO   114C
4136:  MOVFF  01,4D3
.................... 		if(f & MMC_ERROR) 
413A:  MOVLB  4
413C:  BTFSS  xD3.7
413E:  BRA    4152
.................... 			printf("Error"); 
4140:  MOVLW  3C
4142:  MOVWF  FF6
4144:  MOVLW  00
4146:  MOVWF  FF7
4148:  MOVLB  0
414A:  CALL   0212
.................... 		else{ 
414E:  BRA    420A
4150:  MOVLB  4
.................... 			do{ 
.................... 				res = ListFiles(f); 
4152:  MOVFF  4D3,4EB
4156:  MOVLB  0
4158:  GOTO   197A
415C:  MOVFF  01,4E8
.................... 				for(i=0;i<res;i++){ 
4160:  MOVLB  4
4162:  CLRF   xE9
4164:  MOVF   xE8,W
4166:  SUBWF  xE9,W
4168:  BC    41EE
.................... 					printf(FileList[i].name); 
416A:  MOVF   xE9,W
416C:  MULLW  05
416E:  MOVF   FF3,W
4170:  CLRF   xEC
4172:  MOVWF  xEB
4174:  MOVLW  A1
4176:  ADDWF  xEB,W
4178:  MOVWF  FE9
417A:  MOVLW  04
417C:  ADDWFC xEC,W
417E:  MOVWF  FEA
4180:  MOVFF  FEC,4EC
4184:  MOVF   FED,F
4186:  MOVFF  FEF,4EB
418A:  MOVFF  4EC,FEA
418E:  MOVFF  4EB,FE9
4192:  MOVLB  0
4194:  CALL   248A
.................... 					if(FileList[i].isDir) 
4198:  MOVLB  4
419A:  MOVF   xE9,W
419C:  MULLW  05
419E:  MOVF   FF3,W
41A0:  CLRF   xEC
41A2:  MOVWF  xEB
41A4:  MOVLW  04
41A6:  ADDWF  xEB,W
41A8:  MOVWF  01
41AA:  MOVLW  00
41AC:  ADDWFC xEC,W
41AE:  MOVWF  03
41B0:  MOVF   01,W
41B2:  ADDLW  A1
41B4:  MOVWF  FE9
41B6:  MOVLW  04
41B8:  ADDWFC 03,W
41BA:  MOVWF  FEA
41BC:  BTFSS  FEF.0
41BE:  BRA    41DA
.................... 						printf("\\\r\n");   //a "\" with row break 
41C0:  MOVLW  5C
41C2:  BTFSS  F9E.4
41C4:  BRA    41C2
41C6:  MOVWF  FAD
41C8:  MOVLW  0D
41CA:  BTFSS  F9E.4
41CC:  BRA    41CA
41CE:  MOVWF  FAD
41D0:  MOVLW  0A
41D2:  BTFSS  F9E.4
41D4:  BRA    41D2
41D6:  MOVWF  FAD
.................... 					else 
41D8:  BRA    41EA
.................... 						printf("\r\n"); 
41DA:  MOVLW  0D
41DC:  BTFSS  F9E.4
41DE:  BRA    41DC
41E0:  MOVWF  FAD
41E2:  MOVLW  0A
41E4:  BTFSS  F9E.4
41E6:  BRA    41E4
41E8:  MOVWF  FAD
.................... 					} 
41EA:  INCF   xE9,F
41EC:  BRA    4164
.................... 			} while(NextPage(f) == MMC_OK); 
41EE:  MOVFF  4D3,4EB
41F2:  MOVLB  0
41F4:  GOTO   24B0
41F8:  MOVF   01,F
41FA:  BTFSS  FD8.2
41FC:  BRA    4202
41FE:  MOVLB  4
4200:  BRA    4152
.................... 			CloseList(f); // frees the file, but the list is 
4202:  MOVFF  4D3,4EB
4206:  GOTO   2768
.................... 		}                 // still there... 
.................... 		strcpy(filename,FileList[0].shortName); 
420A:  MOVLW  04
420C:  MOVWF  FEA
420E:  MOVLW  D4
4210:  MOVWF  FE9
4212:  MOVFF  4A4,FE2
4216:  MOVFF  4A3,FE1
421A:  MOVF   FE7,F
421C:  MOVFF  FE6,FEE
4220:  BNZ   421A
.................... 		f = fopen(filename,'r');  // open file for reading 
4222:  MOVLW  04
4224:  MOVLB  4
4226:  MOVWF  xEC
4228:  MOVLW  D4
422A:  MOVWF  xEB
422C:  MOVLW  72
422E:  MOVWF  xED
4230:  MOVLB  0
4232:  GOTO   3258
4236:  MOVFF  01,4D3
.................... 		if((f & MMC_ERROR) == 0) // No error, same as 
423A:  MOVLB  4
423C:  MOVF   xD3,W
423E:  ANDLW  80
4240:  BNZ   4272
.................... 		{                        // if(f < MAXFILES) 
.................... 			while(fgetch(&c,f) == MMC_OK) 
.................... 				printf(c); 
4242:  MOVLW  04
4244:  MOVWF  xEC
4246:  MOVLW  EA
4248:  MOVWF  xEB
424A:  MOVFF  4D3,4ED
424E:  MOVLB  0
4250:  GOTO   385E
4254:  MOVF   01,F
4256:  BNZ   4268
4258:  CLRF   FEA
425A:  MOVFF  4EA,FE9
425E:  CALL   248A
4262:  MOVLB  4
4264:  BRA    4242
4266:  MOVLB  0
.................... 			fclose(f); 
4268:  MOVFF  4D3,4EB
426C:  BRA    3FDE
.................... 		} 
.................... 		else if(f == MMC_NOT_FOUND) 
426E:  BRA    4298
4270:  MOVLB  4
4272:  MOVF   xD3,W
4274:  SUBLW  B0
4276:  BNZ   428A
.................... 				printf("1st file in list was probebly a dir"); 
4278:  MOVLW  42
427A:  MOVWF  FF6
427C:  MOVLW  00
427E:  MOVWF  FF7
4280:  MOVLB  0
4282:  CALL   0212
.................... 			else 
4286:  BRA    4298
4288:  MOVLB  4
.................... 				printf("Other error\r\n"); 
428A:  MOVLW  66
428C:  MOVWF  FF6
428E:  MOVLW  00
4290:  MOVWF  FF7
4292:  MOVLB  0
4294:  CALL   0212
.................... 			while(TRUE) 
....................               ; 	// Loop forever, program is finished 
4298:  BRA    4298
.................... 			} 
.................... 			else 
429A:  BRA    42A8
.................... 				printf("MMC init failed!\r\n"); 
429C:  MOVLW  74
429E:  MOVWF  FF6
42A0:  MOVLW  00
42A2:  MOVWF  FF7
42A4:  CALL   0212
.................... 				delay_ms(1000); 
42A8:  MOVLW  04
42AA:  MOVLB  4
42AC:  MOVWF  xEB
42AE:  MOVLW  FA
42B0:  MOVLB  5
42B2:  MOVWF  x48
42B4:  MOVLB  0
42B6:  CALL   00E4
42BA:  MOVLB  4
42BC:  DECFSZ xEB,F
42BE:  BRA    42AE
.................... 				printf("Trying once more..\r\n"); 
42C0:  MOVLW  88
42C2:  MOVWF  FF6
42C4:  MOVLW  00
42C6:  MOVWF  FF7
42C8:  MOVLB  0
42CA:  CALL   0212
.................... 		} 
42CE:  BRA    40F2
.................... }                                
42D0:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   IESO FCMEN HS PLL12 CPUDIV4 USBDIV
   Word  2: 1E39   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768 VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
