CCS PCH C Compiler, Version 4.106, 39453               10-mai-12 09:09

               Filename: D:\Fichiers_Divers\DataPic\ex_fat\ex_fat.lst

               ROM used: 27382 bytes (84%)
                         Largest free fragment is 5386
               RAM used: 1385 (68%) at main() level
                         1798 (88%) worst case
               Stack:    17 locations

*
0000:  GOTO   66A8
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                     fat_ex_shell.c                              //// 
.................... ////                                                                 //// 
.................... ////    This is a neat little shell utility that resembles a DOS or  //// 
.................... //// UNIX type shell in order to manipulate files on the FAT file    //// 
.................... //// system. This is mostly for demonstration purposes on how to use //// 
.................... //// some of the basic functionality of the FAT library.             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //These settings are for the CCS PICEEC development kit which contains 
.................... //an MMC/SD connector. 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device PASS_STRINGS = IN_RAM 
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,VREGEN 
.................... #use delay(clock=20M) 
*
056A:  MOVLW  06
056C:  MOVWF  FEA
056E:  MOVLW  07
0570:  MOVWF  FE9
0572:  MOVF   FEF,W
0574:  BZ    0590
0576:  MOVLW  06
0578:  MOVWF  01
057A:  CLRF   00
057C:  DECFSZ 00,F
057E:  BRA    057C
0580:  DECFSZ 01,F
0582:  BRA    057A
0584:  MOVLW  7B
0586:  MOVWF  00
0588:  DECFSZ 00,F
058A:  BRA    0588
058C:  DECFSZ FEF,F
058E:  BRA    0576
0590:  RETLW  00
....................  
.................... #use rs232(baud=9600, UART1, errors) 
*
12F0:  BTFSS  F9E.5
12F2:  BRA    12F0
12F4:  MOVFF  FAB,04
12F8:  MOVFF  FAE,01
12FC:  BTFSS  04.1
12FE:  BRA    1304
1300:  BCF    FAB.4
1302:  BSF    FAB.4
1304:  GOTO   684E (RETURN)
1308:  BTFSS  F9E.4
130A:  BRA    1308
130C:  MOVWF  FAD
130E:  RETLW  00
....................  
.................... #include <stdlib.h> // for atoi32 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
15AE:  MOVFF  5A8,5AC
15B2:  MOVFF  5A7,5AB
15B6:  MOVFF  5AC,03
15BA:  MOVLB  5
15BC:  MOVFF  5AB,FE9
15C0:  MOVFF  5AC,FEA
15C4:  MOVF   FEF,F
15C6:  BZ    15D4
15C8:  INCF   xAB,F
15CA:  BTFSC  FD8.2
15CC:  INCF   xAC,F
15CE:  MOVLB  0
15D0:  BRA    15B6
15D2:  MOVLB  5
....................    while(*s2 != '\0') 
....................    { 
15D4:  MOVFF  5AA,03
15D8:  MOVFF  5A9,FE9
15DC:  MOVFF  5AA,FEA
15E0:  MOVF   FEF,F
15E2:  BZ    160A
....................       *s = *s2; 
15E4:  MOVFF  5A9,FE9
15E8:  MOVFF  5AA,FEA
15EC:  MOVFF  FEF,5AF
15F0:  MOVFF  5AC,FEA
15F4:  MOVFF  5AB,FE9
15F8:  MOVFF  5AF,FEF
....................       ++s; 
15FC:  INCF   xAB,F
15FE:  BTFSC  FD8.2
1600:  INCF   xAC,F
....................       ++s2; 
1602:  INCF   xA9,F
1604:  BTFSC  FD8.2
1606:  INCF   xAA,F
....................    } 
1608:  BRA    15D4
....................  
....................    *s = '\0'; 
160A:  MOVFF  5AB,FE9
160E:  MOVFF  5AC,FEA
1612:  CLRF   FEF
....................    return(s1); 
1614:  MOVFF  5A7,01
1618:  MOVFF  5A8,02
.................... } 
161C:  MOVLB  0
161E:  RETLW  00
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
1DC4:  MOVLB  6
1DC6:  MOVFF  67D,FE9
1DCA:  MOVFF  67E,FEA
1DCE:  MOVFF  FEF,681
1DD2:  MOVFF  680,03
1DD6:  MOVFF  67F,FE9
1DDA:  MOVFF  680,FEA
1DDE:  MOVF   FEF,W
1DE0:  SUBWF  x81,W
1DE2:  BNZ   1E0E
....................       if (*s1 == '\0') 
1DE4:  MOVFF  67E,03
1DE8:  MOVFF  67D,FE9
1DEC:  MOVFF  03,FEA
1DF0:  MOVF   FEF,F
1DF2:  BNZ   1DFA
....................          return(0); 
1DF4:  MOVLW  00
1DF6:  MOVWF  01
1DF8:  BRA    1E38
1DFA:  MOVFF  67E,03
1DFE:  MOVF   x7D,W
1E00:  INCF   x7D,F
1E02:  BTFSC  FD8.2
1E04:  INCF   x7E,F
1E06:  INCF   x7F,F
1E08:  BTFSC  FD8.2
1E0A:  INCF   x80,F
1E0C:  BRA    1DC6
....................    return((*s1 < *s2) ? -1: 1); 
1E0E:  MOVFF  67E,03
1E12:  MOVFF  67D,FE9
1E16:  MOVFF  67E,FEA
1E1A:  MOVFF  FEF,681
1E1E:  MOVFF  680,03
1E22:  MOVFF  67F,FE9
1E26:  MOVFF  680,FEA
1E2A:  MOVF   FEF,W
1E2C:  SUBWF  x81,W
1E2E:  BC    1E34
1E30:  MOVLW  FF
1E32:  BRA    1E36
1E34:  MOVLW  01
1E36:  MOVWF  01
.................... } 
1E38:  MOVLB  0
1E3A:  RETLW  00
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
3F24:  MOVFF  65E,03
3F28:  MOVLB  6
3F2A:  MOVFF  65D,FE9
3F2E:  MOVFF  65E,FEA
3F32:  MOVF   x5F,W
3F34:  SUBWF  FEF,W
3F36:  BZ    3F5C
....................       if (*s == '\0') 
3F38:  MOVFF  65E,03
3F3C:  MOVFF  65D,FE9
3F40:  MOVFF  65E,FEA
3F44:  MOVF   FEF,F
3F46:  BNZ   3F50
....................          return(0); 
3F48:  MOVLW  00
3F4A:  MOVWF  01
3F4C:  MOVWF  02
3F4E:  BRA    3F64
3F50:  INCF   x5D,F
3F52:  BTFSC  FD8.2
3F54:  INCF   x5E,F
3F56:  MOVLB  0
3F58:  BRA    3F24
3F5A:  MOVLB  6
....................    return(s); 
3F5C:  MOVFF  65D,01
3F60:  MOVFF  65E,02
.................... } 
3F64:  MOVLB  0
3F66:  RETLW  00
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
13A0:  MOVFF  57A,57E
13A4:  MOVFF  579,57D
13A8:  MOVFF  57E,03
13AC:  MOVLB  5
13AE:  MOVFF  57D,FE9
13B2:  MOVFF  57E,FEA
13B6:  MOVF   FEF,F
13B8:  BZ    140E
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
13BA:  MOVFF  57C,580
13BE:  MOVFF  57B,57F
13C2:  MOVFF  580,03
13C6:  MOVFF  57F,FE9
13CA:  MOVFF  580,FEA
13CE:  MOVF   FEF,F
13D0:  BZ    1402
....................          if (*sc1 == *sc2) 
13D2:  MOVFF  57D,FE9
13D6:  MOVFF  57E,FEA
13DA:  MOVFF  FEF,581
13DE:  MOVFF  580,03
13E2:  MOVFF  57F,FE9
13E6:  MOVFF  580,FEA
13EA:  MOVF   FEF,W
13EC:  SUBWF  x81,W
13EE:  BNZ   13FA
....................             return(sc1); 
13F0:  MOVFF  57D,01
13F4:  MOVFF  57E,02
13F8:  BRA    1414
13FA:  INCF   x7F,F
13FC:  BTFSC  FD8.2
13FE:  INCF   x80,F
1400:  BRA    13C2
1402:  INCF   x7D,F
1404:  BTFSC  FD8.2
1406:  INCF   x7E,F
1408:  MOVLB  0
140A:  BRA    13A8
140C:  MOVLB  5
....................    return(0); 
140E:  MOVLW  00
1410:  MOVWF  01
1412:  MOVWF  02
.................... } 
1414:  MOVLB  0
1416:  GOTO   148C (RETURN)
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
*
3E64:  MOVLB  5
3E66:  CLRF   xF2
3E68:  CLRF   xF1
....................    { 
....................       if (*s == c) 
3E6A:  MOVFF  5EF,03
3E6E:  MOVFF  5EE,FE9
3E72:  MOVFF  5EF,FEA
3E76:  MOVF   xF0,W
3E78:  SUBWF  FEF,W
3E7A:  BNZ   3E84
....................          p = s; 
3E7C:  MOVFF  5EF,5F2
3E80:  MOVFF  5EE,5F1
....................       if (*s == '\0') 
3E84:  MOVFF  5EF,03
3E88:  MOVFF  5EE,FE9
3E8C:  MOVFF  5EF,FEA
3E90:  MOVF   FEF,F
3E92:  BNZ   3E9E
....................          return(p); 
3E94:  MOVFF  5F1,01
3E98:  MOVFF  5F2,02
3E9C:  BRA    3EA6
....................    } 
3E9E:  INCF   xEE,F
3EA0:  BTFSC  FD8.2
3EA2:  INCF   xEF,F
3EA4:  BRA    3E6A
.................... } 
3EA6:  MOVLB  0
3EA8:  RETLW  00
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
1310:  MOVFF  57A,57E
1314:  MOVFF  579,57D
1318:  MOVFF  57E,03
131C:  MOVLB  5
131E:  MOVFF  57D,FE9
1322:  MOVFF  57E,FEA
1326:  MOVF   FEF,F
1328:  BZ    138A
....................       for (sc2 = s2; ; sc2++) 
132A:  MOVFF  57C,580
132E:  MOVFF  57B,57F
....................     if (*sc2 == '\0') 
1332:  MOVFF  580,03
1336:  MOVFF  57F,FE9
133A:  MOVFF  580,FEA
133E:  MOVF   FEF,F
1340:  BNZ   1356
....................        return(sc1 - s1); 
1342:  MOVF   x79,W
1344:  SUBWF  x7D,W
1346:  MOVWF  00
1348:  MOVF   x7A,W
134A:  SUBWFB x7E,W
134C:  MOVWF  03
134E:  MOVFF  00,01
1352:  BRA    139A
....................          else if (*sc1 == *sc2) 
1354:  BRA    1376
1356:  MOVFF  57D,FE9
135A:  MOVFF  57E,FEA
135E:  MOVFF  FEF,581
1362:  MOVFF  580,03
1366:  MOVFF  57F,FE9
136A:  MOVFF  580,FEA
136E:  MOVF   FEF,W
1370:  SUBWF  x81,W
1372:  BNZ   1376
....................             break; 
1374:  BRA    137E
1376:  INCF   x7F,F
1378:  BTFSC  FD8.2
137A:  INCF   x80,F
137C:  BRA    1332
137E:  INCF   x7D,F
1380:  BTFSC  FD8.2
1382:  INCF   x7E,F
1384:  MOVLB  0
1386:  BRA    1318
1388:  MOVLB  5
....................    return(sc1 - s1); 
138A:  MOVF   x79,W
138C:  SUBWF  x7D,W
138E:  MOVWF  00
1390:  MOVF   x7A,W
1392:  SUBWFB x7E,W
1394:  MOVWF  03
1396:  MOVFF  00,01
.................... } 
139A:  MOVLB  0
139C:  GOTO   144A (RETURN)
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
*
4CFC:  MOVFF  5A8,03
4D00:  MOVLB  5
4D02:  MOVFF  5A7,FE9
4D06:  MOVFF  5A8,FEA
4D0A:  MOVF   FEF,F
4D0C:  BZ    4D80
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
4D0E:  MOVFF  5A8,5AC
4D12:  MOVFF  5A7,5AB
4D16:  MOVFF  5AA,5AE
4D1A:  MOVFF  5A9,5AD
4D1E:  MOVFF  5AE,03
4D22:  MOVFF  5AD,FE9
4D26:  MOVFF  5AE,FEA
4D2A:  MOVF   FEF,F
4D2C:  BZ    4D5A
4D2E:  MOVFF  5AB,FE9
4D32:  MOVFF  5AC,FEA
4D36:  MOVFF  FEF,5AF
4D3A:  MOVFF  5AE,03
4D3E:  MOVFF  5AD,FE9
4D42:  MOVFF  5AE,FEA
4D46:  MOVF   FEF,W
4D48:  SUBWF  xAF,W
4D4A:  BNZ   4D5A
4D4C:  INCF   xAB,F
4D4E:  BTFSC  FD8.2
4D50:  INCF   xAC,F
4D52:  INCF   xAD,F
4D54:  BTFSC  FD8.2
4D56:  INCF   xAE,F
4D58:  BRA    4D1E
....................  
....................       if (*t == '\0') 
4D5A:  MOVFF  5AE,03
4D5E:  MOVFF  5AD,FE9
4D62:  MOVFF  5AE,FEA
4D66:  MOVF   FEF,F
4D68:  BNZ   4D74
....................          return s1; 
4D6A:  MOVFF  5A7,01
4D6E:  MOVFF  5A8,02
4D72:  BRA    4D86
....................       ++s1; 
4D74:  INCF   xA7,F
4D76:  BTFSC  FD8.2
4D78:  INCF   xA8,F
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
4D7A:  MOVLB  0
4D7C:  BRA    4CFC
4D7E:  MOVLB  5
....................    return 0; 
4D80:  MOVLW  00
4D82:  MOVWF  01
4D84:  MOVWF  02
.................... } 
4D86:  MOVLB  0
4D88:  GOTO   4DEE (RETURN)
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
141A:  MOVLB  5
141C:  MOVF   x71,W
141E:  IORWF  x72,W
1420:  BZ    142A
1422:  MOVFF  572,03
1426:  MOVF   x71,W
1428:  BRA    1430
142A:  MOVFF  06,03
142E:  MOVF   05,W
1430:  MOVWF  x75
1432:  MOVFF  03,576
....................    beg += strspn(beg, s2); 
1436:  MOVFF  576,57A
143A:  MOVFF  575,579
143E:  MOVFF  574,57C
1442:  MOVFF  573,57B
1446:  MOVLB  0
1448:  BRA    1310
144A:  MOVF   01,W
144C:  MOVLB  5
144E:  ADDWF  x75,F
1450:  MOVLW  00
1452:  ADDWFC x76,F
....................    if (*beg == '\0') 
1454:  MOVFF  576,03
1458:  MOVFF  575,FE9
145C:  MOVFF  576,FEA
1460:  MOVF   FEF,F
1462:  BNZ   1478
....................    { 
....................       *save = ' '; 
1464:  MOVFF  05,FE9
1468:  MOVFF  06,FEA
146C:  MOVLW  20
146E:  MOVWF  FEF
....................       return(0); 
1470:  MOVLW  00
1472:  MOVWF  01
1474:  MOVWF  02
1476:  BRA    14C6
....................    } 
....................    end = strpbrk(beg, s2); 
1478:  MOVFF  576,57A
147C:  MOVFF  575,579
1480:  MOVFF  574,57C
1484:  MOVFF  573,57B
1488:  MOVLB  0
148A:  BRA    13A0
148C:  MOVFF  02,578
1490:  MOVFF  01,577
....................    if (*end != '\0') 
1494:  MOVFF  578,03
1498:  MOVLB  5
149A:  MOVFF  577,FE9
149E:  MOVFF  578,FEA
14A2:  MOVF   FEF,F
14A4:  BZ    14B6
....................    { 
....................       *end = '\0'; 
14A6:  MOVFF  577,FE9
14AA:  MOVFF  578,FEA
14AE:  CLRF   FEF
....................       end++; 
14B0:  INCF   x77,F
14B2:  BTFSC  FD8.2
14B4:  INCF   x78,F
....................    } 
....................    save = end; 
14B6:  MOVFF  578,06
14BA:  MOVFF  577,05
....................    return(beg); 
14BE:  MOVFF  575,01
14C2:  MOVFF  576,02
.................... } 
14C6:  MOVLB  0
14C8:  RETLW  00
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
14F4:  MOVFF  65E,660
14F8:  MOVFF  65D,65F
14FC:  MOVFF  660,03
1500:  MOVLB  6
1502:  MOVFF  65F,FE9
1506:  MOVFF  660,FEA
150A:  MOVF   FEF,F
150C:  BZ    151A
150E:  INCF   x5F,F
1510:  BTFSC  FD8.2
1512:  INCF   x60,F
1514:  MOVLB  0
1516:  BRA    14FC
1518:  MOVLB  6
....................    return(sc - s); 
151A:  MOVF   x5D,W
151C:  SUBWF  x5F,W
151E:  MOVWF  00
1520:  MOVF   x5E,W
1522:  SUBWFB x60,W
1524:  MOVWF  03
1526:  MOVFF  00,01
.................... } 
152A:  MOVLB  0
152C:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
1620:  MOVLB  5
1622:  MOVFF  572,FE9
1626:  MOVFF  573,FEA
162A:  MOVFF  FEF,576
162E:  MOVFF  575,03
1632:  MOVFF  574,FE9
1636:  MOVFF  575,FEA
163A:  MOVF   FEF,W
163C:  SUBWF  x76,W
163E:  BZ    16D0
1640:  MOVFF  573,03
1644:  MOVFF  572,FE9
1648:  MOVFF  573,FEA
164C:  MOVFF  FEF,576
1650:  MOVF   x76,W
1652:  SUBLW  40
1654:  BC    165C
1656:  MOVF   x76,W
1658:  SUBLW  5A
165A:  BC    1668
165C:  MOVF   x76,W
165E:  SUBLW  60
1660:  BC    16FA
1662:  MOVF   x76,W
1664:  SUBLW  7A
1666:  BNC   16FA
1668:  MOVFF  575,03
166C:  MOVFF  574,FE9
1670:  MOVFF  575,FEA
1674:  MOVFF  FEF,576
1678:  MOVF   x76,W
167A:  SUBLW  40
167C:  BC    1684
167E:  MOVF   x76,W
1680:  SUBLW  5A
1682:  BC    1690
1684:  MOVF   x76,W
1686:  SUBLW  60
1688:  BC    16FA
168A:  MOVF   x76,W
168C:  SUBLW  7A
168E:  BNC   16FA
1690:  MOVFF  572,FE9
1694:  MOVFF  573,FEA
1698:  MOVFF  FEF,576
169C:  MOVFF  575,03
16A0:  MOVFF  574,FE9
16A4:  MOVFF  575,FEA
16A8:  MOVLW  20
16AA:  ADDWF  FEF,W
16AC:  SUBWF  x76,W
16AE:  BZ    16D0
16B0:  MOVFF  574,FE9
16B4:  MOVFF  575,FEA
16B8:  MOVFF  FEF,576
16BC:  MOVFF  573,03
16C0:  MOVFF  572,FE9
16C4:  MOVFF  573,FEA
16C8:  MOVLW  20
16CA:  ADDWF  FEF,W
16CC:  SUBWF  x76,W
16CE:  BNZ   16FA
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
16D0:  MOVFF  573,03
16D4:  MOVFF  572,FE9
16D8:  MOVFF  573,FEA
16DC:  MOVF   FEF,F
16DE:  BNZ   16E6
....................        return(0); 
16E0:  MOVLW  00
16E2:  MOVWF  01
16E4:  BRA    1724
16E6:  MOVFF  573,03
16EA:  MOVF   x72,W
16EC:  INCF   x72,F
16EE:  BTFSC  FD8.2
16F0:  INCF   x73,F
16F2:  INCF   x74,F
16F4:  BTFSC  FD8.2
16F6:  INCF   x75,F
16F8:  BRA    1622
....................  return((*s1 < *s2) ? -1: 1); 
16FA:  MOVFF  573,03
16FE:  MOVFF  572,FE9
1702:  MOVFF  573,FEA
1706:  MOVFF  FEF,576
170A:  MOVFF  575,03
170E:  MOVFF  574,FE9
1712:  MOVFF  575,FEA
1716:  MOVF   FEF,W
1718:  SUBWF  x76,W
171A:  BC    1720
171C:  MOVLW  FF
171E:  BRA    1722
1720:  MOVLW  01
1722:  MOVWF  01
.................... } 
1724:  MOVLB  0
1726:  GOTO   1772 (RETURN)
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
5C5E:  MOVLB  5
5C60:  CLRF   x73
....................    sign = 0; 
5C62:  CLRF   x71
....................    base = 10; 
5C64:  MOVLW  0A
5C66:  MOVWF  x72
....................    result = 0; 
5C68:  CLRF   x70
5C6A:  CLRF   x6F
5C6C:  CLRF   x6E
5C6E:  CLRF   x6D
....................  
....................    if (!s) 
5C70:  MOVF   x6B,W
5C72:  IORWF  x6C,W
5C74:  BNZ   5C80
....................       return 0; 
5C76:  CLRF   00
5C78:  CLRF   01
5C7A:  CLRF   02
5C7C:  CLRF   03
5C7E:  BRA    5EFA
....................    c = s[index++]; 
5C80:  MOVF   x73,W
5C82:  INCF   x73,F
5C84:  CLRF   03
5C86:  ADDWF  x6B,W
5C88:  MOVWF  FE9
5C8A:  MOVF   x6C,W
5C8C:  ADDWFC 03,W
5C8E:  MOVWF  FEA
5C90:  MOVFF  FEF,574
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
5C94:  MOVF   x74,W
5C96:  SUBLW  2D
5C98:  BNZ   5CB4
....................    { 
....................       sign = 1;         // Set the sign to negative 
5C9A:  MOVLW  01
5C9C:  MOVWF  x71
....................       c = s[index++]; 
5C9E:  MOVF   x73,W
5CA0:  INCF   x73,F
5CA2:  CLRF   03
5CA4:  ADDWF  x6B,W
5CA6:  MOVWF  FE9
5CA8:  MOVF   x6C,W
5CAA:  ADDWFC 03,W
5CAC:  MOVWF  FEA
5CAE:  MOVFF  FEF,574
....................    } 
....................    else if (c == '+') 
5CB2:  BRA    5CCE
5CB4:  MOVF   x74,W
5CB6:  SUBLW  2B
5CB8:  BNZ   5CCE
....................    { 
....................       c = s[index++]; 
5CBA:  MOVF   x73,W
5CBC:  INCF   x73,F
5CBE:  CLRF   03
5CC0:  ADDWF  x6B,W
5CC2:  MOVWF  FE9
5CC4:  MOVF   x6C,W
5CC6:  ADDWFC 03,W
5CC8:  MOVWF  FEA
5CCA:  MOVFF  FEF,574
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
5CCE:  MOVF   x74,W
5CD0:  SUBLW  2F
5CD2:  BTFSC  FD8.0
5CD4:  BRA    5ECA
5CD6:  MOVF   x74,W
5CD8:  SUBLW  39
5CDA:  BTFSS  FD8.0
5CDC:  BRA    5ECA
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
5CDE:  MOVF   x74,W
5CE0:  SUBLW  30
5CE2:  BNZ   5D26
5CE4:  CLRF   03
5CE6:  MOVF   x73,W
5CE8:  ADDWF  x6B,W
5CEA:  MOVWF  FE9
5CEC:  MOVF   x6C,W
5CEE:  ADDWFC 03,W
5CF0:  MOVWF  FEA
5CF2:  MOVF   FEF,W
5CF4:  SUBLW  78
5CF6:  BZ    5D0C
5CF8:  CLRF   03
5CFA:  MOVF   x73,W
5CFC:  ADDWF  x6B,W
5CFE:  MOVWF  FE9
5D00:  MOVF   x6C,W
5D02:  ADDWFC 03,W
5D04:  MOVWF  FEA
5D06:  MOVF   FEF,W
5D08:  SUBLW  58
5D0A:  BNZ   5D26
....................       { 
....................          base = 16; 
5D0C:  MOVLW  10
5D0E:  MOVWF  x72
....................          index++; 
5D10:  INCF   x73,F
....................          c = s[index++]; 
5D12:  MOVF   x73,W
5D14:  INCF   x73,F
5D16:  CLRF   03
5D18:  ADDWF  x6B,W
5D1A:  MOVWF  FE9
5D1C:  MOVF   x6C,W
5D1E:  ADDWFC 03,W
5D20:  MOVWF  FEA
5D22:  MOVFF  FEF,574
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
5D26:  MOVF   x72,W
5D28:  SUBLW  0A
5D2A:  BNZ   5DB4
....................       { 
....................          while (c >= '0' && c <= '9') { 
5D2C:  MOVF   x74,W
5D2E:  SUBLW  2F
5D30:  BC    5DB2
5D32:  MOVF   x74,W
5D34:  SUBLW  39
5D36:  BNC   5DB2
....................             result = (result << 1) + (result << 3);  // result *= 10; 
5D38:  BCF    FD8.0
5D3A:  RLCF   x6D,W
5D3C:  MOVWF  x76
5D3E:  RLCF   x6E,W
5D40:  MOVWF  x77
5D42:  RLCF   x6F,W
5D44:  MOVWF  x78
5D46:  RLCF   x70,W
5D48:  MOVWF  x79
5D4A:  RLCF   x6D,W
5D4C:  MOVWF  00
5D4E:  RLCF   x6E,W
5D50:  MOVWF  01
5D52:  RLCF   x6F,W
5D54:  MOVWF  02
5D56:  RLCF   x70,W
5D58:  MOVWF  03
5D5A:  RLCF   00,F
5D5C:  RLCF   01,F
5D5E:  RLCF   02,F
5D60:  RLCF   03,F
5D62:  RLCF   00,F
5D64:  RLCF   01,F
5D66:  RLCF   02,F
5D68:  RLCF   03,F
5D6A:  MOVLW  F8
5D6C:  ANDWF  00,F
5D6E:  MOVF   x76,W
5D70:  ADDWF  00,F
5D72:  MOVF   x77,W
5D74:  ADDWFC 01,F
5D76:  MOVF   x78,W
5D78:  ADDWFC 02,F
5D7A:  MOVF   x79,W
5D7C:  ADDWFC 03,F
5D7E:  MOVFF  03,570
5D82:  MOVFF  02,56F
5D86:  MOVFF  01,56E
5D8A:  MOVFF  00,56D
....................             result += (c - '0'); 
5D8E:  MOVLW  30
5D90:  SUBWF  x74,W
5D92:  ADDWF  x6D,F
5D94:  MOVLW  00
5D96:  ADDWFC x6E,F
5D98:  ADDWFC x6F,F
5D9A:  ADDWFC x70,F
....................             c = s[index++]; 
5D9C:  MOVF   x73,W
5D9E:  INCF   x73,F
5DA0:  CLRF   03
5DA2:  ADDWF  x6B,W
5DA4:  MOVWF  FE9
5DA6:  MOVF   x6C,W
5DA8:  ADDWFC 03,W
5DAA:  MOVWF  FEA
5DAC:  MOVFF  FEF,574
....................          } 
5DB0:  BRA    5D2C
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
5DB2:  BRA    5ECA
5DB4:  MOVF   x72,W
5DB6:  SUBLW  10
5DB8:  BTFSS  FD8.2
5DBA:  BRA    5ECA
....................       { 
....................          c = toupper(c); 
5DBC:  MOVF   x74,W
5DBE:  SUBLW  60
5DC0:  BC    5DCE
5DC2:  MOVF   x74,W
5DC4:  SUBLW  7A
5DC6:  BNC   5DCE
5DC8:  MOVF   x74,W
5DCA:  ANDLW  DF
5DCC:  BRA    5DD0
5DCE:  MOVF   x74,W
5DD0:  MOVWF  x74
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
5DD2:  MOVF   x74,W
5DD4:  SUBLW  2F
5DD6:  BC    5DDE
5DD8:  MOVF   x74,W
5DDA:  SUBLW  39
5DDC:  BC    5DEC
5DDE:  MOVF   x74,W
5DE0:  SUBLW  40
5DE2:  BTFSC  FD8.0
5DE4:  BRA    5ECA
5DE6:  MOVF   x74,W
5DE8:  SUBLW  46
5DEA:  BNC   5ECA
....................             if (c >= '0' && c <= '9') 
5DEC:  MOVF   x74,W
5DEE:  SUBLW  2F
5DF0:  BC    5E4C
5DF2:  MOVF   x74,W
5DF4:  SUBLW  39
5DF6:  BNC   5E4C
....................                result = (result << 4) + (c - '0'); 
5DF8:  RLCF   x6D,W
5DFA:  MOVWF  x76
5DFC:  RLCF   x6E,W
5DFE:  MOVWF  x77
5E00:  RLCF   x6F,W
5E02:  MOVWF  x78
5E04:  RLCF   x70,W
5E06:  MOVWF  x79
5E08:  RLCF   x76,F
5E0A:  RLCF   x77,F
5E0C:  RLCF   x78,F
5E0E:  RLCF   x79,F
5E10:  RLCF   x76,F
5E12:  RLCF   x77,F
5E14:  RLCF   x78,F
5E16:  RLCF   x79,F
5E18:  RLCF   x76,F
5E1A:  RLCF   x77,F
5E1C:  RLCF   x78,F
5E1E:  RLCF   x79,F
5E20:  MOVLW  F0
5E22:  ANDWF  x76,F
5E24:  MOVLW  30
5E26:  SUBWF  x74,W
5E28:  ADDWF  x76,W
5E2A:  MOVWF  00
5E2C:  MOVLW  00
5E2E:  ADDWFC x77,W
5E30:  MOVWF  01
5E32:  MOVLW  00
5E34:  ADDWFC x78,W
5E36:  MOVWF  02
5E38:  MOVLW  00
5E3A:  ADDWFC x79,W
5E3C:  MOVWF  x70
5E3E:  MOVFF  02,56F
5E42:  MOVFF  01,56E
5E46:  MOVFF  00,56D
....................             else 
5E4A:  BRA    5EA0
....................                result = (result << 4) + (c - 'A' + 10); 
5E4C:  RLCF   x6D,W
5E4E:  MOVWF  x76
5E50:  RLCF   x6E,W
5E52:  MOVWF  x77
5E54:  RLCF   x6F,W
5E56:  MOVWF  x78
5E58:  RLCF   x70,W
5E5A:  MOVWF  x79
5E5C:  RLCF   x76,F
5E5E:  RLCF   x77,F
5E60:  RLCF   x78,F
5E62:  RLCF   x79,F
5E64:  RLCF   x76,F
5E66:  RLCF   x77,F
5E68:  RLCF   x78,F
5E6A:  RLCF   x79,F
5E6C:  RLCF   x76,F
5E6E:  RLCF   x77,F
5E70:  RLCF   x78,F
5E72:  RLCF   x79,F
5E74:  MOVLW  F0
5E76:  ANDWF  x76,F
5E78:  MOVLW  41
5E7A:  SUBWF  x74,W
5E7C:  ADDLW  0A
5E7E:  ADDWF  x76,W
5E80:  MOVWF  00
5E82:  MOVLW  00
5E84:  ADDWFC x77,W
5E86:  MOVWF  01
5E88:  MOVLW  00
5E8A:  ADDWFC x78,W
5E8C:  MOVWF  02
5E8E:  MOVLW  00
5E90:  ADDWFC x79,W
5E92:  MOVWF  x70
5E94:  MOVFF  02,56F
5E98:  MOVFF  01,56E
5E9C:  MOVFF  00,56D
....................  
....................             c = s[index++];c = toupper(c); 
5EA0:  MOVF   x73,W
5EA2:  INCF   x73,F
5EA4:  CLRF   03
5EA6:  ADDWF  x6B,W
5EA8:  MOVWF  FE9
5EAA:  MOVF   x6C,W
5EAC:  ADDWFC 03,W
5EAE:  MOVWF  FEA
5EB0:  MOVF   FEF,W
5EB2:  MOVWF  x74
5EB4:  SUBLW  60
5EB6:  BC    5EC4
5EB8:  MOVF   x74,W
5EBA:  SUBLW  7A
5EBC:  BNC   5EC4
5EBE:  MOVF   x74,W
5EC0:  ANDLW  DF
5EC2:  BRA    5EC6
5EC4:  MOVF   x74,W
5EC6:  MOVWF  x74
....................          } 
5EC8:  BRA    5DD2
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
5ECA:  MOVF   x72,W
5ECC:  SUBLW  0A
5ECE:  BNZ   5EEA
5ED0:  DECFSZ x71,W
5ED2:  BRA    5EEA
....................       result = -result; 
5ED4:  COMF   x6D,F
5ED6:  COMF   x6E,F
5ED8:  COMF   x6F,F
5EDA:  COMF   x70,F
5EDC:  INCF   x6D,F
5EDE:  BTFSC  FD8.2
5EE0:  INCF   x6E,F
5EE2:  BTFSC  FD8.2
5EE4:  INCF   x6F,F
5EE6:  BTFSC  FD8.2
5EE8:  INCF   x70,F
....................  
....................    return(result); 
5EEA:  MOVFF  56D,00
5EEE:  MOVFF  56E,01
5EF2:  MOVFF  56F,02
5EF6:  MOVFF  570,03
.................... } 
5EFA:  MOVLB  0
5EFC:  GOTO   657E (RETURN)
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //media library, a compatable media library is required for FAT. 
.................... #use fast_io(d) 
.................... #define MMCSD_PIN_SCL     PIN_D0 //o 
.................... #define MMCSD_PIN_SDI     PIN_D2 //i 
.................... #define MMCSD_PIN_SDO     PIN_D1 //o 
.................... #define MMCSD_PIN_SELECT  PIN_D3 //o 
.................... #include <mmcsd_mod.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           MMCSD.c                               //// 
.................... ////                                                                 //// 
.................... ////    This is a low-level driver for MMC and SD cards.             //// 
.................... ////                                                                 //// 
.................... //// --User Functions--                                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_init(): Initializes the media.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_byte(a, p)                                           //// 
.................... ////  Reads a byte from the MMC/SD card at location a, saves to      //// 
.................... ////  pointer p.  Returns 0 if OK, non-zero if error.                //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_data(a, n, p)                                        //// 
.................... ////  Reads n bytes of data from the MMC/SD card starting at address //// 
.................... ////  a, saves result to pointer p.  Returns 0 if OK, non-zero if    //// 
.................... ////  error.                                                         //// 
.................... ////                                                                 //// 
.................... //// mmcsd_flush_buffer()                                            //// 
.................... ////  The two user write functions (mmcsd_write_byte() and           //// 
.................... ////  mmcsd_write_data()) maintain a buffer to speed up the writing  //// 
.................... ////  process.  Whenever a read or write is performed, the write     //// 
.................... ////  buffer is loaded with the specified page and only the          //// 
.................... ////  contents of this buffer is changed.  If any future writes      //// 
.................... ////  cross a page boundary then the buffer in RAM is written        //// 
.................... ////  to the MMC/SD and then the next page is loaded into the        //// 
.................... ////  buffer.  mmcsd_flush_buffer() forces the contents in RAM       //// 
.................... ////  to the MMC/SD card.  Returns 0 if OK, non-zero if errror.      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_byte(a, d)                                          //// 
.................... ////  Writes data byte d to the MMC/SD address a.  Intelligently     //// 
.................... ////  manages a write buffer, therefore you may need to call         //// 
.................... ////  mmcsd_flush_buffer() to flush the buffer.                      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_data(a, n, p)                                       //// 
.................... ////  Writes n bytes of data from pointer p to the MMC/SD card       //// 
.................... ////  starting at address a.  This function intelligently manages    //// 
.................... ////  a write buffer, therefore if you may need to call              //// 
.................... ////  mmcsd_flush_buffer() to flush any buffered characters.         //// 
.................... ////  returns 0 if OK, non-zero if error.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_block(a, s, p)                                       //// 
.................... ////  Reads an entire page from the SD/MMC.  Keep in mind that the   //// 
.................... ////  start of the read has to be aligned to a block                 //// 
.................... ////  (Address % 512 = 0).  Therefore s must be evenly divisible by  //// 
.................... ////  512.  At the application level it is much more effecient to    //// 
.................... ////  to use mmcsd_read_data() or mmcsd_read_byte().  Returns 0      //// 
.................... ////  if successful, non-zero if error.                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_block(a, s, p):                                     //// 
.................... ////  Writes an entire page to the SD/MMC.  This will write an       //// 
.................... ////  entire page to the SD/MMC, so the address and size must be     //// 
.................... ////  evenly  divisble by 512.  At the application level it is much  //// 
.................... ////  more effecient to use mmcsd_write_data() or mmcsd_write_byte().//// 
.................... ////  Returns 0 if successful, non-zero if error.                    //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_cid(): Displays all data in the Card Identification //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_csd(): Displays all data in the Card Specific Data  //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// --Non-User Functions--                                          //// 
.................... ////                                                                 //// 
.................... //// mmcsd_go_idle_state(): Sends the GO_IDLE_STATE command to the   //// 
.................... ////                        SD/MMC.                                  //// 
.................... //// mmcsd_send_op_cond(): Sends the SEND_OP_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_send_if_cond(): Sends the SEND_IF_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_sd_status(): Sends the SD_STATUS command to the SD. Note  //// 
.................... ////                     This command only works on SD cards.        //// 
.................... //// mmcsd_send_status(): Sends the SEND_STATUS command to the       //// 
.................... ////                       SD/MMC.                                   //// 
.................... //// mmcsd_set_blocklen(): Sends the SET_BLOCKLEN command along with //// 
.................... ////                        the desired block length.                //// 
.................... //// mmcsd_app_cmd(): Sends the APP_CMD command to the SD. This only //// 
.................... ////                   works on SD cards and is used just before any //// 
.................... ////                   SD-only command (e.g. send_op_cond()).        //// 
.................... //// mmcsd_read_ocr(): Sends the READ_OCR command to the SD/MMC.     //// 
.................... //// mmcsd_crc_on_off(): Sends the CRC_ON_OFF command to the SD/MMC  //// 
.................... ////                      along with a bit to turn the CRC on/off.   //// 
.................... //// mmcsd_send_cmd(): Sends a command and argument to the SD/MMC.   //// 
.................... //// mmcsd_get_r1(): Waits for an R1 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r2(): Waits for an R2 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r3(): Waits for an R3 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r7(): Waits for an R7 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_wait_for_token(): Waits for a specified token from the    //// 
.................... ////                          SD/MMC.                                //// 
.................... //// mmcsd_crc7(): Generates a CRC7 using a pointer to some data,    //// 
.................... ////                and how many bytes long the data is.             //// 
.................... //// mmcsd_crc16(): Generates a CRC16 using a pointer to some data,  //// 
.................... ////                and how many bytes long the data is.             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MMCSD_C 
.................... #define MMCSD_C 
....................  
.................... ///////////////////// 
.................... ////             //// 
.................... //// User Config //// 
.................... ////             //// 
.................... ///////////////////// 
....................  
.................... #include "stdint.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifndef MMCSD_PIN_SCL 
....................  #define MMCSD_PIN_SCL     PIN_C3 //o 
....................  #define MMCSD_PIN_SDI     PIN_C4 //i 
....................  #define MMCSD_PIN_SDO     PIN_C5 //o 
....................  #define MMCSD_PIN_SELECT  PIN_C2 //o 
.................... #endif 
....................  
.................... #use spi(MASTER, DI=MMCSD_PIN_SDI, DO=MMCSD_PIN_SDO, CLK=MMCSD_PIN_SCL, BITS=8, MSB_FIRST, MODE=0, stream=mmcsd_spi) 
*
0512:  MOVLB  6
0514:  MOVF   xFF,W
0516:  SUBLW  08
0518:  BZ    052A
051A:  MOVLB  7
051C:  MOVWF  x00
051E:  MOVLB  6
0520:  RLCF   xFE,F
0522:  MOVLB  7
0524:  DECFSZ x00,F
0526:  BRA    051E
0528:  MOVLB  6
052A:  BCF    F8C.0
052C:  MOVFF  6FF,700
0530:  BTFSS  xFE.7
0532:  BCF    F8C.1
0534:  BTFSC  xFE.7
0536:  BSF    F8C.1
0538:  RLCF   xFE,F
053A:  BSF    F8C.0
053C:  RLCF   01,F
053E:  BTFSS  F83.2
0540:  BCF    01.0
0542:  BTFSC  F83.2
0544:  BSF    01.0
0546:  BCF    F8C.0
0548:  MOVLB  7
054A:  DECFSZ x00,F
054C:  BRA    0550
054E:  BRA    0554
0550:  MOVLB  6
0552:  BRA    0530
0554:  MOVLB  0
0556:  RETLW  00
....................  
.................... //////////////////////// 
.................... ////                //// 
.................... //// Useful Defines //// 
.................... ////                //// 
.................... //////////////////////// 
....................  
.................... enum MMCSD_err 
....................    {MMCSD_GOODEC = 0, 
....................    MMCSD_IDLE = 0x01, 
....................    MMCSD_ERASE_RESET = 0x02, 
....................    MMCSD_ILLEGAL_CMD = 0x04, 
....................    MMCSD_CRC_ERR = 0x08, 
....................    MMCSD_ERASE_SEQ_ERR = 0x10, 
....................    MMCSD_ADDR_ERR = 0x20, 
....................    MMCSD_PARAM_ERR = 0x40, 
....................    RESP_TIMEOUT = 0x80}; 
....................  
.................... #define GO_IDLE_STATE 0 
.................... #define SEND_OP_COND 1 
.................... #define SEND_IF_COND 8 
.................... #define SEND_CSD 9 
.................... #define SEND_CID 10 
.................... #define SD_STATUS 13 
.................... #define SEND_STATUS 13 
.................... #define SET_BLOCKLEN 16 
.................... #define READ_SINGLE_BLOCK 17 
.................... #define WRITE_BLOCK 24 
.................... #define SD_SEND_OP_COND 41 
.................... #define APP_CMD 55 
.................... #define READ_OCR 58 
.................... #define CRC_ON_OFF 59 
....................  
.................... #define IDLE_TOKEN 0x01 
.................... #define DATA_START_TOKEN 0xFE 
....................  
.................... #define MMCSD_MAX_BLOCK_SIZE 512 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... uint8_t g_mmcsd_buffer[MMCSD_MAX_BLOCK_SIZE]; 
....................  
.................... int1 g_CRC_enabled; 
.................... int1 g_MMCSDBufferChanged; 
....................  
.................... uint32_t g_mmcsdBufferAddress; 
.................... uint32_t g_mmcsdPartitionOffset; 
....................  
.................... enum _card_type{SD, MMC} g_card_type; 
....................  
.................... ///////////////////////////// 
.................... ////                     //// 
.................... //// Function Prototypes //// 
.................... ////                     //// 
.................... ///////////////////////////// 
....................  
.................... MMCSD_err mmcsd_init(); 
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_go_idle_state(void); 
.................... MMCSD_err mmcsd_send_op_cond(void); 
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]); 
.................... MMCSD_err mmcsd_print_csd(); 
.................... MMCSD_err mmcsd_print_cid(); 
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen); 
.................... MMCSD_err mmcsd_read_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_write_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_sd_send_op_cond(void); 
.................... MMCSD_err mmcsd_app_cmd(void); 
.................... MMCSD_err mmcsd_read_ocr(uint8_t* r1); 
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled); 
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg); 
.................... MMCSD_err mmcsd_get_r1(void); 
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]); 
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]); 
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]); 
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token); 
.................... uint8_t mmcsd_crc7(char *data, uint8_t length); 
.................... uint16_t mmcsd_crc16(char *data, uint8_t length); 
.................... void mmcsd_select(); 
.................... void mmcsd_deselect(); 
....................  
.................... /// Fast Functions ! /// 
....................  
.................... MMCSD_err mmcsd_load_buffer(void); 
.................... MMCSD_err mmcsd_flush_buffer(void); 
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr); 
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data); 
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data); 
....................  
.................... ////////////////////////////////// 
.................... ////                          //// 
.................... //// Function Implementations //// 
.................... ////                          //// 
.................... ////////////////////////////////// 
....................  
.................... void mmcsd_check_part(uint16_t off) 
.................... { 
.................... 	if (g_mmcsd_buffer[off + 0] == 0x80) 
*
0968:  MOVLW  0B
096A:  MOVLB  6
096C:  ADDWF  x07,W
096E:  MOVWF  FE9
0970:  MOVLW  00
0972:  ADDWFC x08,W
0974:  MOVWF  FEA
0976:  MOVF   FEF,W
0978:  SUBLW  80
097A:  BNZ   0A3A
.................... 	{ 
.................... 		// active partition  
.................... 		uint8_t t; 
.................... 		t = g_mmcsd_buffer[off + 4]; 
097C:  MOVLW  04
097E:  ADDWF  x07,W
0980:  MOVWF  x0A
0982:  MOVLW  00
0984:  ADDWFC x08,W
0986:  MOVWF  x0B
0988:  MOVLW  0B
098A:  ADDWF  x0A,W
098C:  MOVWF  FE9
098E:  MOVLW  00
0990:  ADDWFC x0B,W
0992:  MOVWF  FEA
0994:  MOVFF  FEF,609
.................... 		if (t == 0x04 || t == 0x06 || t == 0x0B) 
0998:  MOVF   x09,W
099A:  SUBLW  04
099C:  BZ    09AA
099E:  MOVF   x09,W
09A0:  SUBLW  06
09A2:  BZ    09AA
09A4:  MOVF   x09,W
09A6:  SUBLW  0B
09A8:  BNZ   0A3A
.................... 		{ 
.................... 			// FAT16 or FAT32 partition  
.................... 			g_mmcsdPartitionOffset = make32( 
.................... 			g_mmcsd_buffer[off + 11], g_mmcsd_buffer[off + 10], 
.................... 			g_mmcsd_buffer[off + 9], g_mmcsd_buffer[off + 8]) * MMCSD_MAX_BLOCK_SIZE; 
09AA:  MOVLW  0B
09AC:  ADDWF  x07,W
09AE:  MOVWF  x0A
09B0:  MOVLW  00
09B2:  ADDWFC x08,W
09B4:  MOVWF  x0B
09B6:  MOVLW  0B
09B8:  ADDWF  x0A,W
09BA:  MOVWF  FE9
09BC:  MOVLW  00
09BE:  ADDWFC x0B,W
09C0:  MOVWF  FEA
09C2:  MOVFF  FEF,60A
09C6:  MOVLW  0A
09C8:  ADDWF  x07,W
09CA:  MOVWF  x0B
09CC:  MOVLW  00
09CE:  ADDWFC x08,W
09D0:  MOVWF  x0C
09D2:  MOVLW  0B
09D4:  ADDWF  x0B,W
09D6:  MOVWF  FE9
09D8:  MOVLW  00
09DA:  ADDWFC x0C,W
09DC:  MOVWF  FEA
09DE:  MOVFF  FEF,60B
09E2:  MOVLW  09
09E4:  ADDWF  x07,W
09E6:  MOVWF  x0C
09E8:  MOVLW  00
09EA:  ADDWFC x08,W
09EC:  MOVWF  x0D
09EE:  MOVLW  0B
09F0:  ADDWF  x0C,W
09F2:  MOVWF  FE9
09F4:  MOVLW  00
09F6:  ADDWFC x0D,W
09F8:  MOVWF  FEA
09FA:  MOVFF  FEF,60C
09FE:  MOVLW  08
0A00:  ADDWF  x07,W
0A02:  MOVWF  x0D
0A04:  MOVLW  00
0A06:  ADDWFC x08,W
0A08:  MOVWF  x0E
0A0A:  MOVLW  0B
0A0C:  ADDWF  x0D,W
0A0E:  MOVWF  FE9
0A10:  MOVLW  00
0A12:  ADDWFC x0E,W
0A14:  MOVWF  FEA
0A16:  MOVFF  FEF,60D
0A1A:  BCF    FD8.0
0A1C:  MOVLB  2
0A1E:  CLRF   x10
0A20:  MOVLB  6
0A22:  RLCF   x0D,W
0A24:  MOVLB  2
0A26:  MOVWF  x11
0A28:  MOVLB  6
0A2A:  RLCF   x0C,W
0A2C:  MOVLB  2
0A2E:  MOVWF  x12
0A30:  MOVLB  6
0A32:  RLCF   x0B,W
0A34:  MOVLB  2
0A36:  MOVWF  x13
0A38:  MOVLB  6
.................... 		} 
.................... 	} 
.................... } 
0A3A:  MOVLB  0
0A3C:  RETLW  00
....................  
.................... MMCSD_err mmcsd_init() 
.................... { 
....................    uint8_t 
....................       i, 
....................       r1; 
....................  
....................    g_CRC_enabled = TRUE; 
0A3E:  MOVLB  2
0A40:  BSF    x0B.0
....................    g_mmcsdBufferAddress = 0; 
0A42:  CLRF   x0F
0A44:  CLRF   x0E
0A46:  CLRF   x0D
0A48:  CLRF   x0C
....................  
....................    output_drive(MMCSD_PIN_SCL); 
0A4A:  BCF    F95.0
....................    output_drive(MMCSD_PIN_SDO); 
0A4C:  BCF    F95.1
....................    output_drive(MMCSD_PIN_SELECT); 
0A4E:  BCF    F95.3
....................    output_float(MMCSD_PIN_SDI); 
0A50:  BSF    F95.2
....................  
....................    mmcsd_deselect(); 
0A52:  MOVLB  0
0A54:  RCALL  0558
....................    delay_ms(15); 
0A56:  MOVLW  0F
0A58:  MOVLB  6
0A5A:  MOVWF  x07
0A5C:  MOVLB  0
0A5E:  RCALL  056A
....................        
....................    /* begin initialization */ 
....................    i = 0; 
0A60:  MOVLB  6
0A62:  CLRF   x05
....................    do 
....................    { 
....................       delay_ms(1); 
0A64:  MOVLW  01
0A66:  MOVWF  x07
0A68:  MOVLB  0
0A6A:  RCALL  056A
....................       mmcsd_select();       
0A6C:  RCALL  0592
....................       r1=mmcsd_go_idle_state(); 
0A6E:  BRA    06C0
0A70:  MOVFF  01,606
....................       mmcsd_deselect(); 
0A74:  RCALL  0558
....................       i++; 
0A76:  MOVLB  6
0A78:  INCF   x05,F
....................       if(i == 0xFF) 
0A7A:  INCFSZ x05,W
0A7C:  BRA    0A8A
....................       { 
....................          mmcsd_deselect(); 
0A7E:  MOVLB  0
0A80:  RCALL  0558
....................          return r1; 
0A82:  MOVLB  6
0A84:  MOVFF  606,01
0A88:  BRA    0B7E
....................       } 
....................    } while(!bit_test(r1, 0)); 
0A8A:  BTFSS  x06.0
0A8C:  BRA    0A64
....................  
....................    i = 0; 
0A8E:  CLRF   x05
....................    do 
....................    { 
....................       delay_ms(1); 
0A90:  MOVLW  01
0A92:  MOVWF  x07
0A94:  MOVLB  0
0A96:  RCALL  056A
....................       mmcsd_select(); 
0A98:  RCALL  0592
....................       r1=mmcsd_send_op_cond(); 
0A9A:  BRA    06D8
0A9C:  MOVFF  01,606
....................       mmcsd_deselect(); 
0AA0:  RCALL  0558
....................       i++; 
0AA2:  MOVLB  6
0AA4:  INCF   x05,F
....................       if(i == 0xFF) 
0AA6:  INCFSZ x05,W
0AA8:  BRA    0AB6
....................       { 
....................          mmcsd_deselect(); 
0AAA:  MOVLB  0
0AAC:  RCALL  0558
....................          return r1; 
0AAE:  MOVLB  6
0AB0:  MOVFF  606,01
0AB4:  BRA    0B7E
....................       } 
....................    } while(r1 & MMCSD_IDLE); 
0AB6:  BTFSC  x06.0
0AB8:  BRA    0A90
....................  
....................    /* figure out if we have an SD or MMC */ 
....................    mmcsd_select(); 
0ABA:  MOVLB  0
0ABC:  RCALL  0592
....................    r1=mmcsd_app_cmd(); 
0ABE:  BRA    06F2
0AC0:  MOVFF  01,606
....................    r1=mmcsd_sd_send_op_cond(); 
0AC4:  BRA    070C
0AC6:  MOVFF  01,606
....................    mmcsd_deselect(); 
0ACA:  RCALL  0558
....................  
....................    /* an mmc will return an 0x04 here */ 
....................    if(r1 == 0x04) 
0ACC:  MOVLB  6
0ACE:  MOVF   x06,W
0AD0:  SUBLW  04
0AD2:  BNZ   0ADA
....................       g_card_type = MMC; 
0AD4:  MOVLB  2
0AD6:  BSF    x0B.2
....................    else 
0AD8:  BRA    0ADE
....................       g_card_type = SD; 
0ADA:  MOVLB  2
0ADC:  BCF    x0B.2
....................  
....................    /* set block length to 512 bytes */ 
....................    mmcsd_select(); 
0ADE:  MOVLB  0
0AE0:  RCALL  0592
....................    r1 = mmcsd_set_blocklen(MMCSD_MAX_BLOCK_SIZE); 
0AE2:  MOVLB  6
0AE4:  CLRF   x0A
0AE6:  CLRF   x09
0AE8:  MOVLW  02
0AEA:  MOVWF  x08
0AEC:  CLRF   x07
0AEE:  MOVLB  0
0AF0:  BRA    0726
0AF2:  MOVFF  01,606
....................    if(r1 != MMCSD_GOODEC) 
0AF6:  MOVLB  6
0AF8:  MOVF   x06,F
0AFA:  BZ    0B08
....................    { 
....................       mmcsd_deselect(); 
0AFC:  MOVLB  0
0AFE:  RCALL  0558
....................       return r1; 
0B00:  MOVLB  6
0B02:  MOVFF  606,01
0B06:  BRA    0B7E
....................    } 
....................    mmcsd_deselect(); 
0B08:  MOVLB  0
0B0A:  RCALL  0558
....................  
....................    /* turn CRCs off to speed up reading/writing */ 
....................    mmcsd_select(); 
0B0C:  RCALL  0592
....................    r1 = mmcsd_crc_on_off(0); 
0B0E:  MOVLB  6
0B10:  CLRF   x07
0B12:  MOVLB  0
0B14:  BRA    0748
0B16:  MOVFF  01,606
....................    if(r1 != MMCSD_GOODEC) 
0B1A:  MOVLB  6
0B1C:  MOVF   x06,F
0B1E:  BZ    0B2C
....................    { 
....................       mmcsd_deselect(); 
0B20:  MOVLB  0
0B22:  RCALL  0558
....................       return r1; 
0B24:  MOVLB  6
0B26:  MOVFF  606,01
0B2A:  BRA    0B7E
....................    } 
....................    mmcsd_deselect(); 
0B2C:  MOVLB  0
0B2E:  RCALL  0558
....................  
....................    r1 = mmcsd_load_buffer(); 
0B30:  RCALL  093E
0B32:  MOVFF  01,606
....................    g_mmcsdPartitionOffset = 0; 
0B36:  MOVLB  2
0B38:  CLRF   x13
0B3A:  CLRF   x12
0B3C:  CLRF   x11
0B3E:  CLRF   x10
.................... 	mmcsd_check_part(0x1EE); 
0B40:  MOVLW  01
0B42:  MOVLB  6
0B44:  MOVWF  x08
0B46:  MOVLW  EE
0B48:  MOVWF  x07
0B4A:  MOVLB  0
0B4C:  RCALL  0968
.................... 	mmcsd_check_part(0x1DE); 
0B4E:  MOVLW  01
0B50:  MOVLB  6
0B52:  MOVWF  x08
0B54:  MOVLW  DE
0B56:  MOVWF  x07
0B58:  MOVLB  0
0B5A:  RCALL  0968
.................... 	mmcsd_check_part(0x1CE); 
0B5C:  MOVLW  01
0B5E:  MOVLB  6
0B60:  MOVWF  x08
0B62:  MOVLW  CE
0B64:  MOVWF  x07
0B66:  MOVLB  0
0B68:  RCALL  0968
.................... 	mmcsd_check_part(0x1BE); 
0B6A:  MOVLW  01
0B6C:  MOVLB  6
0B6E:  MOVWF  x08
0B70:  MOVLW  BE
0B72:  MOVWF  x07
0B74:  MOVLB  0
0B76:  RCALL  0968
....................  
....................    return r1; 
0B78:  MOVLB  6
0B7A:  MOVFF  606,01
.................... } 
0B7E:  MOVLB  0
0B80:  GOTO   0F6C (RETURN)
....................  
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err r1; 
....................    uint16_t i;  // counter for loops 
....................  
....................    for(i = 0; i < size; i++) 
*
0DD6:  MOVLB  6
0DD8:  CLRF   xB4
0DDA:  CLRF   xB3
0DDC:  MOVF   xB4,W
0DDE:  SUBWF  xAF,W
0DE0:  BNC   0E5E
0DE2:  BNZ   0DEA
0DE4:  MOVF   xAE,W
0DE6:  SUBWF  xB3,W
0DE8:  BC    0E5E
....................    { 
....................       r1 = mmcsd_read_byte(address++, ptr++); 
0DEA:  MOVFF  6AD,03
0DEE:  MOVFF  6AC,02
0DF2:  MOVFF  6AB,01
0DF6:  MOVFF  6AA,00
0DFA:  MOVLW  01
0DFC:  ADDWF  xAA,F
0DFE:  BTFSC  FD8.0
0E00:  INCF   xAB,F
0E02:  BTFSC  FD8.2
0E04:  INCF   xAC,F
0E06:  BTFSC  FD8.2
0E08:  INCF   xAD,F
0E0A:  MOVFF  03,6B8
0E0E:  MOVFF  02,6B7
0E12:  MOVFF  01,6B6
0E16:  MOVFF  00,6B5
0E1A:  MOVFF  6B1,03
0E1E:  MOVF   xB0,W
0E20:  INCF   xB0,F
0E22:  BTFSC  FD8.2
0E24:  INCF   xB1,F
0E26:  MOVWF  xB9
0E28:  MOVFF  03,6BA
0E2C:  MOVFF  6B8,6BE
0E30:  MOVFF  02,6BD
0E34:  MOVFF  01,6BC
0E38:  MOVFF  00,6BB
0E3C:  MOVFF  03,6C0
0E40:  MOVWF  xBF
0E42:  MOVLB  0
0E44:  BRA    0D84
0E46:  MOVFF  01,6B2
....................       if(r1 != MMCSD_GOODEC) 
0E4A:  MOVLB  6
0E4C:  MOVF   xB2,F
0E4E:  BZ    0E56
....................          return r1; 
0E50:  MOVFF  6B2,01
0E54:  BRA    0E62
....................    } 
0E56:  INCF   xB3,F
0E58:  BTFSC  FD8.2
0E5A:  INCF   xB4,F
0E5C:  BRA    0DDC
....................     
....................    return MMCSD_GOODEC; 
0E5E:  MOVLW  00
0E60:  MOVWF  01
.................... } 
0E62:  MOVLB  0
0E64:  RETLW  00
....................  
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {   
....................    MMCSD_err ec; 
....................    uint16_t i; // counter for loops 
....................  
....................    // send command 
....................    mmcsd_select(); 
*
0828:  RCALL  0592
....................    ec = mmcsd_read_single_block(address); 
082A:  MOVFF  6E7,6F2
082E:  MOVFF  6E6,6F1
0832:  MOVFF  6E5,6F0
0836:  MOVFF  6E4,6EF
083A:  BRA    0776
083C:  MOVFF  01,6EC
....................    if(ec != MMCSD_GOODEC) 
0840:  MOVLB  6
0842:  MOVF   xEC,F
0844:  BZ    0852
....................    { 
....................       mmcsd_deselect(); 
0846:  MOVLB  0
0848:  RCALL  0558
....................       return ec; 
084A:  MOVLB  6
084C:  MOVFF  6EC,01
0850:  BRA    0938
....................    } 
....................     
....................    // wait for the data start token 
....................    ec = mmcsd_wait_for_token(DATA_START_TOKEN); 
0852:  MOVLW  FE
0854:  MOVWF  xEF
0856:  MOVLB  0
0858:  BRA    0798
085A:  MOVFF  01,6EC
....................    if(ec != MMCSD_GOODEC) 
085E:  MOVLB  6
0860:  MOVF   xEC,F
0862:  BZ    0870
....................    { 
....................       mmcsd_deselect(); 
0864:  MOVLB  0
0866:  RCALL  0558
....................       return ec; 
0868:  MOVLB  6
086A:  MOVFF  6EC,01
086E:  BRA    0938
....................    } 
....................     
....................    // read in the data 
....................    for(i = 0; i < size; i += 1) 
0870:  CLRF   xEE
0872:  CLRF   xED
0874:  MOVF   xEE,W
0876:  SUBWF  xE9,W
0878:  BNC   08AC
087A:  BNZ   0882
087C:  MOVF   xE8,W
087E:  SUBWF  xED,W
0880:  BC    08AC
....................       ptr[i] = spi_xfer(mmcsd_spi, 0xFF); 
0882:  MOVF   xEA,W
0884:  ADDWF  xED,W
0886:  MOVWF  FE9
0888:  MOVF   xEB,W
088A:  ADDWFC xEE,W
088C:  MOVWF  FEA
088E:  MOVLW  FF
0890:  MOVWF  xFE
0892:  MOVLW  08
0894:  MOVWF  xFF
0896:  MOVLB  0
0898:  RCALL  0512
089A:  MOVF   01,W
089C:  MOVFF  01,FEF
08A0:  MOVLW  01
08A2:  MOVLB  6
08A4:  ADDWF  xED,F
08A6:  MOVLW  00
08A8:  ADDWFC xEE,F
08AA:  BRA    0874
....................  
....................    if(g_CRC_enabled) 
08AC:  MOVLB  2
08AE:  BTFSS  x0B.0
08B0:  BRA    0912
....................    { 
....................       /* check the crc */ 
....................       if(make16(spi_xfer(mmcsd_spi, 0xFF), spi_xfer(mmcsd_spi, 0xFF)) != mmcsd_crc16(g_mmcsd_buffer, MMCSD_MAX_BLOCK_SIZE)) 
08B2:  MOVLW  FF
08B4:  MOVLB  6
08B6:  MOVWF  xFE
08B8:  MOVLW  08
08BA:  MOVWF  xFF
08BC:  MOVLB  0
08BE:  RCALL  0512
08C0:  MOVF   01,W
08C2:  MOVFF  01,6EF
08C6:  MOVLW  FF
08C8:  MOVLB  6
08CA:  MOVWF  xFE
08CC:  MOVLW  08
08CE:  MOVWF  xFF
08D0:  MOVLB  0
08D2:  RCALL  0512
08D4:  MOVF   01,W
08D6:  MOVFF  01,6F0
08DA:  MOVFF  6EF,6F2
08DE:  MOVFF  01,6F1
08E2:  MOVLB  6
08E4:  CLRF   xF4
08E6:  MOVLW  0B
08E8:  MOVWF  xF3
08EA:  CLRF   xF5
08EC:  MOVLB  0
08EE:  RCALL  07B6
08F0:  MOVFF  02,03
08F4:  MOVF   01,W
08F6:  MOVLB  6
08F8:  SUBWF  xF1,W
08FA:  BNZ   0902
08FC:  MOVF   03,W
08FE:  SUBWF  xF2,W
0900:  BZ    090E
....................       { 
....................          mmcsd_deselect(); 
0902:  MOVLB  0
0904:  RCALL  0558
....................          return MMCSD_CRC_ERR; 
0906:  MOVLW  08
0908:  MOVWF  01
090A:  MOVLB  6
090C:  BRA    0938
....................       } 
....................    } 
....................    else 
090E:  BRA    092E
0910:  MOVLB  2
....................    { 
....................       /* have the card transmit the CRC, but ignore it */ 
....................       spi_xfer(mmcsd_spi, 0xFF); 
0912:  MOVLW  FF
0914:  MOVLB  6
0916:  MOVWF  xFE
0918:  MOVLW  08
091A:  MOVWF  xFF
091C:  MOVLB  0
091E:  RCALL  0512
....................       spi_xfer(mmcsd_spi, 0xFF); 
0920:  MOVLW  FF
0922:  MOVLB  6
0924:  MOVWF  xFE
0926:  MOVLW  08
0928:  MOVWF  xFF
092A:  MOVLB  0
092C:  RCALL  0512
....................    } 
....................    mmcsd_deselect(); 
092E:  MOVLB  0
0930:  RCALL  0558
....................  
....................    return MMCSD_GOODEC; 
0932:  MOVLW  00
0934:  MOVWF  01
0936:  MOVLB  6
.................... } 
0938:  MOVLB  0
093A:  GOTO   0964 (RETURN)
....................  
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err ec; 
....................    uint16_t i;  // counter for loops 
....................    
....................    for(i = 0; i < size; i++) 
*
1EE8:  MOVLB  6
1EEA:  CLRF   xCF
1EEC:  CLRF   xCE
1EEE:  MOVF   xCF,W
1EF0:  SUBWF  xCA,W
1EF2:  BNC   1F72
1EF4:  BNZ   1EFC
1EF6:  MOVF   xC9,W
1EF8:  SUBWF  xCE,W
1EFA:  BC    1F72
....................    { 
....................       ec = mmcsd_write_byte(address++, *ptr++); 
1EFC:  MOVFF  6C8,03
1F00:  MOVFF  6C7,02
1F04:  MOVFF  6C6,01
1F08:  MOVFF  6C5,00
1F0C:  MOVLW  01
1F0E:  ADDWF  xC5,F
1F10:  BTFSC  FD8.0
1F12:  INCF   xC6,F
1F14:  BTFSC  FD8.2
1F16:  INCF   xC7,F
1F18:  BTFSC  FD8.2
1F1A:  INCF   xC8,F
1F1C:  MOVFF  03,6D3
1F20:  MOVFF  02,6D2
1F24:  MOVFF  01,6D1
1F28:  MOVFF  00,6D0
1F2C:  MOVFF  6CC,03
1F30:  MOVF   xCB,W
1F32:  INCF   xCB,F
1F34:  BTFSC  FD8.2
1F36:  INCF   xCC,F
1F38:  MOVWF  FE9
1F3A:  MOVFF  03,FEA
1F3E:  MOVFF  FEF,6D4
1F42:  MOVFF  6D3,6D8
1F46:  MOVFF  02,6D7
1F4A:  MOVFF  01,6D6
1F4E:  MOVFF  00,6D5
1F52:  MOVFF  6D4,6D9
1F56:  MOVLB  0
1F58:  BRA    1E9A
1F5A:  MOVFF  01,6CD
....................       if(ec != MMCSD_GOODEC) 
1F5E:  MOVLB  6
1F60:  MOVF   xCD,F
1F62:  BZ    1F6A
....................          return ec; 
1F64:  MOVFF  6CD,01
1F68:  BRA    1F76
....................    } 
1F6A:  INCF   xCE,F
1F6C:  BTFSC  FD8.2
1F6E:  INCF   xCF,F
1F70:  BRA    1EEE
....................     
....................    return MMCSD_GOODEC; 
1F72:  MOVLW  00
1F74:  MOVWF  01
.................... } 
1F76:  MOVLB  0
1F78:  RETLW  00
....................  
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {  
....................    MMCSD_err ec; 
....................    uint16_t i; 
....................  
....................    // send command 
....................    mmcsd_select(); 
*
0BA6:  RCALL  0592
....................    ec = mmcsd_write_single_block(address); 
0BA8:  MOVFF  6E7,6F2
0BAC:  MOVFF  6E6,6F1
0BB0:  MOVFF  6E5,6F0
0BB4:  MOVFF  6E4,6EF
0BB8:  BRA    0B84
0BBA:  MOVFF  01,6EC
....................    if(ec != MMCSD_GOODEC) 
0BBE:  MOVLB  6
0BC0:  MOVF   xEC,F
0BC2:  BZ    0BD0
....................    { 
....................       mmcsd_deselect(); 
0BC4:  MOVLB  0
0BC6:  RCALL  0558
....................       return ec; 
0BC8:  MOVLB  6
0BCA:  MOVFF  6EC,01
0BCE:  BRA    0C9C
....................    } 
....................     
....................    // send a data start token 
....................    spi_xfer(mmcsd_spi, DATA_START_TOKEN); 
0BD0:  MOVLW  FE
0BD2:  MOVWF  xFE
0BD4:  MOVLW  08
0BD6:  MOVWF  xFF
0BD8:  MOVLB  0
0BDA:  RCALL  0512
....................     
....................    // send all the data 
....................    for(i = 0; i < size; i += 1) 
0BDC:  MOVLB  6
0BDE:  CLRF   xEE
0BE0:  CLRF   xED
0BE2:  MOVF   xEE,W
0BE4:  SUBWF  xE9,W
0BE6:  BNC   0C18
0BE8:  BNZ   0BF0
0BEA:  MOVF   xE8,W
0BEC:  SUBWF  xED,W
0BEE:  BC    0C18
....................       spi_xfer(mmcsd_spi, ptr[i]); 
0BF0:  MOVF   xEA,W
0BF2:  ADDWF  xED,W
0BF4:  MOVWF  FE9
0BF6:  MOVF   xEB,W
0BF8:  ADDWFC xEE,W
0BFA:  MOVWF  FEA
0BFC:  MOVFF  FEF,6EF
0C00:  MOVFF  6EF,6FE
0C04:  MOVLW  08
0C06:  MOVWF  xFF
0C08:  MOVLB  0
0C0A:  RCALL  0512
0C0C:  MOVLW  01
0C0E:  MOVLB  6
0C10:  ADDWF  xED,F
0C12:  MOVLW  00
0C14:  ADDWFC xEE,F
0C16:  BRA    0BE2
....................  
....................    // if the CRC is enabled we have to calculate it, otherwise just send an 0xFFFF 
....................    if(g_CRC_enabled) 
0C18:  MOVLB  2
0C1A:  BTFSS  x0B.0
0C1C:  BRA    0C48
....................       spi_xfer(mmcsd_spi, mmcsd_crc16(ptr, size)); 
0C1E:  MOVFF  6EB,6F4
0C22:  MOVFF  6EA,6F3
0C26:  MOVFF  6E8,6F5
0C2A:  MOVLB  0
0C2C:  RCALL  07B6
0C2E:  MOVFF  02,6F0
0C32:  MOVFF  01,6EF
0C36:  MOVFF  01,6FE
0C3A:  MOVLW  08
0C3C:  MOVLB  6
0C3E:  MOVWF  xFF
0C40:  MOVLB  0
0C42:  RCALL  0512
....................    else 
0C44:  BRA    0C64
0C46:  MOVLB  2
....................    { 
....................       spi_xfer(mmcsd_spi, 0xFF); 
0C48:  MOVLW  FF
0C4A:  MOVLB  6
0C4C:  MOVWF  xFE
0C4E:  MOVLW  08
0C50:  MOVWF  xFF
0C52:  MOVLB  0
0C54:  RCALL  0512
....................       spi_xfer(mmcsd_spi, 0xFF); 
0C56:  MOVLW  FF
0C58:  MOVLB  6
0C5A:  MOVWF  xFE
0C5C:  MOVLW  08
0C5E:  MOVWF  xFF
0C60:  MOVLB  0
0C62:  RCALL  0512
....................    } 
....................     
....................    // get the error code back from the card; "data accepted" is 0bXXX00101 
....................    ec = mmcsd_get_r1(); 
0C64:  RCALL  0688
0C66:  MOVFF  01,6EC
....................    if(ec & 0x0A) 
0C6A:  MOVLB  6
0C6C:  MOVF   xEC,W
0C6E:  ANDLW  0A
0C70:  BZ    0C7E
....................    { 
....................       mmcsd_deselect(); 
0C72:  MOVLB  0
0C74:  RCALL  0558
....................       return ec; 
0C76:  MOVLB  6
0C78:  MOVFF  6EC,01
0C7C:  BRA    0C9C
....................    } 
....................     
....................    // wait for the line to go back high, this indicates that the write is complete 
....................    while(spi_xfer(mmcsd_spi, 0xFF) == 0); 
0C7E:  MOVLW  FF
0C80:  MOVWF  xFE
0C82:  MOVLW  08
0C84:  MOVWF  xFF
0C86:  MOVLB  0
0C88:  RCALL  0512
0C8A:  MOVF   01,W
0C8C:  BTFSS  FD8.2
0C8E:  BRA    0C94
0C90:  MOVLB  6
0C92:  BRA    0C7E
....................    mmcsd_deselect(); 
0C94:  RCALL  0558
....................  
....................    return MMCSD_GOODEC; 
0C96:  MOVLW  00
0C98:  MOVWF  01
0C9A:  MOVLB  6
.................... } 
0C9C:  MOVLB  0
0C9E:  GOTO   0CCC (RETURN)
....................  
.................... MMCSD_err mmcsd_go_idle_state(void) 
.................... { 
....................    mmcsd_send_cmd(GO_IDLE_STATE, 0); 
*
06C0:  MOVLB  6
06C2:  CLRF   xF3
06C4:  CLRF   xF7
06C6:  CLRF   xF6
06C8:  CLRF   xF5
06CA:  CLRF   xF4
06CC:  MOVLB  0
06CE:  RCALL  05F0
....................     
....................    return mmcsd_get_r1(); 
06D0:  RCALL  0688
06D2:  MOVF   01,W
.................... } 
06D4:  GOTO   0A70 (RETURN)
....................  
.................... MMCSD_err mmcsd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SEND_OP_COND, 0); 
06D8:  MOVLW  01
06DA:  MOVLB  6
06DC:  MOVWF  xF3
06DE:  CLRF   xF7
06E0:  CLRF   xF6
06E2:  CLRF   xF5
06E4:  CLRF   xF4
06E6:  MOVLB  0
06E8:  RCALL  05F0
....................     
....................    return mmcsd_get_r1(); 
06EA:  RCALL  0688
06EC:  MOVF   01,W
.................... } 
06EE:  GOTO   0A9C (RETURN)
....................  
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_IF_COND, 0x45A); 
....................  
....................    return mmcsd_get_r7(r7); 
.................... } 
....................  
.................... MMCSD_err mmcsd_print_csd() 
.................... {   
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................  
....................    mmcsd_select();    
....................    mmcsd_send_cmd(SEND_CSD, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................  
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = spi_xfer(mmcsd_spi, 0xFF); 
....................    mmcsd_deselect(); 
.................... /* 
....................    printf("\r\nCSD_STRUCTURE: %X", (buf[0] & 0x0C) >> 2); 
....................    printf("\r\nTAAC: %X", buf[1]); 
....................    printf("\r\nNSAC: %X", buf[2]); 
....................    printf("\r\nTRAN_SPEED: %X", buf[3]); 
....................    printf("\r\nCCC: %lX", (make16(buf[4], buf[5]) & 0xFFF0) >> 4); 
....................    printf("\r\nREAD_BL_LEN: %X", buf[5] & 0x0F);    
....................    printf("\r\nREAD_BL_PARTIAL: %X", (buf[6] & 0x80) >> 7); 
....................    printf("\r\nWRITE_BLK_MISALIGN: %X", (buf[6] & 0x40) >> 6); 
....................    printf("\r\nREAD_BLK_MISALIGN: %X", (buf[6] & 0x20) >> 5); 
....................    printf("\r\nDSR_IMP: %X", (buf[6] & 0x10) >> 4); 
....................    printf("\r\nC_SIZE: %lX", (((buf[6] & 0x03) << 10) | (buf[7] << 2) | ((buf[8] & 0xC0) >> 6))); 
....................    printf("\r\nVDD_R_CURR_MIN: %X", (buf[8] & 0x38) >> 3); 
....................    printf("\r\nVDD_R_CURR_MAX: %X", buf[8] & 0x07); 
....................    printf("\r\nVDD_W_CURR_MIN: %X", (buf[9] & 0xE0) >> 5); 
....................    printf("\r\nVDD_W_CURR_MAX: %X", (buf[9] & 0x1C) >> 2); 
....................    printf("\r\nC_SIZE_MULT: %X", ((buf[9] & 0x03) << 1) | ((buf[10] & 0x80) >> 7)); 
....................    printf("\r\nERASE_BLK_EN: %X", (buf[10] & 0x40) >> 6); 
....................    printf("\r\nSECTOR_SIZE: %X", ((buf[10] & 0x3F) << 1) | ((buf[11] & 0x80) >> 7)); 
....................    printf("\r\nWP_GRP_SIZE: %X", buf[11] & 0x7F); 
....................    printf("\r\nWP_GRP_ENABLE: %X", (buf[12] & 0x80) >> 7); 
....................    printf("\r\nR2W_FACTOR: %X", (buf[12] & 0x1C) >> 2); 
....................    printf("\r\nWRITE_BL_LEN: %X", ((buf[12] & 0x03) << 2) | ((buf[13] & 0xC0) >> 6)); 
....................    printf("\r\nWRITE_BL_PARTIAL: %X", (buf[13] & 0x20) >> 5); 
....................    printf("\r\nFILE_FORMAT_GRP: %X", (buf[14] & 0x80) >> 7); 
....................    printf("\r\nCOPY: %X", (buf[14] & 0x40) >> 6); 
....................    printf("\r\nPERM_WRITE_PROTECT: %X", (buf[14] & 0x20) >> 5); 
....................    printf("\r\nTMP_WRITE_PROTECT: %X", (buf[14] & 0x10) >> 4); 
....................    printf("\r\nFILE_FORMAT: %X", (buf[14] & 0x0C) >> 2); 
....................    printf("\r\nCRC: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_print_cid() 
.................... { 
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................     
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SEND_CID, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = spi_xfer(mmcsd_spi, 0xFF); 
....................    mmcsd_deselect(); 
....................    /* 
....................    printf("\r\nManufacturer ID: %X", buf[0]); 
....................    printf("\r\nOEM/Application ID: %c%c", buf[1], buf[2]); 
....................    printf("\r\nOEM/Application ID: %c%c%c%c%c", buf[3], buf[4], buf[5], buf[6], buf[7]); 
....................    printf("\r\nProduct Revision: %X", buf[8]); 
....................    printf("\r\nSerial Number: %X%X%X%X", buf[9], buf[10], buf[11], buf[12]); 
....................    printf("\r\nManufacturer Date Code: %X%X", buf[13] & 0x0F, buf[14]); 
....................    printf("\r\nCRC-7 Checksum: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]) 
.................... { 
....................    uint8_t i; 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(APP_CMD, 0); 
....................    r2[0]=mmcsd_get_r1(); 
....................    mmcsd_deselect(); 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SD_STATUS, 0); 
....................  
....................    for(i = 0; i < 64; i++) 
....................       spi_xfer(mmcsd_spi, 0xFF);       
....................  
....................    mmcsd_deselect(); 
....................  
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_STATUS, 0);    
....................     
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen) 
.................... { 
....................    mmcsd_send_cmd(SET_BLOCKLEN, blocklen); 
*
0726:  MOVLW  10
0728:  MOVLB  6
072A:  MOVWF  xF3
072C:  MOVFF  60A,6F7
0730:  MOVFF  609,6F6
0734:  MOVFF  608,6F5
0738:  MOVFF  607,6F4
073C:  MOVLB  0
073E:  RCALL  05F0
....................     
....................    return mmcsd_get_r1(); 
0740:  RCALL  0688
0742:  MOVF   01,W
.................... } 
0744:  GOTO   0AF2 (RETURN)
....................  
.................... MMCSD_err mmcsd_read_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(READ_SINGLE_BLOCK, address); 
*
0776:  MOVLW  11
0778:  MOVLB  6
077A:  MOVWF  xF3
077C:  MOVFF  6F2,6F7
0780:  MOVFF  6F1,6F6
0784:  MOVFF  6F0,6F5
0788:  MOVFF  6EF,6F4
078C:  MOVLB  0
078E:  RCALL  05F0
....................     
....................    return mmcsd_get_r1(); 
0790:  RCALL  0688
0792:  MOVF   01,W
.................... } 
0794:  GOTO   083C (RETURN)
....................  
.................... MMCSD_err mmcsd_write_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(WRITE_BLOCK, address); 
*
0B84:  MOVLW  18
0B86:  MOVLB  6
0B88:  MOVWF  xF3
0B8A:  MOVFF  6F2,6F7
0B8E:  MOVFF  6F1,6F6
0B92:  MOVFF  6F0,6F5
0B96:  MOVFF  6EF,6F4
0B9A:  MOVLB  0
0B9C:  RCALL  05F0
....................    
....................    return mmcsd_get_r1(); 
0B9E:  RCALL  0688
0BA0:  MOVF   01,W
.................... } 
0BA2:  GOTO   0BBA (RETURN)
....................  
.................... MMCSD_err mmcsd_sd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SD_SEND_OP_COND, 0); 
*
070C:  MOVLW  29
070E:  MOVLB  6
0710:  MOVWF  xF3
0712:  CLRF   xF7
0714:  CLRF   xF6
0716:  CLRF   xF5
0718:  CLRF   xF4
071A:  MOVLB  0
071C:  RCALL  05F0
....................     
....................    return mmcsd_get_r1(); 
071E:  RCALL  0688
0720:  MOVF   01,W
.................... } 
0722:  GOTO   0AC6 (RETURN)
....................  
.................... MMCSD_err mmcsd_app_cmd(void) 
.................... { 
....................    mmcsd_send_cmd(APP_CMD, 0); 
*
06F2:  MOVLW  37
06F4:  MOVLB  6
06F6:  MOVWF  xF3
06F8:  CLRF   xF7
06FA:  CLRF   xF6
06FC:  CLRF   xF5
06FE:  CLRF   xF4
0700:  MOVLB  0
0702:  RCALL  05F0
....................     
....................    return mmcsd_get_r1(); 
0704:  RCALL  0688
0706:  MOVF   01,W
.................... } 
0708:  GOTO   0AC0 (RETURN)
....................  
.................... MMCSD_err mmcsd_read_ocr(int r3[]) 
.................... { 
....................    mmcsd_send_cmd(READ_OCR, 0); 
....................     
....................    return mmcsd_get_r3(r3); 
.................... } 
....................  
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled) 
.................... { 
....................    mmcsd_send_cmd(CRC_ON_OFF, crc_enabled); 
*
0748:  MOVLW  3B
074A:  MOVLB  6
074C:  MOVWF  xF3
074E:  CLRF   xF7
0750:  CLRF   xF6
0752:  CLRF   xF5
0754:  MOVFF  607,6F4
0758:  MOVLB  0
075A:  RCALL  05F0
....................     
....................    g_CRC_enabled = crc_enabled; 
075C:  MOVLB  2
075E:  BCF    x0B.0
0760:  MOVLB  6
0762:  BTFSS  x07.0
0764:  BRA    076C
0766:  MOVLB  2
0768:  BSF    x0B.0
076A:  MOVLB  6
....................     
....................    return mmcsd_get_r1(); 
076C:  MOVLB  0
076E:  RCALL  0688
0770:  MOVF   01,W
.................... } 
0772:  GOTO   0B16 (RETURN)
....................  
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg) 
.................... {    
....................    uint8_t packet[6]; // the entire command, argument, and crc in one variable 
....................    
....................    // construct the packet 
....................    // every command on an SD card is or'ed with 0x40 
....................    packet[0] = cmd | 0x40; 
*
05F0:  MOVLB  6
05F2:  MOVF   xF3,W
05F4:  IORLW  40
05F6:  MOVWF  xF8
....................    packet[1] = make8(arg, 3); 
05F8:  MOVFF  6F7,6F9
....................    packet[2] = make8(arg, 2); 
05FC:  MOVFF  6F6,6FA
....................    packet[3] = make8(arg, 1); 
0600:  MOVFF  6F5,6FB
....................    packet[4] = make8(arg, 0); 
0604:  MOVFF  6F4,6FC
....................  
....................    // calculate the crc if needed 
....................    if(g_CRC_enabled) 
0608:  MOVLB  2
060A:  BTFSS  x0B.0
060C:  BRA    0628
....................       packet[5] = mmcsd_crc7(packet, 5); 
060E:  MOVLW  06
0610:  MOVLB  6
0612:  MOVWF  xFF
0614:  MOVLW  F8
0616:  MOVWF  xFE
0618:  MOVLW  05
061A:  MOVLB  7
061C:  MOVWF  x00
061E:  MOVLB  0
0620:  BRA    0596
0622:  MOVFF  01,6FD
....................    else 
0626:  BRA    062E
....................       packet[5] = 0xFF; 
0628:  MOVLW  FF
062A:  MOVLB  6
062C:  MOVWF  xFD
....................  
....................    // transfer the command and argument, with an extra 0xFF hacked in there 
....................    spi_xfer(mmcsd_spi, packet[0]); 
062E:  MOVFF  6F8,6FE
0632:  MOVLW  08
0634:  MOVLB  6
0636:  MOVWF  xFF
0638:  MOVLB  0
063A:  RCALL  0512
....................    spi_xfer(mmcsd_spi, packet[1]); 
063C:  MOVFF  6F9,6FE
0640:  MOVLW  08
0642:  MOVLB  6
0644:  MOVWF  xFF
0646:  MOVLB  0
0648:  RCALL  0512
....................    spi_xfer(mmcsd_spi, packet[2]); 
064A:  MOVFF  6FA,6FE
064E:  MOVLW  08
0650:  MOVLB  6
0652:  MOVWF  xFF
0654:  MOVLB  0
0656:  RCALL  0512
....................    spi_xfer(mmcsd_spi, packet[3]); 
0658:  MOVFF  6FB,6FE
065C:  MOVLW  08
065E:  MOVLB  6
0660:  MOVWF  xFF
0662:  MOVLB  0
0664:  RCALL  0512
....................    spi_xfer(mmcsd_spi, packet[4]); 
0666:  MOVFF  6FC,6FE
066A:  MOVLW  08
066C:  MOVLB  6
066E:  MOVWF  xFF
0670:  MOVLB  0
0672:  RCALL  0512
....................    spi_xfer(mmcsd_spi, packet[5]); 
0674:  MOVFF  6FD,6FE
0678:  MOVLW  08
067A:  MOVLB  6
067C:  MOVWF  xFF
067E:  MOVLB  0
0680:  RCALL  0512
.................... //!   spi_write2(packet[0]); 
.................... //!   spi_write2(packet[1]); 
.................... //!   spi_write2(packet[2]); 
.................... //!   spi_write2(packet[3]); 
.................... //!   spi_write2(packet[4]); 
.................... //!   spi_write2(packet[5]); 
....................     
....................  
....................    return MMCSD_GOODEC; 
0682:  MOVLW  00
0684:  MOVWF  01
.................... } 
0686:  RETLW  00
....................  
.................... MMCSD_err mmcsd_get_r1(void) 
.................... { 
0688:  MOVLB  6
068A:  CLRF   xF3
068C:  MOVLW  FF
068E:  MOVWF  xF4
....................    uint8_t 
....................       response = 0,  // place to hold the response coming back from the SPI line 
....................       timeout = 0xFF; // maximum amount loops to wait for idle before getting impatient and leaving the function with an error code 
....................      
....................    // loop until timeout == 0 
....................    while(timeout) 
....................    { 
0690:  MOVF   xF4,F
0692:  BZ    06B8
....................       // read what's on the SPI line 
....................       //  the SD/MMC requires that you leave the line high when you're waiting for data from it 
....................       response = spi_xfer(mmcsd_spi, 0xFF); 
0694:  MOVLW  FF
0696:  MOVWF  xFE
0698:  MOVLW  08
069A:  MOVWF  xFF
069C:  MOVLB  0
069E:  RCALL  0512
06A0:  MOVF   01,W
06A2:  MOVFF  01,6F3
....................       //response = spi_xfer(mmcsd_spi, 0x00);//leave the line idle 
....................        
....................       // check to see if we got a response 
....................       if(response != 0xFF) 
06A6:  MOVLB  6
06A8:  INCFSZ xF3,W
06AA:  BRA    06AE
06AC:  BRA    06B4
....................       {    
....................          // fill in the response that we got and leave the function 
....................          return response; 
06AE:  MOVFF  6F3,01
06B2:  BRA    06BC
....................       } 
....................  
....................       // wait for a little bit longer 
....................       timeout--; 
06B4:  DECF   xF4,F
....................    } 
06B6:  BRA    0690
....................     
....................    // for some reason, we didn't get a response back from the card 
....................    //  return the proper error codes 
....................    return RESP_TIMEOUT; 
06B8:  MOVLW  80
06BA:  MOVWF  01
.................... } 
06BC:  MOVLB  0
06BE:  RETLW  00
....................  
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]) 
.................... { 
....................    r2[1] = mmcsd_get_r1(); 
....................     
....................    r2[0] = spi_xfer(mmcsd_spi, 0xFF); 
....................     
....................    return 0; 
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]) 
.................... { 
....................    return mmcsd_get_r7(r3); 
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]) 
.................... { 
....................    uint8_t i;   // counter for loop 
....................     
....................    // the top byte of r7 is r1 
....................    r7[4]=mmcsd_get_r1(); 
....................     
....................    // fill in the other 4 bytes 
....................    for(i = 0; i < 4; i++) 
....................       r7[3 - i] = spi_xfer(mmcsd_spi, 0xFF); 
....................  
....................    return r7[4]; 
.................... } 
....................  
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token) 
.................... { 
....................    MMCSD_err r1; 
....................     
....................    // get a token 
....................    r1 = mmcsd_get_r1(); 
*
0798:  RCALL  0688
079A:  MOVFF  01,6F0
....................     
....................    // check to see if the token we recieved was the one that we were looking for 
....................    if(r1 == token) 
079E:  MOVLB  6
07A0:  MOVF   xEF,W
07A2:  SUBWF  xF0,W
07A4:  BNZ   07AC
....................       return MMCSD_GOODEC; 
07A6:  MOVLW  00
07A8:  MOVWF  01
07AA:  BRA    07B0
....................     
....................    // if that wasn't right, return the error 
....................    return r1;    
07AC:  MOVFF  6F0,01
.................... } 
07B0:  MOVLB  0
07B2:  GOTO   085A (RETURN)
....................  
.................... unsigned int8 mmcsd_crc7(char *data,uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c, crc; 
....................      
....................    crc = 0x00;                                                                // Set initial value 
*
0596:  MOVLB  7
0598:  CLRF   x04
....................  
....................    for (i = 0; i < length; i++, data++) 
059A:  CLRF   x01
059C:  MOVF   x00,W
059E:  SUBWF  x01,W
05A0:  BC    05E2
....................    { 
....................       c = *data; 
05A2:  MOVFF  6FE,FE9
05A6:  MOVFF  6FF,FEA
05AA:  MOVFF  FEF,703
05AE:  MOVLB  7
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
05B0:  CLRF   x02
05B2:  MOVF   x02,W
05B4:  SUBLW  07
05B6:  BNC   05D0
....................       { 
....................          crc = crc << 1; 
05B8:  BCF    FD8.0
05BA:  RLCF   x04,F
....................          if ((c ^ crc) & 0x80) crc = crc ^ 0x09;                              // ^ is XOR 
05BC:  MOVF   x03,W
05BE:  XORWF  x04,W
05C0:  ANDLW  80
05C2:  BZ    05C8
05C4:  MOVLW  09
05C6:  XORWF  x04,F
....................          c = c << 1; 
05C8:  BCF    FD8.0
05CA:  RLCF   x03,F
....................       } 
05CC:  INCF   x02,F
05CE:  BRA    05B2
....................  
....................        crc = crc & 0x7F; 
05D0:  BCF    x04.7
....................    } 
05D2:  MOVF   x01,W
05D4:  INCF   x01,F
05D6:  MOVLB  6
05D8:  INCF   xFE,F
05DA:  BTFSC  FD8.2
05DC:  INCF   xFF,F
05DE:  MOVLB  7
05E0:  BRA    059C
....................  
....................    shift_left(&crc, 1, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
05E2:  BSF    FD8.0
05E4:  RLCF   x04,F
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
05E6:  MOVFF  704,01
.................... } 
05EA:  MOVLB  0
05EC:  GOTO   0622 (RETURN)
....................  
.................... uint16_t mmcsd_crc16(char *data, uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c; 
....................  
....................    uint16_t crc; 
....................  
....................    crc = 0x0000;                                                                // Set initial value 
*
07B6:  MOVLB  6
07B8:  CLRF   xFA
07BA:  CLRF   xF9
....................  
....................    for (i = 0; i < length; i++, data++) 
07BC:  CLRF   xF6
07BE:  MOVF   xF5,W
07C0:  SUBWF  xF6,W
07C2:  BC    0816
....................    { 
....................       c = *data; 
07C4:  MOVFF  6F3,FE9
07C8:  MOVFF  6F4,FEA
07CC:  MOVFF  FEF,6F8
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
07D0:  CLRF   xF7
07D2:  MOVF   xF7,W
07D4:  SUBLW  07
07D6:  BNC   0808
....................       { 
....................          crc = crc << 1; 
07D8:  BCF    FD8.0
07DA:  RLCF   xF9,F
07DC:  RLCF   xFA,F
....................          if ((c ^ crc) & 0x8000) crc = crc ^ 0x1021;                              // ^ is XOR 
07DE:  MOVF   xF8,W
07E0:  XORWF  xF9,W
07E2:  MOVWF  xFB
07E4:  MOVF   xFA,W
07E6:  MOVWF  xFC
07E8:  ANDLW  00
07EA:  MOVWF  00
07EC:  MOVF   xFC,W
07EE:  ANDLW  80
07F0:  MOVWF  03
07F2:  MOVF   00,W
07F4:  IORWF  03,W
07F6:  BZ    0800
07F8:  MOVLW  21
07FA:  XORWF  xF9,F
07FC:  MOVLW  10
07FE:  XORWF  xFA,F
....................          c = c << 1; 
0800:  BCF    FD8.0
0802:  RLCF   xF8,F
....................       } 
0804:  INCF   xF7,F
0806:  BRA    07D2
....................  
....................        crc = crc & 0x7FFF; 
0808:  BCF    xFA.7
....................    } 
080A:  MOVF   xF6,W
080C:  INCF   xF6,F
080E:  INCF   xF3,F
0810:  BTFSC  FD8.2
0812:  INCF   xF4,F
0814:  BRA    07BE
....................  
....................    shift_left(&crc, 2, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
0816:  BSF    FD8.0
0818:  RLCF   xF9,F
081A:  RLCF   xFA,F
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
081C:  MOVFF  6F9,01
0820:  MOVFF  6FA,02
.................... } 
0824:  MOVLB  0
0826:  RETLW  00
....................  
.................... void mmcsd_select() 
.................... { 
....................    output_low(MMCSD_PIN_SELECT); 
*
0592:  BCF    F8C.3
.................... } 
0594:  RETLW  00
....................  
.................... void mmcsd_deselect() 
.................... { 
....................    spi_xfer(mmcsd_spi, 0xFF); 
*
0558:  MOVLW  FF
055A:  MOVLB  6
055C:  MOVWF  xFE
055E:  MOVLW  08
0560:  MOVWF  xFF
0562:  MOVLB  0
0564:  RCALL  0512
....................    output_high(MMCSD_PIN_SELECT); 
0566:  BSF    F8C.3
.................... } 
0568:  RETLW  00
....................  
.................... MMCSD_err mmcsd_load_buffer(void) 
.................... { 
....................    g_MMCSDBufferChanged = FALSE; 
*
093E:  MOVLB  2
0940:  BCF    x0B.1
....................    return(mmcsd_read_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
0942:  MOVFF  20F,6E7
0946:  MOVFF  20E,6E6
094A:  MOVFF  20D,6E5
094E:  MOVFF  20C,6E4
0952:  MOVLW  02
0954:  MOVLB  6
0956:  MOVWF  xE9
0958:  CLRF   xE8
095A:  CLRF   xEB
095C:  MOVLW  0B
095E:  MOVWF  xEA
0960:  MOVLB  0
0962:  BRA    0828
0964:  MOVF   01,W
.................... } 
0966:  RETLW  00
....................  
.................... MMCSD_err mmcsd_flush_buffer(void) 
.................... { 
....................    if (g_MMCSDBufferChanged) 
*
0CA2:  MOVLB  2
0CA4:  BTFSS  x0B.1
0CA6:  BRA    0CD2
....................    { 
....................       g_MMCSDBufferChanged = FALSE; 
0CA8:  BCF    x0B.1
....................       return(mmcsd_write_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
0CAA:  MOVFF  20F,6E7
0CAE:  MOVFF  20E,6E6
0CB2:  MOVFF  20D,6E5
0CB6:  MOVFF  20C,6E4
0CBA:  MOVLW  02
0CBC:  MOVLB  6
0CBE:  MOVWF  xE9
0CC0:  CLRF   xE8
0CC2:  CLRF   xEB
0CC4:  MOVLW  0B
0CC6:  MOVWF  xEA
0CC8:  MOVLB  0
0CCA:  BRA    0BA6
0CCC:  MOVF   01,W
0CCE:  BRA    0CD6
0CD0:  MOVLB  2
....................    } 
....................    return(0);  //ok 
0CD2:  MOVLW  00
0CD4:  MOVWF  01
0CD6:  MOVLB  0
.................... } 
0CD8:  RETLW  00
....................  
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr) 
.................... { 
0CDA:  MOVLB  6
0CDC:  CLRF   xDF
....................    MMCSD_err ec = MMCSD_GOODEC; 
....................    uint32_t 
....................       //cur_block, 
....................       new_block; 
....................     
....................    // make sure we're still on the same block 
....................    //cur_block = g_mmcsdBufferAddress - (g_mmcsdBufferAddress % MMCSD_MAX_BLOCK_SIZE); 
....................    new_block = new_addr - (new_addr % MMCSD_MAX_BLOCK_SIZE); 
0CDE:  MOVF   xDC,W
0CE0:  ANDLW  01
0CE2:  MOVWF  01
0CE4:  CLRF   02
0CE6:  CLRF   03
0CE8:  MOVF   xDB,W
0CEA:  SUBWF  xDB,W
0CEC:  MOVWF  xE0
0CEE:  MOVF   01,W
0CF0:  SUBWFB xDC,W
0CF2:  MOVWF  xE1
0CF4:  MOVF   02,W
0CF6:  SUBWFB xDD,W
0CF8:  MOVWF  xE2
0CFA:  MOVF   03,W
0CFC:  SUBWFB xDE,W
0CFE:  MOVWF  xE3
....................    new_block += g_mmcsdPartitionOffset; 
0D00:  MOVLB  2
0D02:  MOVF   x10,W
0D04:  MOVLB  6
0D06:  ADDWF  xE0,F
0D08:  MOVLB  2
0D0A:  MOVF   x11,W
0D0C:  MOVLB  6
0D0E:  ADDWFC xE1,F
0D10:  MOVLB  2
0D12:  MOVF   x12,W
0D14:  MOVLB  6
0D16:  ADDWFC xE2,F
0D18:  MOVLB  2
0D1A:  MOVF   x13,W
0D1C:  MOVLB  6
0D1E:  ADDWFC xE3,F
....................     
....................    //if(cur_block != new_block) 
....................    if(g_mmcsdBufferAddress != new_block) 
0D20:  MOVF   xE0,W
0D22:  MOVLB  2
0D24:  SUBWF  x0C,W
0D26:  BNZ   0D46
0D28:  MOVLB  6
0D2A:  MOVF   xE1,W
0D2C:  MOVLB  2
0D2E:  SUBWF  x0D,W
0D30:  BNZ   0D46
0D32:  MOVLB  6
0D34:  MOVF   xE2,W
0D36:  MOVLB  2
0D38:  SUBWF  x0E,W
0D3A:  BNZ   0D46
0D3C:  MOVLB  6
0D3E:  MOVF   xE3,W
0D40:  MOVLB  2
0D42:  SUBWF  x0F,W
0D44:  BZ    0D7A
....................    { 
....................       // dump the old buffer 
....................       if (g_MMCSDBufferChanged) 
0D46:  BTFSS  x0B.1
0D48:  BRA    0D62
....................       { 
....................          ec = mmcsd_flush_buffer(); 
0D4A:  MOVLB  0
0D4C:  RCALL  0CA2
0D4E:  MOVFF  01,6DF
....................          if(ec != MMCSD_GOODEC) 
0D52:  MOVLB  6
0D54:  MOVF   xDF,F
0D56:  BZ    0D5E
....................             return ec; 
0D58:  MOVFF  6DF,01
0D5C:  BRA    0D80
....................          g_MMCSDBufferChanged = FALSE; 
0D5E:  MOVLB  2
0D60:  BCF    x0B.1
....................       } 
....................           
....................       // figure out the best place for a block 
....................       g_mmcsdBufferAddress = new_block; 
0D62:  MOVFF  6E3,20F
0D66:  MOVFF  6E2,20E
0D6A:  MOVFF  6E1,20D
0D6E:  MOVFF  6E0,20C
....................  
....................       // load up a new buffer 
....................       ec = mmcsd_load_buffer(); 
0D72:  MOVLB  0
0D74:  RCALL  093E
0D76:  MOVFF  01,6DF
....................    } 
....................     
....................    return ec; 
0D7A:  MOVLB  6
0D7C:  MOVFF  6DF,01
.................... } 
0D80:  MOVLB  0
0D82:  RETLW  00
....................  
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data) 
.................... { 
....................    MMCSD_err ec; 
....................     
....................    ec = mmcsd_move_buffer(addr); 
0D84:  MOVFF  6BE,6DE
0D88:  MOVFF  6BD,6DD
0D8C:  MOVFF  6BC,6DC
0D90:  MOVFF  6BB,6DB
0D94:  RCALL  0CDA
0D96:  MOVFF  01,6C1
....................    if(ec != MMCSD_GOODEC) 
0D9A:  MOVLB  6
0D9C:  MOVF   xC1,F
0D9E:  BZ    0DA6
....................    { 
....................      return ec; 
0DA0:  MOVFF  6C1,01
0DA4:  BRA    0DD0
....................    } 
....................   
....................    *data = g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE]; 
0DA6:  MOVF   xBC,W
0DA8:  ANDLW  01
0DAA:  MOVWF  xC5
0DAC:  CLRF   xC6
0DAE:  CLRF   xC7
0DB0:  MOVLW  0B
0DB2:  ADDWF  xBB,W
0DB4:  MOVWF  FE9
0DB6:  MOVLW  00
0DB8:  ADDWFC xC5,W
0DBA:  MOVWF  FEA
0DBC:  MOVFF  FEF,6C4
0DC0:  MOVFF  6C0,FEA
0DC4:  MOVFF  6BF,FE9
0DC8:  MOVFF  6C4,FEF
....................  
....................    return MMCSD_GOODEC; 
0DCC:  MOVLW  00
0DCE:  MOVWF  01
.................... } 
0DD0:  MOVLB  0
0DD2:  GOTO   0E46 (RETURN)
....................  
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data) 
.................... {   
....................    MMCSD_err ec; 
....................    ec = mmcsd_move_buffer(addr); 
*
1E9A:  MOVFF  6D8,6DE
1E9E:  MOVFF  6D7,6DD
1EA2:  MOVFF  6D6,6DC
1EA6:  MOVFF  6D5,6DB
1EAA:  CALL   0CDA
1EAE:  MOVFF  01,6DA
....................    if(ec != MMCSD_GOODEC) 
1EB2:  MOVLB  6
1EB4:  MOVF   xDA,F
1EB6:  BZ    1EBE
....................      return ec; 
1EB8:  MOVFF  6DA,01
1EBC:  BRA    1EE2
....................     
....................    g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE] = data; 
1EBE:  MOVF   xD6,W
1EC0:  ANDLW  01
1EC2:  MOVWF  xDC
1EC4:  CLRF   xDD
1EC6:  CLRF   xDE
1EC8:  MOVLW  0B
1ECA:  ADDWF  xD5,W
1ECC:  MOVWF  FE9
1ECE:  MOVLW  00
1ED0:  ADDWFC xDC,W
1ED2:  MOVWF  FEA
1ED4:  MOVFF  6D9,FEF
....................     
....................    g_MMCSDBufferChanged = TRUE; 
1ED8:  MOVLB  2
1EDA:  BSF    x0B.1
....................  
....................    return MMCSD_GOODEC; 
1EDC:  MOVLW  00
1EDE:  MOVWF  01
1EE0:  MOVLB  6
.................... } 
1EE2:  MOVLB  0
1EE4:  GOTO   1F5A (RETURN)
....................  
.................... #endif 
....................  
....................  
.................... //FAT library. 
.................... #include <fat_mod.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          FAT_PIC.C                              //// 
.................... ////                                                                 //// 
.................... //// Driver/Library for a FAT filesystem with a PIC                  //// 
.................... ////                                                                 //// 
.................... //// This Library was designed to resemble standard ANSI C I/O as    //// 
.................... ////  much as possible. There are, however, some caveats to this.    //// 
.................... ////  Please read the comments to make sure the inputs and outputs   //// 
.................... ////  to each function are understood before using anything in       //// 
.................... ////  this library.                                                  //// 
.................... ////                                                                 //// 
.................... //// This library supports FAT16 and FAT32, but not both at the same //// 
.................... //// time (this is a compile option, see options below).  It is      //// 
.................... //// recommended to use FAT32, FAT32 also has been tested more.      //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a file name must be in  //// 
.................... ////  the form of...                                                 //// 
.................... ////  "/filename.fil" for a file in the root directory               //// 
.................... ////  "/Directory/filename.fil" for a file in a subdirectory of root //// 
.................... ////  "/Directory/Subdirectory/filename.fil" and so on...            //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a directory name must   //// 
.................... ////  be in the form of...                                           //// 
.................... ////  "/Dirname/" for a directory in the root directory              //// 
.................... ////  "/Dirname/Subdirname/" for a directory in a subdirectory of    //// 
.................... ////  root and so on...                                              //// 
.................... ////                                                                 //// 
.................... //// A compatable media library must be provided.  This is           //// 
.................... //// documented after the User Functions.                            //// 
.................... ////                                                                 //// 
.................... //// -- User Functions --                                            //// 
.................... ////                                                                 //// 
.................... //// fat_init()                                                      //// 
.................... ////  Initializes the FAT library, also initializes the media.       //// 
.................... ////                                                                 //// 
.................... //// fatopen(char *name, char *mode, FILE *fstream)                  //// 
.................... ////  Opens up a FILE stream to a specified file with the specified  ////  
.................... ////  permission mode:                                               //// 
.................... ////             Permissions: "r" = read                             //// 
.................... ////                          "w" = write                            //// 
.................... ////                          "a" = append                           //// 
.................... ////                          "rb" = read binarily                   //// 
.................... ////             "w" will erase all of the data in the file upon     //// 
.................... ////              the opening of the file.                           //// 
.................... ////             "a" will tack on all of the data to the end of the  //// 
.................... ////              file.                                              //// 
.................... ////             "r" will keep on reading until the stream           //// 
.................... ////              hits an '\0'                                       //// 
.................... ////             "rb" will keep on reading until the amount of       //// 
.................... ////              bytes read equals the size of the file.            //// 
.................... ////                                                                 //// 
.................... ////  Unlike standard C fopen(), this does not malloc a FILE -       //// 
.................... ////  instead the caller will have to have allready allocated a      //// 
.................... ////  a FILE and pass a pointer to it.                               //// 
.................... ////                                                                 //// 
.................... //// fatreopen(char *name, char *mode, FILE *fstream)                //// 
.................... ////  Closes a FILE stream, then reopens the stream with a new file  //// 
.................... ////  and new permissions.                                           //// 
.................... ////                                                                 //// 
.................... //// fatclose(FILE *fstream)                                         //// 
.................... ////  Closes a FILE stream. It is very important to call this        ////  
.................... ////  function when you're done reading or writing to a file.        ////                             //// 
.................... ////                                                                 //// 
.................... //// fatgetc(FILE *fstream)                                          //// 
.................... ////  Gets a character from a stream. An EOF will be returned at     ////  
.................... ////  different times depending on whether or not the stream is      ////  
.................... ////  reading binarily.  If not reading binarily: EOF when the       ////  
.................... ////  stream reads a '\0'.  If reading binarily: EOF when the amount ////  
.................... ////  of bytes read equals the size of the file (end of file).       //// 
.................... ////                                                                 //// 
.................... //// fatputc(char c, FILE *fstream)                                  //// 
.................... ////  Puts a character into a stream (write to the file).            //// 
.................... ////  Writes are buffered, so the media may not be written to until  //// 
.................... ////  a fatclose().                                                  //// 
.................... ////                                                                 //// 
.................... //// char* fatgets(char* str, int num, FILE *fstream)                ////  
.................... ////  Gets characters from a stream until either a '\r',  EOF, or    ////  
.................... ////  num - 1 is hit.                                                //// 
.................... ////                                                                 //// 
.................... //// fatputs(char* str, FILE *fstream)                               //// 
.................... ////  Puts a string into a stream (write a string to the file).      //// 
.................... ////                                                                 //// 
.................... //// fatprintf(FILE *stream): Printfs the entire stream.             //// 
.................... ////  printf()'s the entire stream (printf()'s the contents of the 
.................... ////  file). 
.................... ////                                                                 //// 
.................... //// fatgetpos(FILE *fstream, fatpos_t *pos)                         //// 
.................... ////  Gets the current position of the stream/file, saves to pos.    //// 
.................... ////                                                                 //// 
.................... //// fatsetpos(FILE *fstream, fatpos_t *pos)                          //// 
.................... ////  Sets the current position of the stream/file.                  //// 
.................... ////                                                                 //// 
.................... //// fatseek(FILE *fstream, int32 offset, int origin)                 //// 
.................... ////  Sets the current position of the stream according to the       //// 
.................... ////  origin parameter:                                              //// 
.................... ////             SEEK_CUR: Set position relative to the              //// 
.................... ////              current stream position.                           //// 
.................... ////             SEEK_END: Set position relative to the              //// 
.................... ////              end of the stream.                                 //// 
.................... ////             SEEK_SET: Set position relative to the              //// 
.................... ////              beginning of the stream.                           //// 
.................... ////                                                                 //// 
.................... //// fateof(FILE *fstream)                                           //// 
.................... ////  Returns non-zero if the stream/file position is at EOF,        ////  
.................... ////  non-zero if there are still data left in the stream.           //// 
.................... ////                                                                 //// 
.................... //// faterror(FILE *fstream):                                        //// 
.................... ////  Returns non-zero if there have been errors with the stream,    //// 
.................... ////  zero if the stream has been operating correctly since it has   //// 
.................... ////  been opened.                                                   //// 
.................... ////                                                                 //// 
.................... //// fatread(void* buffer, int size, int32 num, FILE* fstream)       //// 
.................... ////  Reads size*num chars from the stream, saves to buffer.         //// 
.................... ////                                                                 //// 
.................... //// fatwrite(void* buffer, int size, int32 num, FILE* fstream)      ////  
.................... ////  Writes size*num chars from buffer to the stream.               //// 
.................... ////                                                                 //// 
.................... //// fatflush(FILE *fstream)                                         //// 
.................... ////  Flushes the buffer in a stream.                                //// 
.................... ////                                                                 //// 
.................... //// clearerr(FILE *fstream)                                         //// 
.................... ////  Clears any error flags in the stream.                          //// 
.................... ////                                                                 //// 
.................... //// rewind(FILE *fstream)                                           //// 
.................... ////  Send the stream back to the beginning of the file.             //// 
.................... ////                                                                 //// 
.................... //// fatpos_t fattell(FILE *fstream)                                 //// 
.................... ////  Returns the current position of the stream.                    //// 
.................... ////                                                                 //// 
.................... //// rm_file(char *fname)                                            //// 
.................... ////  Removes a file.                                                //// 
.................... ////                                                                 //// 
.................... //// rm_dir(char *dirname)                                           //// 
.................... ////  Removes a directory.                                           //// 
.................... ////                                                                 //// 
.................... //// mk_file(char *fname)                                            //// 
.................... ////  Makes a file, file will be blank.                              //// 
.................... ////                                                                 //// 
.................... //// mk_dir(char *dirname)                                           //// 
.................... ////  Makes a directory.                                             //// 
.................... ////                                                                 //// 
.................... //// format(int32 mediaSize)                                         //// 
.................... ////  Formats the media into a FAT32 or FAT16 file system.           //// 
.................... ////  If you specify a mediaSize larger than the actual media bad    //// 
.................... ////  things will happen.  If you specify a mediaSize smaller than   //// 
.................... ////  the actual media size will simply limit the filesystem from    //// 
.................... ////  using 0 to mediaSize-1.  Anything after mediaSize can be used  //// 
.................... ////  by the application (perhaps as a general purpose EEPROM?)      //// 
.................... ////  NOTE: Windows thinks the filesystem is RAW.                    //// 
.................... ////  NOTE: This may be a little buggy.                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// This library was written to use CCS's MMC/SD library as the     //// 
.................... //// media source.  If you want to use a different media source,     //// 
.................... //// you must provide the following 4 functions:                     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_init(void);                                          //// 
.................... ////  Initializes the media.  This will be called by fat_init().     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_read_bytes(int32 a, int16 s, char *p);               //// 
.................... ////  Read s bytes from p to the media starting at address a.        //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_write_data(int32 a, int16 s, char *p);               //// 
.................... ////  Write s bytes from p to the media starting at address a.       //// 
.................... ////  To maximize throughput on some medias, it's a good idea to     //// 
.................... ////  buffer writes in this function.                                //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_flush_buffer(void);                                  //// 
.................... ////  If your write function is buffering writes, this will flush    //// 
.................... ////  the buffer and write it to the media.                          //// 
.................... ////                                                                 //// 
.................... //// All four functions should return 0 if OK, non-zero if error.    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // NOTE This library has no concept of what time and date it currently is. 
.................... //       All files and folders created or modified using this library 
.................... //       will have invalid/inaccurate timestamps and datestamps. 
....................  
.................... // NOTE To save on ROM and RAM space, the user of this library will have to  
.................... //       define what type of FAT they will be working with. The defines are  
.................... //       in the Useful Defines section below. 
....................  
.................... // NOTE For faster writing or appending for an application such as a logger,  
.................... //       uncomment #FAST_FAT below.  This will make the FAT library assume  
.................... //       there is one file on the card to write or append to, thereby 
.................... //       making writing and appending much faster. Reading is impossible in  
.................... //       this mode. 
.................... //       THIS IS NOT TESTED VERY WELL YET! 
....................  
.................... // NOTE The current maximum file name length (full path) is 32 characters  
.................... //       long. If longer file names are desired, change the  
.................... //       MAX_FILE_NAME_LENGTH define below. Creating a file whose full path  
.................... //       is longer than MAX_FILE_NAME_LENGTH may lead to weird operation. Keep 
.................... //       in mind that making this define larger will make your RAM usage go  
.................... //        up. 
....................  
.................... #ifndef FAT_PIC_C 
.................... #define FAT_PIC_C 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #case 
....................  
.................... ////////////////////// 
.................... ///                /// 
.................... /// Useful Defines /// 
.................... ///                /// 
.................... ////////////////////// 
....................  
.................... /// Define your FAT type here /// 
.................... #define FAT16 
.................... //#define FAT32 
....................  
.................... /// For faster single-file writing, uncomment this line below /// 
.................... //#define FAST_FAT 
....................  
.................... /// Everything else /// 
.................... #define MAX_FILE_NAME_LENGTH 0x20  // the maximum length of a file name for our FAT, including /0 terminator 
.................... #define STREAM_BUF_SIZE 0x20       // how big the FILE buffer is. 0x20 is optimal 
....................  
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #define EOF -1 
.................... #define GOODEC 0 
.................... #define fatpos_t int32 
.................... #define SEEK_CUR 0 
.................... #define SEEK_END 1 
.................... #define SEEK_SET 2 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... int16 
....................    Bytes_Per_Cluster,   // number of addressable bytes per cluster 
....................    FAT_Start;           // when the first FAT begins 
....................  
.................... int32 
....................    Data_Start,          // when data starts 
....................    FAT_Length,          // the length of one FAT 
....................    Next_Free_Clust,     // where the next free cluster is 
....................    Root_Dir;            // when the root directory starts 
....................  
.................... enum filetype 
.................... { 
....................    Data_File,  // the stream is pointing to a binary, data file 
....................    Directory,  // the stream is pointing to a directory 
....................    None        // the stream isn't currently pointing to anything 
.................... }; 
....................  
.................... enum ioflags 
.................... { 
....................    Closed = 0x00, 
....................    Read = 0x01, 
....................    Write = 0x02, 
....................    Append = 0x04, 
....................    Binary = 0x08, 
....................    EOF_Reached = 0x10, 
....................    Read_Error = 0x20, 
....................    Write_Error = 0x40, 
....................    File_Not_Found = 0x80 
.................... }; 
....................  
.................... struct iobuf 
.................... { 
....................    fatpos_t 
....................       Bytes_Until_EOF,     // how many bytes until the stream's end of file 
....................       Cur_Char,            // the current byte that the stream is pointing at 
....................       Entry_Addr,          // the entry address of the file that is associated with the stream 
....................       Parent_Start_Addr,   // the parent's start adddress of the file that is associated with the stream 
....................       Size,                // the size of the file that is associated with the stream 
....................       Start_Addr;          // the beginning of the data in the file that is associated with the stream 
....................  
....................    enum filetype File_Type;   // the type of file that is associated with the stream 
....................  
....................    enum ioflags Flags;        // any associated input/output flag 
....................  
....................    int Buf[STREAM_BUF_SIZE];  // this is a buffer so that during fatputc() or fatgetc() 
....................                               //  the media won't have to be read at every character 
.................... }; 
.................... typedef struct iobuf FILE; 
....................  
.................... /////////////////////////// 
.................... ///                     /// 
.................... /// Function Prototypes /// 
.................... ///                     /// 
.................... /////////////////////////// 
....................  
.................... /// Standard C Functions /// 
.................... signed int fatopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatclose(FILE* stream); 
.................... signed int fatgetc(FILE* stream); 
.................... signed int fatputc(int ch, FILE* stream); 
.................... char* fatgets(char* str, int num, FILE* stream); 
.................... signed int fatputs(char* str, FILE* stream); 
.................... signed int fatprintf(FILE* stream); 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatseek(FILE* stream, int32 offset, int origin); 
.................... signed int fateof(FILE* stream); 
.................... signed int faterror(FILE* stream); 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream); 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ); 
.................... signed int fatflush(FILE* stream); 
.................... signed int remove(char* fname); 
.................... void clearerr(FILE* stream); 
.................... void rewind(FILE* stream); 
.................... fatpos_t fattell(FILE* stream); 
....................  
.................... /// Non-Standard C Functions /// 
.................... signed int rm_file(char fname[]); 
.................... signed int rm_dir(char dname[]); 
.................... signed int mk_file(char fname[]); 
.................... signed int mk_dir(char dname[]); 
....................  
.................... /// Functions' Utility Functions /// 
.................... signed int set_file(char fname[], int attrib, FILE* stream); 
.................... signed int get_file_name(int32 file_entry_addr, char name[]); 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]); 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type); 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]); 
.................... int long_name_chksum (int* pFcbName); 
.................... signed int check_invalid_char(char fname[]); 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster); 
.................... signed int dealloc_clusters(int32 start_cluster); 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int32 cluster); 
.................... signed int write_fat(int32 cluster, int32 data); 
.................... #else // FAT16 
.................... signed int get_next_free_cluster(int16* my_cluster); 
.................... signed int dealloc_clusters(int16 start_cluster); 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int16 cluster); 
.................... signed int write_fat(int16 cluster, int16 data); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_file(FILE* stream); 
.................... signed int get_prev_file(FILE* stream); 
.................... signed int get_next_free_addr(int32* my_addr); 
.................... signed int get_next_free_entry(int32* start_addr); 
.................... signed int get_next_entry(int32* start_addr); 
.................... signed int get_prev_entry(int32* start_addr); 
.................... signed int read_buffer(FILE* stream, int* val); 
.................... signed int write_buffer(FILE* stream, int val); 
.................... void fill_entry(char the_entry[], char val, int8 start_ind); 
.................... void disp_timestamp(int16 timestamp); 
.................... void disp_datestamp(int16 datestamp); 
....................  
.................... /// Data Utility Functions /// 
.................... signed int fat_init(); 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster); 
.................... signed int get_prev_cluster(int32* my_cluster); 
.................... int32 cluster_to_addr(int32 cluster); 
.................... int32 addr_to_cluster(int32 addr); 
.................... #else // FAT16 
.................... signed int get_next_cluster(int16* my_cluster); 
.................... signed int get_prev_cluster(int16* my_cluster); 
.................... int32 cluster_to_addr(int16 cluster); 
.................... int16 addr_to_cluster(int32 addr); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_addr(int32* my_addr); 
.................... signed int get_prev_addr(int32* my_addr); 
.................... signed int format(int32 DskSize); 
....................  
.................... /// Debugging Utility Functions /// 
.................... signed int disp_folder_contents(char foldername[]); 
.................... signed int dump_addr(int32 from, int32 to); 
.................... signed int dump_clusters(int32 from, int32 to); 
.................... void disp_fat_stats(); 
.................... signed int fatprintfinfo(FILE* stream); 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /// Standard C Functions /// 
....................  
.................... /* 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
.................... Summary: This will open up a file stream for reading, writing, or appending. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to open up. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
.................... { 
*
3474:  MOVLW  01
3476:  MOVLB  5
3478:  MOVWF  xF4
347A:  MOVLB  6
347C:  CLRF   x4F
....................    int fname_parse_pos = 1;    // the current index of the fname character 
....................  
....................    char target_file[MAX_FILE_NAME_LENGTH];   // temporary buffer to hold names of files 
....................  
....................    FILE cur_stream;     // this will   be the stream that will be returned if all goes well 
....................  
.................... #ifndef FAST_FAT 
....................    int 
....................       depth = 0,              // how many subdirectories deep the file is 
....................       target_file_parse_pos;  // the current index of the target_file character 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set flags 
.................... #ifdef FAST_FAT 
....................    switch(mode[0]) 
....................    { 
....................       case 'w': 
....................          cur_stream.Flags = Write; 
....................          break; 
....................       case 'a': 
....................          cur_stream.Flags = Append; 
....................          break; 
....................       default: 
....................          return EOF; 
....................    } 
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
....................  
....................    while(fname[fname_parse_pos] != '\0') 
....................    { 
....................       target_file[fname_parse_pos - 1] = fname[fname_parse_pos]; 
....................       fname_parse_pos += 1; 
....................    } 
....................  
....................    target_file[fname_parse_pos] = '\0'; 
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
....................       *stream = cur_stream; 
....................       return EOF; 
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................    switch(mode[0]) 
....................    { 
347E:  MOVLB  5
3480:  MOVF   xF0,W
3482:  MOVWF  FE9
3484:  MOVF   xF1,W
3486:  MOVWF  FEA
3488:  MOVF   FEF,W
348A:  XORLW  72
348C:  MOVLB  0
348E:  BZ    349A
3490:  XORLW  05
3492:  BZ    34A2
3494:  XORLW  16
3496:  BZ    34AA
3498:  BRA    34B4
....................       case 'r': 
....................          cur_stream.Flags = Read; 
349A:  MOVLW  01
349C:  MOVLB  6
349E:  MOVWF  x2E
....................          break; 
34A0:  BRA    34BA
....................       case 'w': 
....................          cur_stream.Flags = Write; 
34A2:  MOVLW  02
34A4:  MOVLB  6
34A6:  MOVWF  x2E
....................          break; 
34A8:  BRA    34BA
....................       case 'a': 
....................          cur_stream.Flags = Append; 
34AA:  MOVLW  04
34AC:  MOVLB  6
34AE:  MOVWF  x2E
....................          break; 
34B0:  BRA    34BA
34B2:  MOVLB  0
....................       default: 
....................          return EOF; 
34B4:  MOVLW  FF
34B6:  MOVWF  01
34B8:  BRA    372A
....................    } 
....................  
....................    if(mode[1] == 'b') 
34BA:  MOVLW  01
34BC:  MOVLB  5
34BE:  ADDWF  xF0,W
34C0:  MOVWF  FE9
34C2:  MOVLW  00
34C4:  ADDWFC xF1,W
34C6:  MOVWF  FEA
34C8:  MOVF   FEF,W
34CA:  SUBLW  62
34CC:  BNZ   34D4
....................       cur_stream.Flags |= Binary; 
34CE:  MOVLB  6
34D0:  BSF    x2E.3
34D2:  MOVLB  5
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
34D4:  MOVFF  227,624
34D8:  MOVFF  226,623
34DC:  MOVFF  225,622
34E0:  MOVFF  224,621
34E4:  MOVFF  624,62C
34E8:  MOVFF  623,62B
34EC:  MOVFF  622,62A
34F0:  MOVFF  621,629
....................  
....................    // figure out how deep we have to go, count how many '/' we have in the string 
....................    while(fname[fname_parse_pos] != '\0') 
....................    { 
34F4:  CLRF   03
34F6:  MOVF   xF4,W
34F8:  ADDWF  xEE,W
34FA:  MOVWF  FE9
34FC:  MOVF   xEF,W
34FE:  ADDWFC 03,W
3500:  MOVWF  FEA
3502:  MOVF   FEF,F
3504:  BZ    3526
....................       if(fname[fname_parse_pos] == '/') 
3506:  CLRF   03
3508:  MOVF   xF4,W
350A:  ADDWF  xEE,W
350C:  MOVWF  FE9
350E:  MOVF   xEF,W
3510:  ADDWFC 03,W
3512:  MOVWF  FEA
3514:  MOVF   FEF,W
3516:  SUBLW  2F
3518:  BNZ   3520
....................          depth++; 
351A:  MOVLB  6
351C:  INCF   x4F,F
351E:  MOVLB  5
....................       fname_parse_pos += 1; 
3520:  MOVLW  01
3522:  ADDWF  xF4,F
....................    } 
3524:  BRA    34F4
....................  
....................    // start the fname index at 1 to skip over the '/' 
....................    fname_parse_pos = 1; 
3526:  MOVLW  01
3528:  MOVWF  xF4
....................  
....................    // open up to the subdirectory, if possible 
....................    while(depth > 0) 
....................    { 
352A:  MOVLB  6
352C:  MOVF   x4F,F
352E:  BZ    3610
....................       // find the name of our next target directory 
....................       target_file_parse_pos = 0; 
3530:  CLRF   x50
....................       while(fname[fname_parse_pos] != '/') 
....................       { 
3532:  CLRF   03
3534:  MOVLB  5
3536:  MOVF   xF4,W
3538:  ADDWF  xEE,W
353A:  MOVWF  FE9
353C:  MOVF   xEF,W
353E:  ADDWFC 03,W
3540:  MOVWF  FEA
3542:  MOVF   FEF,W
3544:  SUBLW  2F
3546:  BZ    35A6
....................          // check to make sure that we're not at the end of a poorly formatted string 
....................          if(fname[fname_parse_pos] == '\0') 
3548:  CLRF   03
354A:  MOVF   xF4,W
354C:  ADDWF  xEE,W
354E:  MOVWF  FE9
3550:  MOVF   xEF,W
3552:  ADDWFC 03,W
3554:  MOVWF  FEA
3556:  MOVF   FEF,F
3558:  BNZ   3564
....................             return EOF; 
355A:  MOVLW  FF
355C:  MOVWF  01
355E:  MOVLB  0
3560:  BRA    372A
3562:  MOVLB  5
....................  
....................          // fill up the buffer and increment the indexes 
....................          target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
3564:  CLRF   03
3566:  MOVLB  6
3568:  MOVF   x50,W
356A:  ADDLW  F5
356C:  MOVWF  01
356E:  MOVLW  05
3570:  ADDWFC 03,F
3572:  MOVFF  03,652
3576:  CLRF   03
3578:  MOVLB  5
357A:  MOVF   xF4,W
357C:  ADDWF  xEE,W
357E:  MOVWF  FE9
3580:  MOVF   xEF,W
3582:  ADDWFC 03,W
3584:  MOVWF  FEA
3586:  MOVFF  FEF,653
358A:  MOVLB  6
358C:  MOVFF  652,FEA
3590:  MOVFF  01,FE9
3594:  MOVFF  653,FEF
....................          fname_parse_pos += 1; 
3598:  MOVLW  01
359A:  MOVLB  5
359C:  ADDWF  xF4,F
....................          target_file_parse_pos += 1; 
359E:  MOVLB  6
35A0:  ADDWF  x50,F
....................       } 
35A2:  BRA    3532
35A4:  MOVLB  5
....................  
....................       // increment the fname index one more because it's currently pointing at the '/' 
....................       fname_parse_pos += 1; 
35A6:  MOVLW  01
35A8:  ADDWF  xF4,F
....................  
....................       // tack on a \0 to the end of the target file to terminate the string 
....................       target_file[target_file_parse_pos] = '\0'; 
35AA:  CLRF   03
35AC:  MOVLB  6
35AE:  MOVF   x50,W
35B0:  ADDLW  F5
35B2:  MOVWF  FE9
35B4:  MOVLW  05
35B6:  ADDWFC 03,W
35B8:  MOVWF  FEA
35BA:  CLRF   FEF
....................  
....................       // check to see if the directory exists and open it if possible, otherwise exit because the directory doesn't exist 
....................       if(set_file(target_file, 0x10, &cur_stream) != GOODEC) 
35BC:  MOVLW  05
35BE:  MOVWF  x52
35C0:  MOVLW  F5
35C2:  MOVWF  x51
35C4:  MOVLW  10
35C6:  MOVWF  x53
35C8:  MOVLW  06
35CA:  MOVWF  x55
35CC:  MOVLW  15
35CE:  MOVWF  x54
35D0:  MOVLB  0
35D2:  CALL   2D8A
35D6:  MOVF   01,F
35D8:  BZ    3608
....................       { 
....................          cur_stream.Flags |= File_Not_Found; 
35DA:  MOVLB  6
35DC:  BSF    x2E.7
....................          *stream = cur_stream; 
35DE:  MOVFF  5F3,03
35E2:  MOVLB  5
35E4:  MOVFF  5F2,FE9
35E8:  MOVFF  5F3,FEA
35EC:  MOVLW  06
35EE:  MOVWF  FE2
35F0:  MOVLW  15
35F2:  MOVWF  FE1
35F4:  MOVLW  3A
35F6:  MOVWF  01
35F8:  MOVFF  FE6,FEE
35FC:  DECFSZ 01,F
35FE:  BRA    35F8
....................          return EOF; 
3600:  MOVLW  FF
3602:  MOVWF  01
3604:  MOVLB  0
3606:  BRA    372A
....................       } 
....................       depth -= 1; 
3608:  MOVLW  01
360A:  MOVLB  6
360C:  SUBWF  x4F,F
....................    } 
360E:  BRA    352C
....................  
....................    // check to see if we're trying to open just a directory 
....................    if(fname[fname_parse_pos] == '\0') 
3610:  CLRF   03
3612:  MOVLB  5
3614:  MOVF   xF4,W
3616:  ADDWF  xEE,W
3618:  MOVWF  FE9
361A:  MOVF   xEF,W
361C:  ADDWFC 03,W
361E:  MOVWF  FEA
3620:  MOVF   FEF,F
3622:  BNZ   364C
....................    { 
....................       *stream = cur_stream; 
3624:  MOVFF  5F3,03
3628:  MOVFF  5F2,FE9
362C:  MOVFF  5F3,FEA
3630:  MOVLW  06
3632:  MOVWF  FE2
3634:  MOVLW  15
3636:  MOVWF  FE1
3638:  MOVLW  3A
363A:  MOVWF  01
363C:  MOVFF  FE6,FEE
3640:  DECFSZ 01,F
3642:  BRA    363C
....................       return GOODEC; 
3644:  MOVLW  00
3646:  MOVWF  01
3648:  MOVLB  0
364A:  BRA    372A
....................    } 
....................  
....................    // now that we have the location of the subdirectory that the file is in, attempt to open the file 
....................    target_file_parse_pos = 0; 
364C:  MOVLB  6
364E:  CLRF   x50
....................    while(fname[fname_parse_pos] != '\0') 
....................    { 
3650:  CLRF   03
3652:  MOVLB  5
3654:  MOVF   xF4,W
3656:  ADDWF  xEE,W
3658:  MOVWF  FE9
365A:  MOVF   xEF,W
365C:  ADDWFC 03,W
365E:  MOVWF  FEA
3660:  MOVF   FEF,F
3662:  BZ    36A6
....................       // fill up the buffer and increment the indexes 
....................       target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
3664:  CLRF   03
3666:  MOVLB  6
3668:  MOVF   x50,W
366A:  ADDLW  F5
366C:  MOVWF  01
366E:  MOVLW  05
3670:  ADDWFC 03,F
3672:  MOVFF  03,652
3676:  CLRF   03
3678:  MOVLB  5
367A:  MOVF   xF4,W
367C:  ADDWF  xEE,W
367E:  MOVWF  FE9
3680:  MOVF   xEF,W
3682:  ADDWFC 03,W
3684:  MOVWF  FEA
3686:  MOVFF  FEF,653
368A:  MOVLB  6
368C:  MOVFF  652,FEA
3690:  MOVFF  01,FE9
3694:  MOVFF  653,FEF
....................       fname_parse_pos += 1; 
3698:  MOVLW  01
369A:  MOVLB  5
369C:  ADDWF  xF4,F
....................       target_file_parse_pos += 1; 
369E:  MOVLB  6
36A0:  ADDWF  x50,F
....................    } 
36A2:  BRA    3650
36A4:  MOVLB  5
....................  
....................    // tack on a \0 to the end of the target file to terminate the string 
....................    target_file[target_file_parse_pos] = '\0'; 
36A6:  CLRF   03
36A8:  MOVLB  6
36AA:  MOVF   x50,W
36AC:  ADDLW  F5
36AE:  MOVWF  FE9
36B0:  MOVLW  05
36B2:  ADDWFC 03,W
36B4:  MOVWF  FEA
36B6:  CLRF   FEF
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
36B8:  MOVLW  05
36BA:  MOVWF  x52
36BC:  MOVLW  F5
36BE:  MOVWF  x51
36C0:  MOVLW  20
36C2:  MOVWF  x53
36C4:  MOVLW  06
36C6:  MOVWF  x55
36C8:  MOVLW  15
36CA:  MOVWF  x54
36CC:  MOVLB  0
36CE:  CALL   2D8A
36D2:  MOVF   01,F
36D4:  BZ    3704
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
36D6:  MOVLB  6
36D8:  BSF    x2E.7
....................       *stream = cur_stream; 
36DA:  MOVFF  5F3,03
36DE:  MOVLB  5
36E0:  MOVFF  5F2,FE9
36E4:  MOVFF  5F3,FEA
36E8:  MOVLW  06
36EA:  MOVWF  FE2
36EC:  MOVLW  15
36EE:  MOVWF  FE1
36F0:  MOVLW  3A
36F2:  MOVWF  01
36F4:  MOVFF  FE6,FEE
36F8:  DECFSZ 01,F
36FA:  BRA    36F4
....................       return EOF; 
36FC:  MOVLW  FF
36FE:  MOVWF  01
3700:  MOVLB  0
3702:  BRA    372A
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
3704:  MOVFF  5F3,03
3708:  MOVLB  5
370A:  MOVFF  5F2,FE9
370E:  MOVFF  5F3,FEA
3712:  MOVLW  06
3714:  MOVWF  FE2
3716:  MOVLW  15
3718:  MOVWF  FE1
371A:  MOVLW  3A
371C:  MOVWF  01
371E:  MOVFF  FE6,FEE
3722:  DECFSZ 01,F
3724:  BRA    371E
....................    return GOODEC; 
3726:  MOVLW  00
3728:  MOVWF  01
372A:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
.................... } 
372C:  RETLW  00
....................  
.................... /* 
.................... signed int fatreopen(char fname[], char mode[], FILE* old_stream, FILE* new_stream) 
.................... Summary: This will close a stream and then reopen it using new parameters. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to close and reopen. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................          /Directory/filename.fil for a file in a subdirectory of root 
....................          /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream) 
.................... { 
....................    // close the old stream 
....................    if(fatclose(stream) == EOF) 
....................      return EOF; 
....................  
....................    // open the new stream 
....................    if(fatopen(fname, mode, stream) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fatclose(FILE* stream) 
.................... Summary: Closes a stream and commits any changes done to the file. 
.................... Param: The stream to close. 
.................... Returns: EOF if there was a problem, 0 if everything went okay. 
.................... */ 
.................... signed int fatclose(FILE* stream) 
.................... { 
*
38CA:  MOVLB  5
38CC:  CLRF   xED
....................    int ec = 0; 
....................  
....................    int32 first_cluster; 
....................  
....................    // commit data back to the stream's entry, if needed 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
38CE:  MOVLW  19
38D0:  ADDWF  xEB,W
38D2:  MOVWF  FE9
38D4:  MOVLW  00
38D6:  ADDWFC xEC,W
38D8:  MOVWF  FEA
38DA:  BTFSC  FEF.1
38DC:  BRA    38EE
38DE:  MOVLW  19
38E0:  ADDWF  xEB,W
38E2:  MOVWF  FE9
38E4:  MOVLW  00
38E6:  ADDWFC xEC,W
38E8:  MOVWF  FEA
38EA:  BTFSS  FEF.2
38EC:  BRA    3B68
....................    {  
....................       // write the new size of the file 
....................       if(mmcsd_write_data(stream->Entry_Addr + 0x1C, 4, &(stream->Size)) != GOODEC) 
38EE:  MOVLW  08
38F0:  ADDWF  xEB,W
38F2:  MOVWF  FE9
38F4:  MOVLW  00
38F6:  ADDWFC xEC,W
38F8:  MOVWF  FEA
38FA:  MOVFF  FEF,5F2
38FE:  MOVFF  FEC,5F3
3902:  MOVFF  FEC,5F4
3906:  MOVFF  FEC,5F5
390A:  MOVLW  1C
390C:  ADDWF  xF2,F
390E:  MOVLW  00
3910:  ADDWFC xF3,F
3912:  ADDWFC xF4,F
3914:  ADDWFC xF5,F
3916:  MOVLW  10
3918:  ADDWF  xEB,W
391A:  MOVWF  01
391C:  MOVLW  00
391E:  ADDWFC xEC,W
3920:  MOVWF  03
3922:  MOVFF  01,5F6
3926:  MOVWF  xF7
3928:  MOVFF  5F5,6C8
392C:  MOVFF  5F4,6C7
3930:  MOVFF  5F3,6C6
3934:  MOVFF  5F2,6C5
3938:  MOVLB  6
393A:  CLRF   xCA
393C:  MOVLW  04
393E:  MOVWF  xC9
3940:  MOVFF  03,6CC
3944:  MOVFF  01,6CB
3948:  MOVLB  0
394A:  CALL   1EE8
394E:  MOVF   01,F
3950:  BZ    396C
....................       { 
....................          stream->Flags |= Write_Error; 
3952:  MOVLW  19
3954:  MOVLB  5
3956:  ADDWF  xEB,W
3958:  MOVWF  FE9
395A:  MOVLW  00
395C:  ADDWFC xEC,W
395E:  MOVWF  FEA
3960:  MOVF   FEF,W
3962:  IORLW  40
3964:  MOVWF  FEF
....................          return EOF; 
3966:  MOVLW  FF
3968:  MOVWF  01
396A:  BRA    3BF6
....................       } 
....................  
....................       // check to see if the first cluster is already linked in the file 
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
396C:  MOVLW  08
396E:  MOVLB  5
3970:  ADDWF  xEB,W
3972:  MOVWF  FE9
3974:  MOVLW  00
3976:  ADDWFC xEC,W
3978:  MOVWF  FEA
397A:  MOVFF  FEF,5F2
397E:  MOVFF  FEC,5F3
3982:  MOVFF  FEC,5F4
3986:  MOVFF  FEC,5F5
398A:  MOVLW  14
398C:  ADDWF  xF2,F
398E:  MOVLW  00
3990:  ADDWFC xF3,F
3992:  ADDWFC xF4,F
3994:  ADDWFC xF5,F
3996:  MOVFF  5F5,6AD
399A:  MOVFF  5F4,6AC
399E:  MOVFF  5F3,6AB
39A2:  MOVFF  5F2,6AA
39A6:  MOVLB  6
39A8:  CLRF   xAF
39AA:  MOVLW  02
39AC:  MOVWF  xAE
39AE:  MOVLW  05
39B0:  MOVWF  xB1
39B2:  MOVLW  F0
39B4:  MOVWF  xB0
39B6:  MOVLB  0
39B8:  CALL   0DD6
39BC:  MOVF   01,W
39BE:  MOVLB  5
39C0:  ADDWF  xED,F
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
39C2:  MOVLW  08
39C4:  ADDWF  xEB,W
39C6:  MOVWF  FE9
39C8:  MOVLW  00
39CA:  ADDWFC xEC,W
39CC:  MOVWF  FEA
39CE:  MOVFF  FEF,5F2
39D2:  MOVFF  FEC,5F3
39D6:  MOVFF  FEC,5F4
39DA:  MOVFF  FEC,5F5
39DE:  MOVLW  1A
39E0:  ADDWF  xF2,F
39E2:  MOVLW  00
39E4:  ADDWFC xF3,F
39E6:  ADDWFC xF4,F
39E8:  ADDWFC xF5,F
39EA:  MOVFF  5F5,6AD
39EE:  MOVFF  5F4,6AC
39F2:  MOVFF  5F3,6AB
39F6:  MOVFF  5F2,6AA
39FA:  MOVLB  6
39FC:  CLRF   xAF
39FE:  MOVLW  02
3A00:  MOVWF  xAE
3A02:  MOVLW  05
3A04:  MOVWF  xB1
3A06:  MOVLW  EE
3A08:  MOVWF  xB0
3A0A:  MOVLB  0
3A0C:  CALL   0DD6
3A10:  MOVF   01,W
3A12:  MOVLB  5
3A14:  ADDWF  xED,F
....................  
....................       if(ec != GOODEC) 
3A16:  MOVF   xED,F
3A18:  BZ    3A32
....................       { 
....................          stream->Flags |= Read_Error; 
3A1A:  MOVLW  19
3A1C:  ADDWF  xEB,W
3A1E:  MOVWF  FE9
3A20:  MOVLW  00
3A22:  ADDWFC xEC,W
3A24:  MOVWF  FEA
3A26:  MOVF   FEF,W
3A28:  IORLW  20
3A2A:  MOVWF  FEF
....................          return EOF; 
3A2C:  MOVLW  FF
3A2E:  MOVWF  01
3A30:  BRA    3BF6
....................       } 
....................  
....................       // write the first cluster to the entry if needed 
....................       if(first_cluster == 0) 
3A32:  MOVF   xEE,F
3A34:  BTFSS  FD8.2
3A36:  BRA    3B4E
3A38:  MOVF   xEF,F
3A3A:  BTFSS  FD8.2
3A3C:  BRA    3B4E
3A3E:  MOVF   xF0,F
3A40:  BTFSS  FD8.2
3A42:  BRA    3B4E
3A44:  MOVF   xF1,F
3A46:  BTFSS  FD8.2
3A48:  BRA    3B4E
....................       { 
....................          // convert the start address to a cluster number 
....................          first_cluster = addr_to_cluster(stream->Start_Addr); 
3A4A:  MOVLW  14
3A4C:  ADDWF  xEB,W
3A4E:  MOVWF  FE9
3A50:  MOVLW  00
3A52:  ADDWFC xEC,W
3A54:  MOVWF  FEA
3A56:  MOVFF  FEF,5F2
3A5A:  MOVFF  FEC,5F3
3A5E:  MOVFF  FEC,5F4
3A62:  MOVFF  FEC,5F5
3A66:  MOVFF  5F5,69D
3A6A:  MOVFF  5F4,69C
3A6E:  MOVFF  5F3,69B
3A72:  MOVFF  5F2,69A
3A76:  MOVLB  0
3A78:  CALL   188E
3A7C:  MOVLB  5
3A7E:  CLRF   xF1
3A80:  CLRF   xF0
3A82:  MOVFF  02,5EF
3A86:  MOVFF  01,5EE
....................  
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
3A8A:  MOVLW  08
3A8C:  ADDWF  xEB,W
3A8E:  MOVWF  FE9
3A90:  MOVLW  00
3A92:  ADDWFC xEC,W
3A94:  MOVWF  FEA
3A96:  MOVFF  FEF,5F2
3A9A:  MOVFF  FEC,5F3
3A9E:  MOVFF  FEC,5F4
3AA2:  MOVFF  FEC,5F5
3AA6:  MOVLW  14
3AA8:  ADDWF  xF2,F
3AAA:  MOVLW  00
3AAC:  ADDWFC xF3,F
3AAE:  ADDWFC xF4,F
3AB0:  ADDWFC xF5,F
3AB2:  MOVFF  5F5,6C8
3AB6:  MOVFF  5F4,6C7
3ABA:  MOVFF  5F3,6C6
3ABE:  MOVFF  5F2,6C5
3AC2:  MOVLB  6
3AC4:  CLRF   xCA
3AC6:  MOVLW  02
3AC8:  MOVWF  xC9
3ACA:  MOVLW  05
3ACC:  MOVWF  xCC
3ACE:  MOVLW  F0
3AD0:  MOVWF  xCB
3AD2:  MOVLB  0
3AD4:  CALL   1EE8
3AD8:  MOVF   01,W
3ADA:  MOVLB  5
3ADC:  ADDWF  xED,F
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
3ADE:  MOVLW  08
3AE0:  ADDWF  xEB,W
3AE2:  MOVWF  FE9
3AE4:  MOVLW  00
3AE6:  ADDWFC xEC,W
3AE8:  MOVWF  FEA
3AEA:  MOVFF  FEF,5F2
3AEE:  MOVFF  FEC,5F3
3AF2:  MOVFF  FEC,5F4
3AF6:  MOVFF  FEC,5F5
3AFA:  MOVLW  1A
3AFC:  ADDWF  xF2,F
3AFE:  MOVLW  00
3B00:  ADDWFC xF3,F
3B02:  ADDWFC xF4,F
3B04:  ADDWFC xF5,F
3B06:  MOVFF  5F5,6C8
3B0A:  MOVFF  5F4,6C7
3B0E:  MOVFF  5F3,6C6
3B12:  MOVFF  5F2,6C5
3B16:  MOVLB  6
3B18:  CLRF   xCA
3B1A:  MOVLW  02
3B1C:  MOVWF  xC9
3B1E:  MOVLW  05
3B20:  MOVWF  xCC
3B22:  MOVLW  EE
3B24:  MOVWF  xCB
3B26:  MOVLB  0
3B28:  CALL   1EE8
3B2C:  MOVF   01,W
3B2E:  MOVLB  5
3B30:  ADDWF  xED,F
....................  
....................          if(ec != GOODEC) 
3B32:  MOVF   xED,F
3B34:  BZ    3B4E
....................          { 
....................             stream->Flags |= Write_Error; 
3B36:  MOVLW  19
3B38:  ADDWF  xEB,W
3B3A:  MOVWF  FE9
3B3C:  MOVLW  00
3B3E:  ADDWFC xEC,W
3B40:  MOVWF  FEA
3B42:  MOVF   FEF,W
3B44:  IORLW  40
3B46:  MOVWF  FEF
....................             return EOF; 
3B48:  MOVLW  FF
3B4A:  MOVWF  01
3B4C:  BRA    3BF6
....................          } 
....................       } 
....................        
....................       // dump the remaining buffer to the card 
....................       if(fatflush(stream) == EOF) 
3B4E:  MOVFF  5EC,5F3
3B52:  MOVFF  5EB,5F2
3B56:  MOVLB  0
3B58:  BRA    372E
3B5A:  MOVF   01,W
3B5C:  SUBLW  FF
3B5E:  BNZ   3B6A
....................          return EOF; 
3B60:  MOVLW  FF
3B62:  MOVWF  01
3B64:  MOVLB  5
3B66:  BRA    3BF6
3B68:  MOVLB  0
....................    } 
....................    // nullify the data 
....................    stream->Cur_Char = 0; 
3B6A:  MOVLW  04
3B6C:  MOVLB  5
3B6E:  ADDWF  xEB,W
3B70:  MOVWF  FE9
3B72:  MOVLW  00
3B74:  ADDWFC xEC,W
3B76:  MOVWF  FEA
3B78:  MOVF   FEE,F
3B7A:  MOVF   FEE,F
3B7C:  CLRF   FEC
3B7E:  MOVF   FED,F
3B80:  CLRF   FEF
3B82:  MOVF   FED,F
3B84:  CLRF   FEF
3B86:  MOVF   FED,F
3B88:  CLRF   FEF
....................    stream->Entry_Addr = 0; 
3B8A:  MOVLW  08
3B8C:  ADDWF  xEB,W
3B8E:  MOVWF  FE9
3B90:  MOVLW  00
3B92:  ADDWFC xEC,W
3B94:  MOVWF  FEA
3B96:  MOVF   FEE,F
3B98:  MOVF   FEE,F
3B9A:  CLRF   FEC
3B9C:  MOVF   FED,F
3B9E:  CLRF   FEF
3BA0:  MOVF   FED,F
3BA2:  CLRF   FEF
3BA4:  MOVF   FED,F
3BA6:  CLRF   FEF
....................    stream->Size = 0; 
3BA8:  MOVLW  10
3BAA:  ADDWF  xEB,W
3BAC:  MOVWF  FE9
3BAE:  MOVLW  00
3BB0:  ADDWFC xEC,W
3BB2:  MOVWF  FEA
3BB4:  MOVF   FEE,F
3BB6:  MOVF   FEE,F
3BB8:  CLRF   FEC
3BBA:  MOVF   FED,F
3BBC:  CLRF   FEF
3BBE:  MOVF   FED,F
3BC0:  CLRF   FEF
3BC2:  MOVF   FED,F
3BC4:  CLRF   FEF
....................    stream->Start_Addr = 0; 
3BC6:  MOVLW  14
3BC8:  ADDWF  xEB,W
3BCA:  MOVWF  FE9
3BCC:  MOVLW  00
3BCE:  ADDWFC xEC,W
3BD0:  MOVWF  FEA
3BD2:  MOVF   FEE,F
3BD4:  MOVF   FEE,F
3BD6:  CLRF   FEC
3BD8:  MOVF   FED,F
3BDA:  CLRF   FEF
3BDC:  MOVF   FED,F
3BDE:  CLRF   FEF
3BE0:  MOVF   FED,F
3BE2:  CLRF   FEF
....................    stream->Flags = 0; 
3BE4:  MOVLW  19
3BE6:  ADDWF  xEB,W
3BE8:  MOVWF  FE9
3BEA:  MOVLW  00
3BEC:  ADDWFC xEC,W
3BEE:  MOVWF  FEA
3BF0:  CLRF   FEF
....................    return 0; 
3BF2:  MOVLW  00
3BF4:  MOVWF  01
.................... } 
3BF6:  MOVLB  0
3BF8:  RETLW  00
....................  
.................... /* 
.................... signed int fatgetc(FILE* stream) 
.................... Summary: Gets a character from a stream. 
.................... Param: The stream to get a character from. 
.................... Returns: The character that was gotten from the stream, 
....................           EOF if the stream has reached the end of the file or doesn't have permissions to read, 
.................... */ 
.................... signed int fatgetc(FILE* stream) 
.................... { 
....................    char ch; // character read in 
....................  
....................    // check to see if the stream has proper permissions to read 
....................    if(stream->Flags & Read) 
*
54B0:  MOVLW  19
54B2:  MOVLB  5
54B4:  ADDWF  xA7,W
54B6:  MOVWF  FE9
54B8:  MOVLW  00
54BA:  ADDWFC xA8,W
54BC:  MOVWF  FEA
54BE:  BTFSS  FEF.0
54C0:  BRA    55BA
....................    { 
....................       // when the number of bytes until eof hit zero, we know we are at the end of any file 
....................       if(stream->Bytes_Until_EOF == 0) 
54C2:  MOVFF  5A7,FE9
54C6:  MOVFF  5A8,FEA
54CA:  MOVFF  FEF,5AA
54CE:  MOVFF  FEC,5AB
54D2:  MOVFF  FEC,5AC
54D6:  MOVFF  FEC,5AD
54DA:  MOVF   xAA,F
54DC:  BNZ   5502
54DE:  MOVF   xAB,F
54E0:  BNZ   5502
54E2:  MOVF   xAC,F
54E4:  BNZ   5502
54E6:  MOVF   xAD,F
54E8:  BNZ   5502
....................       { 
....................          stream->Flags |= EOF_Reached; 
54EA:  MOVLW  19
54EC:  ADDWF  xA7,W
54EE:  MOVWF  FE9
54F0:  MOVLW  00
54F2:  ADDWFC xA8,W
54F4:  MOVWF  FEA
54F6:  MOVF   FEF,W
54F8:  IORLW  10
54FA:  MOVWF  FEF
....................          return EOF; 
54FC:  MOVLW  FF
54FE:  MOVWF  01
5500:  BRA    55C0
....................       } 
....................  
....................       // read in the next byte in the buffer 
....................       if(read_buffer(stream, &ch) == EOF) 
5502:  MOVFF  5A8,5AB
5506:  MOVFF  5A7,5AA
550A:  MOVLW  05
550C:  MOVWF  xAD
550E:  MOVLW  A9
5510:  MOVWF  xAC
5512:  MOVLB  0
5514:  BRA    539C
5516:  MOVF   01,W
5518:  SUBLW  FF
551A:  BNZ   5524
....................          return EOF; 
551C:  MOVLW  FF
551E:  MOVWF  01
5520:  MOVLB  5
5522:  BRA    55C0
....................  
....................       // a 0x00 will signify the end of a non-binary file 
....................       if((ch == '\0') && !(stream->Flags & Binary)) 
5524:  MOVLB  5
5526:  MOVF   xA9,F
5528:  BNZ   5552
552A:  MOVLW  19
552C:  ADDWF  xA7,W
552E:  MOVWF  FE9
5530:  MOVLW  00
5532:  ADDWFC xA8,W
5534:  MOVWF  FEA
5536:  BTFSC  FEF.3
5538:  BRA    5552
....................       { 
....................          stream->Flags |= EOF_Reached; 
553A:  MOVLW  19
553C:  ADDWF  xA7,W
553E:  MOVWF  FE9
5540:  MOVLW  00
5542:  ADDWFC xA8,W
5544:  MOVWF  FEA
5546:  MOVF   FEF,W
5548:  IORLW  10
554A:  MOVWF  FEF
....................          return EOF; 
554C:  MOVLW  FF
554E:  MOVWF  01
5550:  BRA    55C0
....................       } 
....................  
....................       // get the next contiguous address of the stream 
....................       if(get_next_addr(&(stream->Cur_Char)) != GOODEC) 
5552:  MOVLW  04
5554:  ADDWF  xA7,W
5556:  MOVWF  01
5558:  MOVLW  00
555A:  ADDWFC xA8,W
555C:  MOVWF  03
555E:  MOVFF  01,5AA
5562:  MOVWF  xAB
5564:  MOVFF  FE8,68F
5568:  MOVFF  01,68E
556C:  MOVLB  0
556E:  CALL   23EC
5572:  MOVF   01,F
5574:  BZ    557E
....................          return EOF; 
5576:  MOVLW  FF
5578:  MOVWF  01
557A:  MOVLB  5
557C:  BRA    55C0
....................           
....................       // we just got 1 byte closer to the end of the file 
....................       stream->Bytes_Until_EOF -= 1; 
557E:  MOVLB  5
5580:  MOVFF  5A7,FE9
5584:  MOVFF  5A8,FEA
5588:  MOVLW  01
558A:  SUBWF  FEF,W
558C:  MOVWF  00
558E:  MOVLW  00
5590:  SUBWFB FEC,W
5592:  MOVWF  01
5594:  MOVLW  00
5596:  SUBWFB FEC,W
5598:  MOVWF  02
559A:  MOVLW  00
559C:  SUBWFB FEC,W
559E:  MOVF   FED,F
55A0:  MOVF   FED,F
55A2:  MOVF   FED,F
55A4:  MOVFF  00,FEF
55A8:  MOVFF  01,FEC
55AC:  MOVFF  02,FEC
55B0:  MOVWF  FEC
....................       return ch; 
55B2:  MOVFF  5A9,01
55B6:  BRA    55C0
....................    } 
....................  
....................    // if the stream doesn't have proper permissions to read, return an EOF 
....................    else 
55B8:  BRA    55C0
....................       return EOF; 
55BA:  MOVLW  FF
55BC:  MOVWF  01
55BE:  BRA    55C0
.................... } 
55C0:  MOVLB  0
55C2:  GOTO   55D0 (RETURN)
....................  
.................... /* 
.................... signed int fatputc(int ch, FILE* stream) 
.................... Summary: Puts a character into a stream. 
.................... Param ch: The character to put into the stream. 
.................... Param stream: The stream to put a character into. 
.................... Returns: The character that was put into the stream, 
....................           EOF if the stream doesn't have permissions to write, or if a problem happened. 
.................... */ 
.................... signed int fatputc(int ch, FILE* stream) 
.................... { 
....................    // check to see if the stream has proper permissions to write 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->File_Type == Data_File)) 
*
261E:  MOVLW  19
2620:  MOVLB  6
2622:  ADDWF  x8A,W
2624:  MOVWF  FE9
2626:  MOVLW  00
2628:  ADDWFC x8B,W
262A:  MOVWF  FEA
262C:  BTFSC  FEF.1
262E:  BRA    2640
2630:  MOVLW  19
2632:  ADDWF  x8A,W
2634:  MOVWF  FE9
2636:  MOVLW  00
2638:  ADDWFC x8B,W
263A:  MOVWF  FEA
263C:  BTFSS  FEF.2
263E:  BRA    28F2
2640:  MOVLW  18
2642:  ADDWF  x8A,W
2644:  MOVWF  FE9
2646:  MOVLW  00
2648:  ADDWFC x8B,W
264A:  MOVWF  FEA
264C:  MOVF   FEF,F
264E:  BTFSS  FD8.2
2650:  BRA    28F2
....................    { 
....................       // if there isn't any space allocated yet, allocate some 
....................       if(stream->Cur_Char < Data_Start) 
2652:  MOVLW  04
2654:  ADDWF  x8A,W
2656:  MOVWF  FE9
2658:  MOVLW  00
265A:  ADDWFC x8B,W
265C:  MOVWF  FEA
265E:  MOVFF  FEF,68C
2662:  MOVFF  FEC,68D
2666:  MOVFF  FEC,68E
266A:  MOVFF  FEC,68F
266E:  MOVF   x8F,W
2670:  MOVLB  2
2672:  SUBWF  x1B,W
2674:  BTFSS  FD8.0
2676:  BRA    2772
2678:  BNZ   26A6
267A:  MOVLB  6
267C:  MOVF   x8E,W
267E:  MOVLB  2
2680:  SUBWF  x1A,W
2682:  BTFSS  FD8.0
2684:  BRA    2772
2686:  BNZ   26A6
2688:  MOVLB  6
268A:  MOVF   x8D,W
268C:  MOVLB  2
268E:  SUBWF  x19,W
2690:  BTFSS  FD8.0
2692:  BRA    2772
2694:  BNZ   26A6
2696:  MOVF   x18,W
2698:  MOVLB  6
269A:  SUBWF  x8C,W
269C:  BTFSS  FD8.0
269E:  BRA    26A4
26A0:  MOVLB  2
26A2:  BRA    2772
26A4:  MOVLB  2
....................       { 
....................          if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
26A6:  MOVLW  02
26A8:  MOVLB  6
26AA:  MOVWF  x99
26AC:  MOVLW  20
26AE:  MOVWF  x98
26B0:  MOVLB  0
26B2:  RCALL  20B4
26B4:  MOVF   01,W
26B6:  SUBLW  FF
26B8:  BNZ   26C0
....................             return EOF; 
26BA:  MOVLW  FF
26BC:  MOVWF  01
26BE:  BRA    28FA
.................... #ifdef FAT32 
....................          if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
....................             return EOF; 
.................... #else // FAT16 
....................          if(write_fat(Next_Free_Clust, 0xFFFF) == EOF) 
26C0:  MOVFF  221,68D
26C4:  MOVFF  220,68C
26C8:  MOVFF  221,699
26CC:  MOVFF  220,698
26D0:  MOVLW  FF
26D2:  MOVLB  6
26D4:  MOVWF  x9B
26D6:  MOVWF  x9A
26D8:  MOVLB  0
26DA:  RCALL  1F7A
26DC:  MOVF   01,W
26DE:  SUBLW  FF
26E0:  BNZ   26E8
....................             return EOF; 
26E2:  MOVLW  FF
26E4:  MOVWF  01
26E6:  BRA    28FA
.................... #endif // #ifdef FAT32 
....................          if(clear_cluster(Next_Free_Clust) == EOF) 
26E8:  MOVFF  221,68D
26EC:  MOVFF  220,68C
26F0:  MOVFF  221,699
26F4:  MOVFF  220,698
26F8:  RCALL  21E6
26FA:  MOVF   01,W
26FC:  SUBLW  FF
26FE:  BNZ   2706
....................             return EOF; 
2700:  MOVLW  FF
2702:  MOVWF  01
2704:  BRA    28FA
....................          stream->Cur_Char = stream->Start_Addr = cluster_to_addr(Next_Free_Clust); 
2706:  MOVLW  04
2708:  MOVLB  6
270A:  ADDWF  x8A,W
270C:  MOVWF  01
270E:  MOVLW  00
2710:  ADDWFC x8B,W
2712:  MOVWF  03
2714:  MOVFF  01,68C
2718:  MOVWF  x8D
271A:  MOVLW  14
271C:  ADDWF  x8A,W
271E:  MOVWF  01
2720:  MOVLW  00
2722:  ADDWFC x8B,W
2724:  MOVWF  03
2726:  MOVFF  01,68E
272A:  MOVWF  x8F
272C:  MOVFF  221,691
2730:  MOVFF  220,690
2734:  MOVFF  221,6C2
2738:  MOVFF  220,6C1
273C:  MOVLB  0
273E:  CALL   19DA
2742:  MOVFF  68F,FEA
2746:  MOVFF  68E,FE9
274A:  MOVFF  00,FEF
274E:  MOVFF  01,FEC
2752:  MOVFF  02,FEC
2756:  MOVFF  03,FEC
275A:  MOVFF  68D,FEA
275E:  MOVFF  68C,FE9
2762:  MOVFF  00,FEF
2766:  MOVFF  01,FEC
276A:  MOVFF  02,FEC
276E:  MOVFF  03,FEC
....................       } 
....................  
....................       // write the next character to the buffer 
....................       if(write_buffer(stream, ch) == EOF) 
2772:  MOVFF  68B,68D
2776:  MOVFF  68A,68C
277A:  MOVFF  689,68E
277E:  MOVLB  0
2780:  BRA    229A
2782:  MOVF   01,W
2784:  SUBLW  FF
2786:  BNZ   278E
....................          return EOF; 
2788:  MOVLW  FF
278A:  MOVWF  01
278C:  BRA    28FA
....................  
....................       // get the next address, increment Cur_Char 
....................       if(get_next_addr(&(stream->Cur_Char)) == EOF) 
278E:  MOVLW  04
2790:  MOVLB  6
2792:  ADDWF  x8A,W
2794:  MOVWF  01
2796:  MOVLW  00
2798:  ADDWFC x8B,W
279A:  MOVWF  03
279C:  MOVFF  01,68C
27A0:  MOVWF  x8D
27A2:  MOVWF  x8F
27A4:  MOVFF  01,68E
27A8:  MOVLB  0
27AA:  RCALL  23EC
27AC:  MOVF   01,W
27AE:  SUBLW  FF
27B0:  BTFSS  FD8.2
27B2:  BRA    28AE
....................       { 
....................          // write the current buffer to the end of the current cluster 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE + 1, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
27B4:  MOVLW  04
27B6:  MOVLB  6
27B8:  ADDWF  x8A,W
27BA:  MOVWF  FE9
27BC:  MOVLW  00
27BE:  ADDWFC x8B,W
27C0:  MOVWF  FEA
27C2:  MOVFF  FEF,68C
27C6:  MOVFF  FEC,68D
27CA:  MOVFF  FEC,68E
27CE:  MOVFF  FEC,68F
27D2:  MOVLW  20
27D4:  SUBWF  x8C,F
27D6:  MOVLW  00
27D8:  SUBWFB x8D,F
27DA:  SUBWFB x8E,F
27DC:  SUBWFB x8F,F
27DE:  MOVLW  01
27E0:  ADDWF  x8C,F
27E2:  MOVLW  00
27E4:  ADDWFC x8D,F
27E6:  ADDWFC x8E,F
27E8:  ADDWFC x8F,F
27EA:  MOVLW  1A
27EC:  ADDWF  x8A,W
27EE:  MOVWF  01
27F0:  MOVLW  00
27F2:  ADDWFC x8B,W
27F4:  MOVWF  03
27F6:  MOVFF  01,690
27FA:  MOVWF  x91
27FC:  MOVFF  68F,6C8
2800:  MOVFF  68E,6C7
2804:  MOVFF  68D,6C6
2808:  MOVFF  68C,6C5
280C:  CLRF   xCA
280E:  MOVLW  20
2810:  MOVWF  xC9
2812:  MOVFF  03,6CC
2816:  MOVFF  01,6CB
281A:  MOVLB  0
281C:  CALL   1EE8
2820:  MOVF   01,F
2822:  BZ    2840
....................          { 
....................             stream->Flags |= Write_Error; 
2824:  MOVLW  19
2826:  MOVLB  6
2828:  ADDWF  x8A,W
282A:  MOVWF  FE9
282C:  MOVLW  00
282E:  ADDWFC x8B,W
2830:  MOVWF  FEA
2832:  MOVF   FEF,W
2834:  IORLW  40
2836:  MOVWF  FEF
....................             return EOF; 
2838:  MOVLW  FF
283A:  MOVWF  01
283C:  MOVLB  0
283E:  BRA    28FA
....................          } 
....................          // start looking for a new cluster to allocate 
....................          if(alloc_clusters(addr_to_cluster(stream->Cur_Char), &(stream->Cur_Char)) == EOF) 
2840:  MOVLW  04
2842:  MOVLB  6
2844:  ADDWF  x8A,W
2846:  MOVWF  FE9
2848:  MOVLW  00
284A:  ADDWFC x8B,W
284C:  MOVWF  FEA
284E:  MOVFF  FEF,68C
2852:  MOVFF  FEC,68D
2856:  MOVFF  FEC,68E
285A:  MOVFF  FEC,68F
285E:  MOVFF  68F,69D
2862:  MOVFF  68E,69C
2866:  MOVFF  68D,69B
286A:  MOVFF  68C,69A
286E:  MOVLB  0
2870:  CALL   188E
2874:  MOVFF  02,68D
2878:  MOVFF  01,68C
287C:  MOVLW  04
287E:  MOVLB  6
2880:  ADDWF  x8A,W
2882:  MOVWF  01
2884:  MOVLW  00
2886:  ADDWFC x8B,W
2888:  MOVWF  03
288A:  MOVFF  01,68E
288E:  MOVWF  x8F
2890:  MOVFF  02,691
2894:  MOVFF  68C,690
2898:  MOVWF  x93
289A:  MOVFF  01,692
289E:  MOVLB  0
28A0:  RCALL  2568
28A2:  MOVF   01,W
28A4:  SUBLW  FF
28A6:  BNZ   28AE
....................             return EOF; 
28A8:  MOVLW  FF
28AA:  MOVWF  01
28AC:  BRA    28FA
....................       } 
....................  
....................       // our file just got bigger by 1 byte 
....................       stream->Size += 1; 
28AE:  MOVLW  10
28B0:  MOVLB  6
28B2:  ADDWF  x8A,W
28B4:  MOVWF  FE9
28B6:  MOVLW  00
28B8:  ADDWFC x8B,W
28BA:  MOVWF  FEA
28BC:  MOVLW  01
28BE:  ADDWF  FEF,W
28C0:  MOVWF  00
28C2:  MOVLW  00
28C4:  ADDWFC FEC,W
28C6:  MOVWF  01
28C8:  MOVLW  00
28CA:  ADDWFC FEC,W
28CC:  MOVWF  02
28CE:  MOVLW  00
28D0:  ADDWFC FEC,W
28D2:  MOVF   FED,F
28D4:  MOVF   FED,F
28D6:  MOVF   FED,F
28D8:  MOVFF  00,FEF
28DC:  MOVFF  01,FEC
28E0:  MOVFF  02,FEC
28E4:  MOVWF  FEC
....................  
....................       return ch; 
28E6:  MOVFF  689,01
28EA:  MOVLB  0
28EC:  BRA    28FA
....................    } 
....................  
....................    // if the stream doesn't have proper permissions to write, return an EOF 
....................    else 
28EE:  BRA    28FA
28F0:  MOVLB  6
....................       return EOF; 
28F2:  MOVLW  FF
28F4:  MOVWF  01
28F6:  MOVLB  0
28F8:  BRA    28FA
.................... } 
28FA:  RETLW  00
....................  
.................... /* 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... Summary: Reads characters from a stream into a string. 
.................... Param str: A pointer to the beginning of the string to put characters into. 
.................... Param num: The number of characters to put into the string - 1. 
.................... Param stream: The stream to read from. 
.................... Returns: A pointer to the most recently added character, or NULL if there was an error. 
.................... Note: If a newline is read from the stream, then str will be terminated with a newline. 
....................        If num - 1 or EOF is reached, then str will be null terminated. 
.................... */ 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... { 
....................    int i;   // counter for loops 
....................  
....................    // loop until num - 1 
....................    for(i = 0; i < num - 1; i += 1) 
....................    { 
....................       str[i] = fatgetc(stream); 
....................       if(str[i] == '\n') 
....................          return str; 
....................       if(str[i] == EOF) 
....................          break; 
....................    } 
....................  
....................    // close off str with a null terminator 
....................    str[i] = '\0'; 
....................  
....................    return str; 
.................... } 
....................  
.................... /* 
.................... signed int fatputs(char* str, FILE* stream) 
.................... Summary: Writes characters from a string into a stream. 
.................... Param str: A pointer to the beginning of the string to write into the stream. 
.................... Param stream: The stream to write into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatputs(char* str, FILE* stream) 
.................... { 
*
4BAA:  MOVLB  5
4BAC:  CLRF   xAC
....................    int i = 0;   // counter for loops 
....................  
....................    // fatputc every character in the stream 
....................    while(str[i] != '\0') 
....................    { 
4BAE:  CLRF   03
4BB0:  MOVF   xAC,W
4BB2:  ADDWF  xA8,W
4BB4:  MOVWF  FE9
4BB6:  MOVF   xA9,W
4BB8:  ADDWFC 03,W
4BBA:  MOVWF  FEA
4BBC:  MOVF   FEF,F
4BBE:  BZ    4BF8
....................       if(fatputc(str[i], stream) == EOF) 
4BC0:  CLRF   03
4BC2:  MOVF   xAC,W
4BC4:  ADDWF  xA8,W
4BC6:  MOVWF  FE9
4BC8:  MOVF   xA9,W
4BCA:  ADDWFC 03,W
4BCC:  MOVWF  FEA
4BCE:  MOVFF  FEF,5AD
4BD2:  MOVFF  5AD,689
4BD6:  MOVFF  5AB,68B
4BDA:  MOVFF  5AA,68A
4BDE:  MOVLB  0
4BE0:  CALL   261E
4BE4:  MOVF   01,W
4BE6:  SUBLW  FF
4BE8:  BNZ   4BF0
....................         return EOF; 
4BEA:  MOVLW  FF
4BEC:  MOVWF  01
4BEE:  BRA    4BFC
....................       i += 1; 
4BF0:  MOVLW  01
4BF2:  MOVLB  5
4BF4:  ADDWF  xAC,F
....................    } 
4BF6:  BRA    4BAE
....................  
....................    return GOODEC; 
4BF8:  MOVLW  00
4BFA:  MOVWF  01
4BFC:  MOVLB  0
.................... } 
4BFE:  RETLW  00
....................  
.................... /* 
.................... signed int fatprintf(FILE* stream) 
.................... Summary: This will print off the entire contents of the stream to the console. 
.................... Param: The stream to print off. 
.................... Returns: The last character printed off to the console. 
.................... */ 
.................... signed int fatprintf(FILE* stream) 
.................... { 
....................    signed int ch; // character read in 
....................  
....................    // keep on printf any characters read in as long as we don't run into an end of file or a media error 
....................    do 
....................    { 
....................       ch = fatgetc(stream); 
*
55C6:  MOVFF  5A5,5A8
55CA:  MOVFF  5A4,5A7
55CE:  BRA    54B0
55D0:  MOVFF  01,5A6
....................       printf("%c", ch); 
55D4:  MOVLB  5
55D6:  MOVF   xA6,W
55D8:  BTFSS  F9E.4
55DA:  BRA    55D8
55DC:  MOVWF  FAD
....................    } while(ch != EOF); 
55DE:  MOVF   xA6,W
55E0:  SUBLW  FF
55E2:  BTFSC  FD8.2
55E4:  BRA    55EA
55E6:  MOVLB  0
55E8:  BRA    55C6
....................  
....................    return ch; 
55EA:  MOVFF  5A6,01
.................... } 
55EE:  MOVLB  0
55F0:  GOTO   566A (RETURN)
....................  
.................... /* 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param stream: The stream to get the position of. 
.................... Param position: A pointer to a variable put the current position of the pointer into. 
.................... Returns: 0 on success. 
.................... */ 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... { 
....................    *position = stream->Size - stream->Bytes_Until_EOF; 
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Sets the current position of where the stream is pointing to in memory relative to the beginning of the stream. 
.................... Param stream: The stream to set the position of. 
.................... Param position: A pointer the a variable that has the value of the new position. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... { 
.................... #ifndef FAST_FAT 
.................... #ifdef FAT32 
....................    int32 cur_cluster; // the current cluster we're pointing to 
.................... #else // FAT16 
....................    int16 cur_cluster; // the current cluster we're pointing to 
.................... #endif // #ifdef FAT32 
....................    int32 i;    // pointer to memory 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // check to see if we want to just rewind the file 
....................    if(*position == 0) 
*
28FC:  MOVFF  682,03
2900:  MOVLB  6
2902:  MOVFF  681,FE9
2906:  MOVFF  682,FEA
290A:  MOVFF  FEF,689
290E:  MOVFF  FEC,68A
2912:  MOVFF  FEC,68B
2916:  MOVFF  FEC,68C
291A:  MOVF   x89,F
291C:  BNZ   2940
291E:  MOVF   x8A,F
2920:  BNZ   2940
2922:  MOVF   x8B,F
2924:  BNZ   2940
2926:  MOVF   x8C,F
2928:  BNZ   2940
....................    { 
....................       rewind(stream); 
292A:  MOVFF  680,68A
292E:  MOVFF  67F,689
2932:  MOVLB  0
2934:  GOTO   2032
....................       return GOODEC; 
2938:  MOVLW  00
293A:  MOVWF  01
293C:  BRA    2D16
293E:  MOVLB  6
....................    } 
....................     
....................    // this whole process is much different and easier if we're writing or appending at a spot after EOF 
....................    //  this will essentially write null characters to the file from EOF to the desired position 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->Size < *position)) 
2940:  MOVLW  19
2942:  ADDWF  x7F,W
2944:  MOVWF  FE9
2946:  MOVLW  00
2948:  ADDWFC x80,W
294A:  MOVWF  FEA
294C:  BTFSC  FEF.1
294E:  BRA    2960
2950:  MOVLW  19
2952:  ADDWF  x7F,W
2954:  MOVWF  FE9
2956:  MOVLW  00
2958:  ADDWFC x80,W
295A:  MOVWF  FEA
295C:  BTFSS  FEF.2
295E:  BRA    2A2C
2960:  MOVLW  10
2962:  ADDWF  x7F,W
2964:  MOVWF  FE9
2966:  MOVLW  00
2968:  ADDWFC x80,W
296A:  MOVWF  FEA
296C:  MOVFF  FEF,689
2970:  MOVFF  FEC,68A
2974:  MOVFF  FEC,68B
2978:  MOVFF  FEC,68C
297C:  MOVFF  681,FE9
2980:  MOVFF  682,FEA
2984:  MOVFF  FEF,00
2988:  MOVFF  FEC,01
298C:  MOVFF  FEC,02
2990:  MOVFF  FEC,03
2994:  MOVF   x8C,W
2996:  SUBWF  03,W
2998:  BNC   2A2C
299A:  BNZ   29B2
299C:  MOVF   x8B,W
299E:  SUBWF  02,W
29A0:  BNC   2A2C
29A2:  BNZ   29B2
29A4:  MOVF   x8A,W
29A6:  SUBWF  01,W
29A8:  BNC   2A2C
29AA:  BNZ   29B2
29AC:  MOVF   00,W
29AE:  SUBWF  x89,W
29B0:  BC    2A2C
....................    { 
....................       while(stream->Size < *position) 
....................          if(fatputc('\0', stream) == EOF) 
29B2:  MOVLW  10
29B4:  ADDWF  x7F,W
29B6:  MOVWF  FE9
29B8:  MOVLW  00
29BA:  ADDWFC x80,W
29BC:  MOVWF  FEA
29BE:  MOVFF  FEF,689
29C2:  MOVFF  FEC,68A
29C6:  MOVFF  FEC,68B
29CA:  MOVFF  FEC,68C
29CE:  MOVFF  681,FE9
29D2:  MOVFF  682,FEA
29D6:  MOVFF  FEF,00
29DA:  MOVFF  FEC,01
29DE:  MOVFF  FEC,02
29E2:  MOVFF  FEC,03
29E6:  MOVF   x8C,W
29E8:  SUBWF  03,W
29EA:  BNC   2A22
29EC:  BNZ   2A04
29EE:  MOVF   x8B,W
29F0:  SUBWF  02,W
29F2:  BNC   2A22
29F4:  BNZ   2A04
29F6:  MOVF   x8A,W
29F8:  SUBWF  01,W
29FA:  BNC   2A22
29FC:  BNZ   2A04
29FE:  MOVF   00,W
2A00:  SUBWF  x89,W
2A02:  BC    2A22
2A04:  CLRF   x89
2A06:  MOVFF  680,68B
2A0A:  MOVFF  67F,68A
2A0E:  MOVLB  0
2A10:  RCALL  261E
2A12:  MOVF   01,W
2A14:  SUBLW  FF
2A16:  BNZ   2A1E
....................             return EOF; 
2A18:  MOVLW  FF
2A1A:  MOVWF  01
2A1C:  BRA    2D16
2A1E:  MOVLB  6
2A20:  BRA    29B2
....................        
....................       return 0; 
2A22:  MOVLW  00
2A24:  MOVWF  01
2A26:  MOVLB  0
2A28:  BRA    2D16
2A2A:  MOVLB  6
....................    } 
....................  
.................... #ifdef FAST_FAT 
....................    stream->Cur_Char = stream->Start_Addr + *position; 
.................... #else // NO FAST_FAT 
....................    // figure out how many clusters into the file the position is to be set to 
....................    i = *position / Bytes_Per_Cluster; 
2A2C:  MOVFF  682,03
2A30:  MOVFF  681,FE9
2A34:  MOVFF  682,FEA
2A38:  MOVFF  FEF,689
2A3C:  MOVFF  FEC,68A
2A40:  MOVFF  FEC,68B
2A44:  MOVFF  FEC,68C
2A48:  MOVFF  FEA,68E
2A4C:  MOVFF  FE9,68D
2A50:  MOVFF  68C,6A5
2A54:  MOVFF  68B,6A4
2A58:  MOVFF  68A,6A3
2A5C:  MOVFF  689,6A2
2A60:  CLRF   xA9
2A62:  CLRF   xA8
2A64:  MOVFF  215,6A7
2A68:  MOVFF  214,6A6
2A6C:  MOVLB  0
2A6E:  CALL   0EE4
2A72:  MOVFF  68E,FEA
2A76:  MOVFF  68D,FE9
2A7A:  MOVFF  03,688
2A7E:  MOVFF  02,687
2A82:  MOVFF  01,686
2A86:  MOVFF  00,685
....................    cur_cluster = addr_to_cluster(stream->Start_Addr); 
2A8A:  MOVLW  14
2A8C:  MOVLB  6
2A8E:  ADDWF  x7F,W
2A90:  MOVWF  FE9
2A92:  MOVLW  00
2A94:  ADDWFC x80,W
2A96:  MOVWF  FEA
2A98:  MOVFF  FEF,689
2A9C:  MOVFF  FEC,68A
2AA0:  MOVFF  FEC,68B
2AA4:  MOVFF  FEC,68C
2AA8:  MOVFF  68C,69D
2AAC:  MOVFF  68B,69C
2AB0:  MOVFF  68A,69B
2AB4:  MOVFF  689,69A
2AB8:  MOVLB  0
2ABA:  CALL   188E
2ABE:  MOVFF  02,684
2AC2:  MOVFF  01,683
....................  
....................    // head to that cluster 
....................    while(i > 0) 
....................    { 
2AC6:  MOVLB  6
2AC8:  MOVF   x85,F
2ACA:  BNZ   2AD8
2ACC:  MOVF   x86,F
2ACE:  BNZ   2AD8
2AD0:  MOVF   x87,F
2AD2:  BNZ   2AD8
2AD4:  MOVF   x88,F
2AD6:  BZ    2B00
....................       if(get_next_cluster(&cur_cluster) != GOODEC) 
2AD8:  MOVLW  06
2ADA:  MOVWF  x97
2ADC:  MOVLW  83
2ADE:  MOVWF  x96
2AE0:  MOVLB  0
2AE2:  CALL   1E3C
2AE6:  MOVF   01,F
2AE8:  BZ    2AF0
....................          return EOF; 
2AEA:  MOVLW  FF
2AEC:  MOVWF  01
2AEE:  BRA    2D16
....................       i -= 1; 
2AF0:  MOVLW  01
2AF2:  MOVLB  6
2AF4:  SUBWF  x85,F
2AF6:  MOVLW  00
2AF8:  SUBWFB x86,F
2AFA:  SUBWFB x87,F
2AFC:  SUBWFB x88,F
....................    } 
2AFE:  BRA    2AC8
....................  
....................    // head to the correct cluster 
....................    stream->Cur_Char = cluster_to_addr(cur_cluster); 
2B00:  MOVLW  04
2B02:  ADDWF  x7F,W
2B04:  MOVWF  01
2B06:  MOVLW  00
2B08:  ADDWFC x80,W
2B0A:  MOVWF  03
2B0C:  MOVFF  01,689
2B10:  MOVWF  x8A
2B12:  MOVFF  684,6C2
2B16:  MOVFF  683,6C1
2B1A:  MOVLB  0
2B1C:  CALL   19DA
2B20:  MOVFF  68A,FEA
2B24:  MOVFF  689,FE9
2B28:  MOVFF  00,FEF
2B2C:  MOVFF  01,FEC
2B30:  MOVFF  02,FEC
2B34:  MOVFF  03,FEC
....................  
....................    // now that we're in the correct cluster, tack on the remaining position 
....................    stream->Cur_Char += (*position % Bytes_Per_Cluster); 
2B38:  MOVLW  04
2B3A:  MOVLB  6
2B3C:  ADDWF  x7F,W
2B3E:  MOVWF  01
2B40:  MOVLW  00
2B42:  ADDWFC x80,W
2B44:  MOVFF  01,689
2B48:  MOVWF  x8A
2B4A:  MOVWF  FEA
2B4C:  MOVFF  01,FE9
2B50:  MOVFF  FEF,68B
2B54:  MOVFF  FEC,68C
2B58:  MOVFF  FEC,68D
2B5C:  MOVFF  FEC,68E
2B60:  MOVFF  682,03
2B64:  MOVFF  681,FE9
2B68:  MOVFF  682,FEA
2B6C:  MOVFF  FEF,68F
2B70:  MOVFF  FEC,690
2B74:  MOVFF  FEC,691
2B78:  MOVFF  FEC,692
2B7C:  MOVF   FED,F
2B7E:  MOVF   FED,F
2B80:  MOVF   FED,F
2B82:  MOVFF  FEA,694
2B86:  MOVFF  FE9,693
2B8A:  MOVFF  692,6A5
2B8E:  MOVFF  691,6A4
2B92:  MOVFF  690,6A3
2B96:  MOVFF  68F,6A2
2B9A:  CLRF   xA9
2B9C:  CLRF   xA8
2B9E:  MOVFF  215,6A7
2BA2:  MOVFF  214,6A6
2BA6:  MOVLB  0
2BA8:  CALL   0EE4
2BAC:  MOVFF  FEF,00
2BB0:  MOVFF  FEC,01
2BB4:  MOVFF  FEC,02
2BB8:  MOVFF  FEC,03
2BBC:  MOVFF  694,FEA
2BC0:  MOVFF  693,FE9
2BC4:  MOVLB  6
2BC6:  MOVF   x8B,W
2BC8:  ADDWF  00,F
2BCA:  MOVF   x8C,W
2BCC:  ADDWFC 01,F
2BCE:  MOVF   x8D,W
2BD0:  ADDWFC 02,F
2BD2:  MOVF   x8E,W
2BD4:  ADDWFC 03,F
2BD6:  MOVFF  68A,FEA
2BDA:  MOVFF  689,FE9
2BDE:  MOVFF  00,FEF
2BE2:  MOVFF  01,FEC
2BE6:  MOVFF  02,FEC
2BEA:  MOVFF  03,FEC
....................  
....................    if(stream->Flags & Read) 
2BEE:  MOVLW  19
2BF0:  ADDWF  x7F,W
2BF2:  MOVWF  FE9
2BF4:  MOVLW  00
2BF6:  ADDWFC x80,W
2BF8:  MOVWF  FEA
2BFA:  BTFSS  FEF.0
2BFC:  BRA    2CD4
....................    { 
....................       // we now need to change how far it is until EOF 
....................       stream->Bytes_Until_EOF = stream->Size - *position; 
2BFE:  MOVLW  10
2C00:  ADDWF  x7F,W
2C02:  MOVWF  FE9
2C04:  MOVLW  00
2C06:  ADDWFC x80,W
2C08:  MOVWF  FEA
2C0A:  MOVFF  FEF,68B
2C0E:  MOVFF  FEC,68C
2C12:  MOVFF  FEC,68D
2C16:  MOVFF  FEC,68E
2C1A:  MOVFF  681,FE9
2C1E:  MOVFF  682,FEA
2C22:  MOVFF  FEF,00
2C26:  MOVFF  FEC,01
2C2A:  MOVFF  FEC,02
2C2E:  MOVFF  FEC,03
2C32:  MOVF   00,W
2C34:  SUBWF  x8B,W
2C36:  MOVWF  00
2C38:  MOVF   01,W
2C3A:  SUBWFB x8C,W
2C3C:  MOVWF  01
2C3E:  MOVF   02,W
2C40:  SUBWFB x8D,W
2C42:  MOVWF  02
2C44:  MOVF   03,W
2C46:  SUBWFB x8E,W
2C48:  MOVFF  680,FEA
2C4C:  MOVFF  67F,FE9
2C50:  MOVFF  00,FEF
2C54:  MOVFF  01,FEC
2C58:  MOVFF  02,FEC
2C5C:  MOVWF  FEC
....................  
....................       // fill up the buffer 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
2C5E:  MOVLW  04
2C60:  ADDWF  x7F,W
2C62:  MOVWF  FE9
2C64:  MOVLW  00
2C66:  ADDWFC x80,W
2C68:  MOVWF  FEA
2C6A:  MOVFF  FEF,689
2C6E:  MOVFF  FEC,68A
2C72:  MOVFF  FEC,68B
2C76:  MOVFF  FEC,68C
2C7A:  MOVLW  1A
2C7C:  ADDWF  x7F,W
2C7E:  MOVWF  01
2C80:  MOVLW  00
2C82:  ADDWFC x80,W
2C84:  MOVWF  03
2C86:  MOVFF  01,68D
2C8A:  MOVWF  x8E
2C8C:  MOVFF  68C,6AD
2C90:  MOVFF  68B,6AC
2C94:  MOVFF  68A,6AB
2C98:  MOVFF  689,6AA
2C9C:  CLRF   xAF
2C9E:  MOVLW  20
2CA0:  MOVWF  xAE
2CA2:  MOVFF  03,6B1
2CA6:  MOVFF  01,6B0
2CAA:  MOVLB  0
2CAC:  CALL   0DD6
2CB0:  MOVF   01,F
2CB2:  BZ    2CD0
....................       { 
....................          stream->Flags |= Read_Error; 
2CB4:  MOVLW  19
2CB6:  MOVLB  6
2CB8:  ADDWF  x7F,W
2CBA:  MOVWF  FE9
2CBC:  MOVLW  00
2CBE:  ADDWFC x80,W
2CC0:  MOVWF  FEA
2CC2:  MOVF   FEF,W
2CC4:  IORLW  20
2CC6:  MOVWF  FEF
....................          return EOF; 
2CC8:  MOVLW  FF
2CCA:  MOVWF  01
2CCC:  MOVLB  0
2CCE:  BRA    2D16
....................       } 
....................    } 
....................  
....................    else 
2CD0:  BRA    2D12
2CD2:  MOVLB  6
....................       stream->Size = *position; 
2CD4:  MOVLW  10
2CD6:  ADDWF  x7F,W
2CD8:  MOVWF  01
2CDA:  MOVLW  00
2CDC:  ADDWFC x80,W
2CDE:  MOVFF  01,689
2CE2:  MOVFF  681,FE9
2CE6:  MOVFF  682,FEA
2CEA:  MOVFF  FEF,00
2CEE:  MOVFF  FEC,01
2CF2:  MOVFF  FEC,02
2CF6:  MOVFF  FEC,03
2CFA:  MOVWF  FEA
2CFC:  MOVFF  689,FE9
2D00:  MOVFF  00,FEF
2D04:  MOVFF  01,FEC
2D08:  MOVFF  02,FEC
2D0C:  MOVFF  03,FEC
2D10:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
....................    return 0; 
2D12:  MOVLW  00
2D14:  MOVWF  01
.................... } 
2D16:  RETLW  00
....................  
.................... /* 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... Summary: This will set the position of the file stream according to the input. The EOF flag will also be cleared. 
.................... Param stream: The stream to set the position of. 
.................... Param offset: How many bytes relative of origin the file stream position will be set. 
.................... Param origin: This will be one of 3 values... 
....................                SEEK_CUR: Set position relative to the current stream position. 
....................                SEEK_END: Set position relative to the end of the stream. 
....................                SEEK_SET: Set position relative to the beginning of the stream. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... { 
....................    int32 myoffset;   // since fatsetpos requires a pointer to a variable, we need this here 
....................  
....................    switch(origin) 
....................    { 
*
527C:  MOVLB  5
527E:  MOVF   xAA,W
5280:  XORLW  00
5282:  MOVLB  0
5284:  BZ    5290
5286:  XORLW  01
5288:  BZ    52EA
528A:  XORLW  03
528C:  BZ    5344
528E:  BRA    5378
....................       case SEEK_CUR: 
....................          myoffset = stream->Cur_Char + offset; 
5290:  MOVLW  04
5292:  MOVLB  5
5294:  ADDWF  xA4,W
5296:  MOVWF  FE9
5298:  MOVLW  00
529A:  ADDWFC xA5,W
529C:  MOVWF  FEA
529E:  MOVFF  FEF,5AF
52A2:  MOVFF  FEC,5B0
52A6:  MOVFF  FEC,5B1
52AA:  MOVFF  FEC,5B2
52AE:  MOVF   xA6,W
52B0:  ADDWF  xAF,W
52B2:  MOVWF  xAB
52B4:  MOVF   xA7,W
52B6:  ADDWFC xB0,W
52B8:  MOVWF  xAC
52BA:  MOVF   xA8,W
52BC:  ADDWFC xB1,W
52BE:  MOVWF  xAD
52C0:  MOVF   xA9,W
52C2:  ADDWFC xB2,W
52C4:  MOVWF  xAE
....................          if(fatsetpos(stream, &myoffset) != 0) 
52C6:  MOVFF  5A5,680
52CA:  MOVFF  5A4,67F
52CE:  MOVLW  05
52D0:  MOVLB  6
52D2:  MOVWF  x82
52D4:  MOVLW  AB
52D6:  MOVWF  x81
52D8:  MOVLB  0
52DA:  CALL   28FC
52DE:  MOVF   01,F
52E0:  BZ    52E8
....................             return EOF; 
52E2:  MOVLW  FF
52E4:  MOVWF  01
52E6:  BRA    5396
....................          break; 
52E8:  BRA    537E
....................       case SEEK_END: 
....................          myoffset = stream->Size - offset; 
52EA:  MOVLW  10
52EC:  MOVLB  5
52EE:  ADDWF  xA4,W
52F0:  MOVWF  FE9
52F2:  MOVLW  00
52F4:  ADDWFC xA5,W
52F6:  MOVWF  FEA
52F8:  MOVFF  FEF,5AF
52FC:  MOVFF  FEC,5B0
5300:  MOVFF  FEC,5B1
5304:  MOVFF  FEC,5B2
5308:  MOVF   xA6,W
530A:  SUBWF  xAF,W
530C:  MOVWF  xAB
530E:  MOVF   xA7,W
5310:  SUBWFB xB0,W
5312:  MOVWF  xAC
5314:  MOVF   xA8,W
5316:  SUBWFB xB1,W
5318:  MOVWF  xAD
531A:  MOVF   xA9,W
531C:  SUBWFB xB2,W
531E:  MOVWF  xAE
....................          if(fatsetpos(stream, &myoffset) != 0) 
5320:  MOVFF  5A5,680
5324:  MOVFF  5A4,67F
5328:  MOVLW  05
532A:  MOVLB  6
532C:  MOVWF  x82
532E:  MOVLW  AB
5330:  MOVWF  x81
5332:  MOVLB  0
5334:  CALL   28FC
5338:  MOVF   01,F
533A:  BZ    5342
....................             return EOF; 
533C:  MOVLW  FF
533E:  MOVWF  01
5340:  BRA    5396
....................          break; 
5342:  BRA    537E
....................       case SEEK_SET: 
....................          myoffset = offset; 
5344:  MOVFF  5A9,5AE
5348:  MOVFF  5A8,5AD
534C:  MOVFF  5A7,5AC
5350:  MOVFF  5A6,5AB
....................          if(fatsetpos(stream, &myoffset) != 0) 
5354:  MOVFF  5A5,680
5358:  MOVFF  5A4,67F
535C:  MOVLW  05
535E:  MOVLB  6
5360:  MOVWF  x82
5362:  MOVLW  AB
5364:  MOVWF  x81
5366:  MOVLB  0
5368:  CALL   28FC
536C:  MOVF   01,F
536E:  BZ    5376
....................             return EOF; 
5370:  MOVLW  FF
5372:  MOVWF  01
5374:  BRA    5396
....................          break; 
5376:  BRA    537E
....................       default: 
....................          return EOF; 
5378:  MOVLW  FF
537A:  MOVWF  01
537C:  BRA    5396
....................    } 
....................  
....................    // clear the EOF flag 
....................    stream->Flags &= 0xEF; 
537E:  MOVLW  19
5380:  MOVLB  5
5382:  ADDWF  xA4,W
5384:  MOVWF  FE9
5386:  MOVLW  00
5388:  ADDWFC xA5,W
538A:  MOVWF  FEA
538C:  MOVF   FEF,W
538E:  ANDLW  EF
5390:  MOVWF  FEF
....................  
....................    return GOODEC; 
5392:  MOVLW  00
5394:  MOVWF  01
5396:  MOVLB  0
.................... } 
5398:  GOTO   565C (RETURN)
....................  
.................... /* 
.................... signed int fateof(FILE* stream) 
.................... Summary: Determines whether or not the stream is at the end of the file. 
.................... Param: The stream to query for EOF. 
.................... Returns: A non-zero value if the file is at EOF, 
....................           0 if the file is not at EOF. 
.................... */ 
.................... signed int fateof(FILE* stream) 
.................... { 
....................    return stream->Flags & EOF_Reached; 
.................... } 
....................  
.................... /* 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... Summary: Fills up an array with data from a stream. 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to fill in the array. 
.................... Param stream: The stream to read from. 
.................... Returns: How many values were written to the array. 
.................... */ 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // fill up every byte 
....................    for(i = 0; i < (num * size); i += 1) 
....................       buffer[i] = fatgetc(stream); 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... Summary: Fills up a stream with data from an array 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to write to the stream. 
.................... Param stream: The stream to write to. 
.................... Returns: How many values were written to the stream. 
.................... */ 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // write every byte 
....................    for(i = 0; i < (count * (int32)size); i += 1) 
....................       if(fatputc(buffer[i], stream) == EOF) 
....................          return EOF; 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatflush(FILE* stream) 
.................... Summary: Flushes the buffer of a given stream. 
.................... Param: The stream to flush the buffer of. 
.................... Returns: EOF if there was a problem, 0 if everything went okay 
.................... */ 
.................... signed int fatflush(FILE* stream) 
.................... { 
....................    // check to see if we have a buffer 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
*
372E:  MOVLW  19
3730:  MOVLB  5
3732:  ADDWF  xF2,W
3734:  MOVWF  FE9
3736:  MOVLW  00
3738:  ADDWFC xF3,W
373A:  MOVWF  FEA
373C:  BTFSC  FEF.1
373E:  BRA    3750
3740:  MOVLW  19
3742:  ADDWF  xF2,W
3744:  MOVWF  FE9
3746:  MOVLW  00
3748:  ADDWFC xF3,W
374A:  MOVWF  FEA
374C:  BTFSS  FEF.2
374E:  BRA    38C0
....................    { 
....................       // check to see if we need to flush the buffer 
....................       if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
3750:  MOVLW  04
3752:  ADDWF  xF2,W
3754:  MOVWF  FE9
3756:  MOVLW  00
3758:  ADDWFC xF3,W
375A:  MOVWF  FEA
375C:  MOVFF  FEF,5F4
3760:  MOVFF  FEC,5F5
3764:  MOVFF  FEC,5F6
3768:  MOVFF  FEC,5F7
376C:  MOVLW  1F
376E:  ANDWF  xF4,F
3770:  CLRF   xF5
3772:  CLRF   xF6
3774:  CLRF   xF7
3776:  MOVF   xF4,F
3778:  BNZ   380A
377A:  MOVF   xF5,F
377C:  BNZ   380A
377E:  MOVF   xF6,F
3780:  BNZ   380A
3782:  MOVF   xF7,F
3784:  BNZ   380A
....................       { 
....................          // flush the buffer to the card 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
3786:  MOVLW  04
3788:  ADDWF  xF2,W
378A:  MOVWF  FE9
378C:  MOVLW  00
378E:  ADDWFC xF3,W
3790:  MOVWF  FEA
3792:  MOVFF  FEF,5F4
3796:  MOVFF  FEC,5F5
379A:  MOVFF  FEC,5F6
379E:  MOVFF  FEC,5F7
37A2:  MOVLW  20
37A4:  SUBWF  xF4,F
37A6:  MOVLW  00
37A8:  SUBWFB xF5,F
37AA:  SUBWFB xF6,F
37AC:  SUBWFB xF7,F
37AE:  MOVLW  1A
37B0:  ADDWF  xF2,W
37B2:  MOVWF  01
37B4:  MOVLW  00
37B6:  ADDWFC xF3,W
37B8:  MOVWF  03
37BA:  MOVFF  01,5F8
37BE:  MOVWF  xF9
37C0:  MOVFF  5F7,6C8
37C4:  MOVFF  5F6,6C7
37C8:  MOVFF  5F5,6C6
37CC:  MOVFF  5F4,6C5
37D0:  MOVLB  6
37D2:  CLRF   xCA
37D4:  MOVLW  20
37D6:  MOVWF  xC9
37D8:  MOVFF  03,6CC
37DC:  MOVFF  01,6CB
37E0:  MOVLB  0
37E2:  CALL   1EE8
37E6:  MOVF   01,F
37E8:  BZ    3806
....................          { 
....................             stream->Flags |= Write_Error; 
37EA:  MOVLW  19
37EC:  MOVLB  5
37EE:  ADDWF  xF2,W
37F0:  MOVWF  FE9
37F2:  MOVLW  00
37F4:  ADDWFC xF3,W
37F6:  MOVWF  FEA
37F8:  MOVF   FEF,W
37FA:  IORLW  40
37FC:  MOVWF  FEF
....................             return EOF; 
37FE:  MOVLW  FF
3800:  MOVWF  01
3802:  BRA    38C4
3804:  MOVLB  0
....................          } 
....................       } 
....................       else 
3806:  BRA    38B6
3808:  MOVLB  5
....................       { 
....................          // flush the buffer to the card 
....................          //  we need to make sure that the buffer gets flushed into the proper location, hence all this weird % math 
....................          if(mmcsd_write_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
380A:  MOVLW  04
380C:  ADDWF  xF2,W
380E:  MOVWF  FE9
3810:  MOVLW  00
3812:  ADDWFC xF3,W
3814:  MOVWF  FEA
3816:  MOVFF  FEF,5F4
381A:  MOVFF  FEC,5F5
381E:  MOVFF  FEC,5F6
3822:  MOVFF  FEC,5F7
3826:  MOVLW  04
3828:  ADDWF  xF2,W
382A:  MOVWF  FE9
382C:  MOVLW  00
382E:  ADDWFC xF3,W
3830:  MOVWF  FEA
3832:  MOVFF  FEF,5F8
3836:  MOVFF  FEC,5F9
383A:  MOVFF  FEC,5FA
383E:  MOVFF  FEC,5FB
3842:  MOVF   xF8,W
3844:  ANDLW  1F
3846:  MOVWF  00
3848:  CLRF   01
384A:  CLRF   02
384C:  CLRF   03
384E:  MOVF   00,W
3850:  SUBWF  xF4,F
3852:  MOVF   01,W
3854:  SUBWFB xF5,F
3856:  MOVF   02,W
3858:  SUBWFB xF6,F
385A:  MOVF   03,W
385C:  SUBWFB xF7,F
385E:  MOVLW  1A
3860:  ADDWF  xF2,W
3862:  MOVWF  01
3864:  MOVLW  00
3866:  ADDWFC xF3,W
3868:  MOVWF  03
386A:  MOVFF  01,5F8
386E:  MOVWF  xF9
3870:  MOVFF  5F7,6C8
3874:  MOVFF  5F6,6C7
3878:  MOVFF  5F5,6C6
387C:  MOVFF  5F4,6C5
3880:  MOVLB  6
3882:  CLRF   xCA
3884:  MOVLW  20
3886:  MOVWF  xC9
3888:  MOVFF  03,6CC
388C:  MOVFF  01,6CB
3890:  MOVLB  0
3892:  CALL   1EE8
3896:  MOVF   01,F
3898:  BZ    38B6
....................          { 
....................             stream->Flags |= Write_Error; 
389A:  MOVLW  19
389C:  MOVLB  5
389E:  ADDWF  xF2,W
38A0:  MOVWF  FE9
38A2:  MOVLW  00
38A4:  ADDWFC xF3,W
38A6:  MOVWF  FEA
38A8:  MOVF   FEF,W
38AA:  IORLW  40
38AC:  MOVWF  FEF
....................             return EOF; 
38AE:  MOVLW  FF
38B0:  MOVWF  01
38B2:  BRA    38C4
38B4:  MOVLB  0
....................          } 
....................       } 
....................       return(mmcsd_flush_buffer()); 
38B6:  CALL   0CA2
38BA:  MOVF   01,W
38BC:  MOVLB  5
38BE:  BRA    38C4
....................    } 
....................    return 0; 
38C0:  MOVLW  00
38C2:  MOVWF  01
.................... } 
38C4:  MOVLB  0
38C6:  GOTO   3B5A (RETURN)
....................  
.................... /* 
.................... signed int remove(char* fname) 
.................... Summary: Removes a file from disk. 
.................... Param: The full path of the file to remove. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... Note: This function does not work for removing directories, use rm_dir instead. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int remove(char* fname) 
.................... { 
....................    if(rm_file(fname) == EOF) 
....................        return EOF; 
....................  
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int faterror(FILE* stream) 
.................... Summary: Checks for an error in a given stream. 
.................... Param: The stream to check for an error in. 
.................... Returns: A non-zero value of there is an error in the stream, 
....................           0 if there is no error in the stream 
.................... */ 
.................... signed int faterror(FILE* stream) 
.................... { 
....................    return stream->Flags & 0xF0; 
.................... } 
....................  
.................... /* 
.................... void clearerr(FILE* stream) 
.................... Summary: Clears off all error in a given stream. 
.................... Param: The stream to clear off the errors in. 
.................... Returns: Nothing. 
.................... */ 
.................... void clearerr(FILE* stream) 
.................... { 
....................    stream->Flags &= 0x0F; 
.................... } 
....................  
.................... /* 
.................... void rewind(FILE* stream) 
.................... Summary: Sets the stream to point back to the beginning of a file. 
.................... Param: The stream to rewind. 
.................... Returns: Nothing. 
.................... */ 
.................... void rewind(FILE* stream) 
.................... { 
....................    // set the stream back to the beginning 
....................    stream->Cur_Char = stream->Start_Addr; 
*
2032:  MOVLW  04
2034:  MOVLB  6
2036:  ADDWF  x89,W
2038:  MOVWF  01
203A:  MOVLW  00
203C:  ADDWFC x8A,W
203E:  MOVWF  03
2040:  MOVFF  01,68B
2044:  MOVWF  x8C
2046:  MOVLW  14
2048:  ADDWF  x89,W
204A:  MOVWF  FE9
204C:  MOVLW  00
204E:  ADDWFC x8A,W
2050:  MOVWF  FEA
2052:  MOVFF  FEF,00
2056:  MOVFF  FEC,01
205A:  MOVFF  FEC,02
205E:  MOVFF  FEC,03
2062:  MOVFF  68C,FEA
2066:  MOVFF  68B,FE9
206A:  MOVFF  00,FEF
206E:  MOVFF  01,FEC
2072:  MOVFF  02,FEC
2076:  MOVFF  03,FEC
....................    stream->Bytes_Until_EOF = stream->Size; 
207A:  MOVLW  10
207C:  ADDWF  x89,W
207E:  MOVWF  FE9
2080:  MOVLW  00
2082:  ADDWFC x8A,W
2084:  MOVWF  FEA
2086:  MOVFF  FEF,00
208A:  MOVFF  FEC,01
208E:  MOVFF  FEC,02
2092:  MOVFF  FEC,03
2096:  MOVFF  68A,FEA
209A:  MOVFF  689,FE9
209E:  MOVFF  00,FEF
20A2:  MOVFF  01,FEC
20A6:  MOVFF  02,FEC
20AA:  MOVFF  03,FEC
.................... } 
20AE:  MOVLB  0
20B0:  GOTO   2938 (RETURN)
....................  
.................... /* 
.................... fatpos_t fattell(FILE* stream) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param: The stream to return the position of. 
.................... Returns: The position of where the stream is pointing to relative to the beginning of the stream, or 0 if there was a problem. 
.................... */ 
.................... fatpos_t fattell(FILE* stream) 
.................... { 
....................    fatpos_t retval; 
....................  
....................    if(fatgetpos(stream, &retval) != 0) 
....................       return 0; 
....................  
....................    return retval; 
.................... } 
....................  
.................... /// Non-Standard C Functions /// 
....................  
.................... /* 
.................... signed int rm_file(char fname[]) 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int rm_file(char fname[]) 
.................... { 
*
3BFA:  MOVLW  E5
3BFC:  MOVLB  5
3BFE:  MOVWF  xAA
....................    int 
....................       order, 
....................       ulinked_entry = 0xE5; // 0xE5 is put into the file's entry to indicate unlinking 
....................  
....................    int32 i; 
....................  
....................    char mode[] = "r";        // r is the safest mode to remove files with 
3C00:  MOVLW  72
3C02:  MOVWF  xAF
3C04:  CLRF   xB0
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(fname, mode, &stream) == EOF) 
3C06:  MOVFF  5A8,5EF
3C0A:  MOVFF  5A7,5EE
3C0E:  MOVLW  05
3C10:  MOVWF  xF1
3C12:  MOVLW  AF
3C14:  MOVWF  xF0
3C16:  MOVLW  05
3C18:  MOVWF  xF3
3C1A:  MOVLW  B1
3C1C:  MOVWF  xF2
3C1E:  MOVLB  0
3C20:  RCALL  3474
3C22:  MOVF   01,W
3C24:  SUBLW  FF
3C26:  BNZ   3C2E
....................       return EOF; 
3C28:  MOVLW  FF
3C2A:  MOVWF  01
3C2C:  BRA    3DFA
....................  
....................    // we need to un-link the file's clusters from the FAT if there are clusters allocated 
....................    if(stream.Start_Addr > Root_Dir) 
3C2E:  MOVLB  2
3C30:  MOVF   x27,W
3C32:  MOVLB  5
3C34:  SUBWF  xC8,W
3C36:  BNC   3C9A
3C38:  BNZ   3C62
3C3A:  MOVLB  2
3C3C:  MOVF   x26,W
3C3E:  MOVLB  5
3C40:  SUBWF  xC7,W
3C42:  BNC   3C9A
3C44:  BNZ   3C62
3C46:  MOVLB  2
3C48:  MOVF   x25,W
3C4A:  MOVLB  5
3C4C:  SUBWF  xC6,W
3C4E:  BNC   3C9A
3C50:  BNZ   3C62
3C52:  MOVF   xC5,W
3C54:  MOVLB  2
3C56:  SUBWF  x24,W
3C58:  BTFSS  FD8.0
3C5A:  BRA    3C60
3C5C:  MOVLB  5
3C5E:  BRA    3C9A
3C60:  MOVLB  5
....................    { 
....................       if(dealloc_clusters(addr_to_cluster(stream.Start_Addr)) == EOF) 
3C62:  MOVFF  5C8,69D
3C66:  MOVFF  5C7,69C
3C6A:  MOVFF  5C6,69B
3C6E:  MOVFF  5C5,69A
3C72:  MOVLB  0
3C74:  CALL   188E
3C78:  MOVFF  02,5EC
3C7C:  MOVFF  01,5EB
3C80:  MOVFF  02,680
3C84:  MOVFF  01,67F
3C88:  CALL   1FC4
3C8C:  MOVF   01,W
3C8E:  SUBLW  FF
3C90:  BNZ   3C98
....................          return EOF; 
3C92:  MOVLW  FF
3C94:  MOVWF  01
3C96:  BRA    3DFA
3C98:  MOVLB  5
....................    } 
....................    // get rid of the first entry 
....................    i = stream.Entry_Addr; 
3C9A:  MOVFF  5BC,5AE
3C9E:  MOVFF  5BB,5AD
3CA2:  MOVFF  5BA,5AC
3CA6:  MOVFF  5B9,5AB
....................    if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
3CAA:  MOVFF  5AE,6C8
3CAE:  MOVFF  5AD,6C7
3CB2:  MOVFF  5AC,6C6
3CB6:  MOVFF  5AB,6C5
3CBA:  MOVLB  6
3CBC:  CLRF   xCA
3CBE:  MOVLW  01
3CC0:  MOVWF  xC9
3CC2:  MOVLW  05
3CC4:  MOVWF  xCC
3CC6:  MOVLW  AA
3CC8:  MOVWF  xCB
3CCA:  MOVLB  0
3CCC:  CALL   1EE8
3CD0:  MOVF   01,W
3CD2:  SUBLW  FF
3CD4:  BNZ   3CDC
....................       return EOF; 
3CD6:  MOVLW  FF
3CD8:  MOVWF  01
3CDA:  BRA    3DFA
....................     
....................    // check to see if there is a long file name 
....................    get_prev_entry(&i); 
3CDC:  MOVLW  05
3CDE:  MOVLB  6
3CE0:  MOVWF  x8C
3CE2:  MOVLW  AB
3CE4:  MOVWF  x8B
3CE6:  MOVLB  0
3CE8:  CALL   1BDA
....................    if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
3CEC:  MOVLW  0B
3CEE:  MOVLB  5
3CF0:  ADDWF  xAB,W
3CF2:  MOVWF  xEB
3CF4:  MOVLW  00
3CF6:  ADDWFC xAC,W
3CF8:  MOVWF  xEC
3CFA:  MOVLW  00
3CFC:  ADDWFC xAD,W
3CFE:  MOVWF  xED
3D00:  MOVLW  00
3D02:  ADDWFC xAE,W
3D04:  MOVWF  xEE
3D06:  MOVFF  FE8,6AD
3D0A:  MOVFF  5ED,6AC
3D0E:  MOVFF  5EC,6AB
3D12:  MOVFF  5EB,6AA
3D16:  MOVLB  6
3D18:  CLRF   xAF
3D1A:  MOVLW  01
3D1C:  MOVWF  xAE
3D1E:  MOVLW  05
3D20:  MOVWF  xB1
3D22:  MOVLW  A9
3D24:  MOVWF  xB0
3D26:  MOVLB  0
3D28:  CALL   0DD6
3D2C:  MOVF   01,W
3D2E:  SUBLW  FF
3D30:  BNZ   3D38
....................       return EOF; 
3D32:  MOVLW  FF
3D34:  MOVWF  01
3D36:  BRA    3DFA
....................  
....................    // get rid of all of the long file name entries if they're there 
....................    while(order == 0x0F) 
....................    { 
3D38:  MOVLB  5
3D3A:  MOVF   xA9,W
3D3C:  SUBLW  0F
3D3E:  BNZ   3DDE
....................       if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
3D40:  MOVFF  5AE,6C8
3D44:  MOVFF  5AD,6C7
3D48:  MOVFF  5AC,6C6
3D4C:  MOVFF  5AB,6C5
3D50:  MOVLB  6
3D52:  CLRF   xCA
3D54:  MOVLW  01
3D56:  MOVWF  xC9
3D58:  MOVLW  05
3D5A:  MOVWF  xCC
3D5C:  MOVLW  AA
3D5E:  MOVWF  xCB
3D60:  MOVLB  0
3D62:  CALL   1EE8
3D66:  MOVF   01,W
3D68:  SUBLW  FF
3D6A:  BNZ   3D72
....................          return EOF; 
3D6C:  MOVLW  FF
3D6E:  MOVWF  01
3D70:  BRA    3DFA
....................  
....................       if(get_prev_entry(&i) == EOF) 
3D72:  MOVLW  05
3D74:  MOVLB  6
3D76:  MOVWF  x8C
3D78:  MOVLW  AB
3D7A:  MOVWF  x8B
3D7C:  MOVLB  0
3D7E:  CALL   1BDA
3D82:  MOVF   01,W
3D84:  SUBLW  FF
3D86:  BNZ   3D8E
....................          return EOF; 
3D88:  MOVLW  FF
3D8A:  MOVWF  01
3D8C:  BRA    3DFA
....................  
....................       if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
3D8E:  MOVLW  0B
3D90:  MOVLB  5
3D92:  ADDWF  xAB,W
3D94:  MOVWF  xEB
3D96:  MOVLW  00
3D98:  ADDWFC xAC,W
3D9A:  MOVWF  xEC
3D9C:  MOVLW  00
3D9E:  ADDWFC xAD,W
3DA0:  MOVWF  xED
3DA2:  MOVLW  00
3DA4:  ADDWFC xAE,W
3DA6:  MOVWF  xEE
3DA8:  MOVFF  FE8,6AD
3DAC:  MOVFF  5ED,6AC
3DB0:  MOVFF  5EC,6AB
3DB4:  MOVFF  5EB,6AA
3DB8:  MOVLB  6
3DBA:  CLRF   xAF
3DBC:  MOVLW  01
3DBE:  MOVWF  xAE
3DC0:  MOVLW  05
3DC2:  MOVWF  xB1
3DC4:  MOVLW  A9
3DC6:  MOVWF  xB0
3DC8:  MOVLB  0
3DCA:  CALL   0DD6
3DCE:  MOVF   01,W
3DD0:  SUBLW  FF
3DD2:  BNZ   3DDA
....................          return EOF; 
3DD4:  MOVLW  FF
3DD6:  MOVWF  01
3DD8:  BRA    3DFA
....................    } 
3DDA:  BRA    3D38
3DDC:  MOVLB  5
....................     
....................    if(fatclose(&stream) == EOF) 
3DDE:  MOVLW  05
3DE0:  MOVWF  xEC
3DE2:  MOVLW  B1
3DE4:  MOVWF  xEB
3DE6:  MOVLB  0
3DE8:  RCALL  38CA
3DEA:  MOVF   01,W
3DEC:  SUBLW  FF
3DEE:  BNZ   3DF6
....................       return EOF; 
3DF0:  MOVLW  FF
3DF2:  MOVWF  01
3DF4:  BRA    3DFA
....................  
....................    return GOODEC; 
3DF6:  MOVLW  00
3DF8:  MOVWF  01
.................... } 
3DFA:  RETLW  00
....................  
.................... /* 
.................... signed int rm_dir(char dname[]) 
.................... Summary: Deletes a directory. 
.................... Param: The full path of the directory to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... Note: This function cannot remove all of the files 
....................        and subdirectories of the directory. Manually remove all subdirectories 
....................        and files before calling this command. 
.................... */ 
.................... signed int rm_dir(char dname[]) 
.................... { 
....................    char mode[] = "r";        // r is the safest mode to remove files with 
*
5B2E:  MOVLW  72
5B30:  MOVLB  5
5B32:  MOVWF  x6B
5B34:  CLRF   x6C
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(dname, mode, &stream) == EOF) 
5B36:  MOVFF  56A,5EF
5B3A:  MOVFF  569,5EE
5B3E:  MOVLW  05
5B40:  MOVWF  xF1
5B42:  MOVLW  6B
5B44:  MOVWF  xF0
5B46:  MOVLW  05
5B48:  MOVWF  xF3
5B4A:  MOVLW  6D
5B4C:  MOVWF  xF2
5B4E:  MOVLB  0
5B50:  CALL   3474
5B54:  MOVF   01,W
5B56:  SUBLW  FF
5B58:  BNZ   5B60
....................       return EOF; 
5B5A:  MOVLW  FF
5B5C:  MOVWF  01
5B5E:  BRA    5BB0
....................  
....................    // jump over the . and .. entries in the directory 
....................    stream.Entry_Addr = stream.Start_Addr + 64; 
5B60:  MOVLW  40
5B62:  MOVLB  5
5B64:  ADDWF  x81,W
5B66:  MOVWF  x75
5B68:  MOVLW  00
5B6A:  ADDWFC x82,W
5B6C:  MOVWF  x76
5B6E:  MOVLW  00
5B70:  ADDWFC x83,W
5B72:  MOVWF  x77
5B74:  MOVLW  00
5B76:  ADDWFC x84,W
5B78:  MOVWF  x78
....................     
....................    // check to make sure that there isn't stuff in this directory 
....................    if(get_next_file(&stream) != EOF) 
5B7A:  MOVLW  05
5B7C:  MOVWF  xC6
5B7E:  MOVLW  6D
5B80:  MOVWF  xC5
5B82:  MOVLB  0
5B84:  CALL   4EDE
5B88:  MOVF   01,W
5B8A:  SUBLW  FF
5B8C:  BZ    5B94
....................       return EOF; 
5B8E:  MOVLW  FF
5B90:  MOVWF  01
5B92:  BRA    5BB0
....................  
....................    // since removing files is a lot like removing directories, we 
....................    //  can just call rm_file 
....................    if(rm_file(dname) == EOF) 
5B94:  MOVFF  56A,5A8
5B98:  MOVFF  569,5A7
5B9C:  CALL   3BFA
5BA0:  MOVF   01,W
5BA2:  SUBLW  FF
5BA4:  BNZ   5BAC
....................       return EOF; 
5BA6:  MOVLW  FF
5BA8:  MOVWF  01
5BAA:  BRA    5BB0
....................  
....................    return GOODEC; 
5BAC:  MOVLW  00
5BAE:  MOVWF  01
.................... } 
5BB0:  GOTO   5C38 (RETURN)
....................  
.................... /* 
.................... signed int mk_file(char fname[]) 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int mk_file(char fname[]) 
.................... { 
*
49C4:  CLRF   xAC
....................    char 
....................       filename[MAX_FILE_NAME_LENGTH],   // the file name we're trying to make 
....................       mode[] = "r";                     // reading is the safest mode to work in 
*
49BC:  MOVLW  72
49BE:  MOVLB  5
49C0:  MOVWF  x89
49C2:  CLRF   x8A
....................  
....................    int 
....................       buf,               // buffer to hold values 
....................       entire_entry[0x20],// entire first entry 
....................       filename_pos = 0,  // the current parse position of the file name we're trying to create 
....................       fname_pos;         // the current parse position of the input the the function 
....................  
....................    int32 i;      // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(fname, mode, &stream) == GOODEC) 
*
49C6:  MOVFF  568,5EF
49CA:  MOVFF  567,5EE
49CE:  MOVLW  05
49D0:  MOVWF  xF1
49D2:  MOVLW  89
49D4:  MOVWF  xF0
49D6:  MOVLW  05
49D8:  MOVWF  xF3
49DA:  MOVLW  B2
49DC:  MOVWF  xF2
49DE:  MOVLB  0
49E0:  CALL   3474
49E4:  MOVF   01,F
49E6:  BNZ   49EE
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
49E8:  MOVLW  FF
49EA:  MOVWF  01
49EC:  BRA    4B3E
....................  
....................    // check to see if the file is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
49EE:  MOVLB  5
49F0:  BTFSC  xCB.7
49F2:  BRA    49FE
....................       return EOF; 
49F4:  MOVLW  FF
49F6:  MOVWF  01
49F8:  MOVLB  0
49FA:  BRA    4B3E
49FC:  MOVLB  5
....................  
....................    // make a file name 
....................    fname_pos = strrchr(fname, '/') - fname + 1; 
49FE:  MOVFF  568,5EF
4A02:  MOVFF  567,5EE
4A06:  MOVLW  2F
4A08:  MOVWF  xF0
4A0A:  MOVLB  0
4A0C:  CALL   3E64
4A10:  MOVFF  02,5ED
4A14:  MOVFF  01,5EC
4A18:  MOVLB  5
4A1A:  MOVF   x67,W
4A1C:  SUBWF  xEC,F
4A1E:  MOVF   x68,W
4A20:  SUBWFB xED,F
4A22:  MOVLW  01
4A24:  ADDWF  xEC,W
4A26:  MOVWF  xAD
....................    while((fname[fname_pos] != '\0') && (filename_pos < MAX_FILE_NAME_LENGTH)) 
....................    { 
4A28:  CLRF   03
4A2A:  MOVF   xAD,W
4A2C:  ADDWF  x67,W
4A2E:  MOVWF  FE9
4A30:  MOVF   x68,W
4A32:  ADDWFC 03,W
4A34:  MOVWF  FEA
4A36:  MOVF   FEF,F
4A38:  BZ    4A76
4A3A:  MOVF   xAC,W
4A3C:  SUBLW  1F
4A3E:  BNC   4A76
....................       filename[filename_pos] = fname[fname_pos]; 
4A40:  CLRF   03
4A42:  MOVF   xAC,W
4A44:  ADDLW  69
4A46:  MOVWF  01
4A48:  MOVLW  05
4A4A:  ADDWFC 03,F
4A4C:  MOVFF  03,5ED
4A50:  CLRF   03
4A52:  MOVF   xAD,W
4A54:  ADDWF  x67,W
4A56:  MOVWF  FE9
4A58:  MOVF   x68,W
4A5A:  ADDWFC 03,W
4A5C:  MOVWF  FEA
4A5E:  MOVFF  FEF,5EE
4A62:  MOVFF  5ED,FEA
4A66:  MOVFF  01,FE9
4A6A:  MOVFF  5EE,FEF
....................       fname_pos += 1; 
4A6E:  MOVLW  01
4A70:  ADDWF  xAD,F
....................       filename_pos += 1; 
4A72:  ADDWF  xAC,F
....................    } 
4A74:  BRA    4A28
....................    filename[filename_pos] = '\0'; 
4A76:  CLRF   03
4A78:  MOVF   xAC,W
4A7A:  ADDLW  69
4A7C:  MOVWF  FE9
4A7E:  MOVLW  05
4A80:  ADDWFC 03,W
4A82:  MOVWF  FEA
4A84:  CLRF   FEF
....................  
....................    // write the name 
....................    if(set_file_name(stream.Start_Addr, &i, filename) == EOF) 
4A86:  MOVFF  5C9,5F1
4A8A:  MOVFF  5C8,5F0
4A8E:  MOVFF  5C7,5EF
4A92:  MOVFF  5C6,5EE
4A96:  MOVLW  05
4A98:  MOVWF  xF3
4A9A:  MOVLW  AE
4A9C:  MOVWF  xF2
4A9E:  MOVLW  05
4AA0:  MOVWF  xF5
4AA2:  MOVLW  69
4AA4:  MOVWF  xF4
4AA6:  MOVLB  0
4AA8:  RCALL  46DC
4AAA:  MOVF   01,W
4AAC:  SUBLW  FF
4AAE:  BNZ   4AB6
....................       return EOF; 
4AB0:  MOVLW  FF
4AB2:  MOVWF  01
4AB4:  BRA    4B3E
....................  
....................    // throw in some values in the file's first entry 
....................    for(buf = 0; buf < 0x20; buf += 1) 
4AB6:  MOVLB  5
4AB8:  CLRF   x8B
4ABA:  MOVF   x8B,W
4ABC:  SUBLW  1F
4ABE:  BNC   4AD6
....................       entire_entry[buf] = 0; 
4AC0:  CLRF   03
4AC2:  MOVF   x8B,W
4AC4:  ADDLW  8C
4AC6:  MOVWF  FE9
4AC8:  MOVLW  05
4ACA:  ADDWFC 03,W
4ACC:  MOVWF  FEA
4ACE:  CLRF   FEF
4AD0:  MOVLW  01
4AD2:  ADDWF  x8B,F
4AD4:  BRA    4ABA
....................  
....................    // this is a file 
....................    entire_entry[0x0B] = 0x20; 
4AD6:  MOVLW  20
4AD8:  MOVWF  x97
....................  
....................    // read what set_file_name gave us for the short name 
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
4ADA:  MOVFF  5B1,6AD
4ADE:  MOVFF  5B0,6AC
4AE2:  MOVFF  5AF,6AB
4AE6:  MOVFF  5AE,6AA
4AEA:  MOVLB  6
4AEC:  CLRF   xAF
4AEE:  MOVLW  0B
4AF0:  MOVWF  xAE
4AF2:  MOVLW  05
4AF4:  MOVWF  xB1
4AF6:  MOVLW  8C
4AF8:  MOVWF  xB0
4AFA:  MOVLB  0
4AFC:  CALL   0DD6
4B00:  MOVF   01,F
4B02:  BZ    4B0A
....................       return EOF; 
4B04:  MOVLW  FF
4B06:  MOVWF  01
4B08:  BRA    4B3E
....................  
....................    // write the entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
4B0A:  MOVFF  5B1,6C8
4B0E:  MOVFF  5B0,6C7
4B12:  MOVFF  5AF,6C6
4B16:  MOVFF  5AE,6C5
4B1A:  MOVLB  6
4B1C:  CLRF   xCA
4B1E:  MOVLW  20
4B20:  MOVWF  xC9
4B22:  MOVLW  05
4B24:  MOVWF  xCC
4B26:  MOVLW  8C
4B28:  MOVWF  xCB
4B2A:  MOVLB  0
4B2C:  CALL   1EE8
4B30:  MOVF   01,F
4B32:  BZ    4B3A
....................       return EOF; 
4B34:  MOVLW  FF
4B36:  MOVWF  01
4B38:  BRA    4B3E
....................  
....................    return GOODEC; 
4B3A:  MOVLW  00
4B3C:  MOVWF  01
.................... } 
4B3E:  GOTO   4B84 (RETURN)
....................  
.................... /* 
.................... signed int mk_dir(char dname[]) 
.................... Summary: Creates a directory. 
.................... Param: The full path of the directory to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... */ 
.................... signed int mk_dir(char dname[]) 
.................... { 
*
5684:  CLRF   xAD
....................    char 
....................       dirname[MAX_FILE_NAME_LENGTH],    // the directory name we're trying to make 
....................       entire_entry[0x20],               // used to hold the link entries (. and ..) to the directory and its parent 
....................       mode[] = "r";                     // reading is the safest mode to work in 
*
567C:  MOVLW  72
567E:  MOVLB  5
5680:  MOVWF  xAB
5682:  CLRF   xAC
....................  
....................    int 
....................       dirname_pos = 0,   // the current parse position of the directory name we're trying to create 
....................       dname_pos,         // the current parse position of the input the the function 
....................       j;                 // counter for loops 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(dname, mode, &stream) == GOODEC) 
*
5686:  MOVFF  56A,5EF
568A:  MOVFF  569,5EE
568E:  MOVLW  05
5690:  MOVWF  xF1
5692:  MOVLW  AB
5694:  MOVWF  xF0
5696:  MOVLW  05
5698:  MOVWF  xF3
569A:  MOVLW  B4
569C:  MOVWF  xF2
569E:  MOVLB  0
56A0:  CALL   3474
56A4:  MOVF   01,F
56A6:  BNZ   56AE
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
56A8:  MOVLW  FF
56AA:  MOVWF  01
56AC:  BRA    5A82
....................  
....................    // check to see if the directory is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
56AE:  MOVLB  5
56B0:  BTFSC  xCD.7
56B2:  BRA    56BE
....................       return EOF; 
56B4:  MOVLW  FF
56B6:  MOVWF  01
56B8:  MOVLB  0
56BA:  BRA    5A82
56BC:  MOVLB  5
....................  
....................    // make the directory name 
....................    dname_pos = strrchr(dname, '/') - dname; 
56BE:  MOVFF  56A,5EF
56C2:  MOVFF  569,5EE
56C6:  MOVLW  2F
56C8:  MOVWF  xF0
56CA:  MOVLB  0
56CC:  CALL   3E64
56D0:  MOVLB  5
56D2:  MOVF   x69,W
56D4:  SUBWF  01,W
56D6:  MOVWF  xAE
....................    dname[dname_pos] = '\0'; 
56D8:  CLRF   03
56DA:  MOVF   xAE,W
56DC:  ADDWF  x69,W
56DE:  MOVWF  FE9
56E0:  MOVF   x6A,W
56E2:  ADDWFC 03,W
56E4:  MOVWF  FEA
56E6:  CLRF   FEF
....................    dname_pos = strrchr(dname, '/') - dname + 1; 
56E8:  MOVFF  56A,5EF
56EC:  MOVFF  569,5EE
56F0:  MOVLW  2F
56F2:  MOVWF  xF0
56F4:  MOVLB  0
56F6:  CALL   3E64
56FA:  MOVFF  02,5EF
56FE:  MOVFF  01,5EE
5702:  MOVLB  5
5704:  MOVF   x69,W
5706:  SUBWF  xEE,F
5708:  MOVF   x6A,W
570A:  SUBWFB xEF,F
570C:  MOVLW  01
570E:  ADDWF  xEE,W
5710:  MOVWF  xAE
....................    while((dname[dname_pos] != '\0') && (dirname_pos < MAX_FILE_NAME_LENGTH)) 
....................    { 
5712:  CLRF   03
5714:  MOVF   xAE,W
5716:  ADDWF  x69,W
5718:  MOVWF  FE9
571A:  MOVF   x6A,W
571C:  ADDWFC 03,W
571E:  MOVWF  FEA
5720:  MOVF   FEF,F
5722:  BZ    5760
5724:  MOVF   xAD,W
5726:  SUBLW  1F
5728:  BNC   5760
....................       dirname[dirname_pos] = dname[dname_pos]; 
572A:  CLRF   03
572C:  MOVF   xAD,W
572E:  ADDLW  6B
5730:  MOVWF  01
5732:  MOVLW  05
5734:  ADDWFC 03,F
5736:  MOVFF  03,5EF
573A:  CLRF   03
573C:  MOVF   xAE,W
573E:  ADDWF  x69,W
5740:  MOVWF  FE9
5742:  MOVF   x6A,W
5744:  ADDWFC 03,W
5746:  MOVWF  FEA
5748:  MOVFF  FEF,5F0
574C:  MOVFF  5EF,FEA
5750:  MOVFF  01,FE9
5754:  MOVFF  5F0,FEF
....................       dname_pos += 1; 
5758:  MOVLW  01
575A:  ADDWF  xAE,F
....................       dirname_pos += 1; 
575C:  ADDWF  xAD,F
....................    } 
575E:  BRA    5712
....................    dirname[dirname_pos] = '\0'; 
5760:  CLRF   03
5762:  MOVF   xAD,W
5764:  ADDLW  6B
5766:  MOVWF  FE9
5768:  MOVLW  05
576A:  ADDWFC 03,W
576C:  MOVWF  FEA
576E:  CLRF   FEF
....................    dname[dname_pos] = '/'; 
5770:  CLRF   03
5772:  MOVF   xAE,W
5774:  ADDWF  x69,W
5776:  MOVWF  FE9
5778:  MOVF   x6A,W
577A:  ADDWFC 03,W
577C:  MOVWF  FEA
577E:  MOVLW  2F
5780:  MOVWF  FEF
....................  
....................    // write the file's name 
....................    if(set_file_name(stream.Start_Addr, &i, dirname) == EOF) 
5782:  MOVFF  5CB,5F1
5786:  MOVFF  5CA,5F0
578A:  MOVFF  5C9,5EF
578E:  MOVFF  5C8,5EE
5792:  MOVLW  05
5794:  MOVWF  xF3
5796:  MOVLW  B0
5798:  MOVWF  xF2
579A:  MOVLW  05
579C:  MOVWF  xF5
579E:  MOVLW  6B
57A0:  MOVWF  xF4
57A2:  MOVLB  0
57A4:  CALL   46DC
57A8:  MOVF   01,W
57AA:  SUBLW  FF
57AC:  BNZ   57B4
....................       return EOF; 
57AE:  MOVLW  FF
57B0:  MOVWF  01
57B2:  BRA    5A82
....................  
....................    // find and allocate an open cluster 
....................    if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
57B4:  MOVLW  02
57B6:  MOVLB  6
57B8:  MOVWF  x99
57BA:  MOVLW  20
57BC:  MOVWF  x98
57BE:  MOVLB  0
57C0:  CALL   20B4
57C4:  MOVF   01,W
57C6:  SUBLW  FF
57C8:  BNZ   57D0
....................       return EOF; 
57CA:  MOVLW  FF
57CC:  MOVWF  01
57CE:  BRA    5A82
....................    if(clear_cluster(Next_Free_Clust) == EOF) 
57D0:  MOVFF  221,5EF
57D4:  MOVFF  220,5EE
57D8:  MOVFF  221,699
57DC:  MOVFF  220,698
57E0:  CALL   21E6
57E4:  MOVF   01,W
57E6:  SUBLW  FF
57E8:  BNZ   57F0
....................       return EOF; 
57EA:  MOVLW  FF
57EC:  MOVWF  01
57EE:  BRA    5A82
.................... #ifdef FAT32 
....................    if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
....................       return EOF; 
.................... #else // FAT16 
....................    if(write_fat(Next_Free_Clust, 0xFFFF) == EOF) 
57F0:  MOVFF  221,5EF
57F4:  MOVFF  220,5EE
57F8:  MOVFF  221,699
57FC:  MOVFF  220,698
5800:  MOVLW  FF
5802:  MOVLB  6
5804:  MOVWF  x9B
5806:  MOVWF  x9A
5808:  MOVLB  0
580A:  CALL   1F7A
580E:  MOVF   01,W
5810:  SUBLW  FF
5812:  BNZ   581A
....................       return EOF; 
5814:  MOVLW  FF
5816:  MOVWF  01
5818:  BRA    5A82
.................... #endif // #ifdef FAT32 
....................  
....................    // throw in some values in the file's first entry 
....................    for(j = 0; j < 0x20; j += 1) 
581A:  MOVLB  5
581C:  CLRF   xAF
581E:  MOVF   xAF,W
5820:  SUBLW  1F
5822:  BNC   583A
....................       entire_entry[j] = 0; 
5824:  CLRF   03
5826:  MOVF   xAF,W
5828:  ADDLW  8B
582A:  MOVWF  FE9
582C:  MOVLW  05
582E:  ADDWFC 03,W
5830:  MOVWF  FEA
5832:  CLRF   FEF
5834:  MOVLW  01
5836:  ADDWF  xAF,F
5838:  BRA    581E
....................  
....................    // this is a directory 
....................    entire_entry[0x0B] = 0x10; 
583A:  MOVLW  10
583C:  MOVWF  x96
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
583E:  MOVFF  220,5A5
5842:  MOVLB  5
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
5844:  MOVFF  221,5A6
5848:  MOVLB  5
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
584A:  MOVFF  5B3,6AD
584E:  MOVFF  5B2,6AC
5852:  MOVFF  5B1,6AB
5856:  MOVFF  5B0,6AA
585A:  MOVLB  6
585C:  CLRF   xAF
585E:  MOVLW  0B
5860:  MOVWF  xAE
5862:  MOVLW  05
5864:  MOVWF  xB1
5866:  MOVLW  8B
5868:  MOVWF  xB0
586A:  MOVLB  0
586C:  CALL   0DD6
5870:  MOVF   01,F
5872:  BZ    587A
....................       return EOF; 
5874:  MOVLW  FF
5876:  MOVWF  01
5878:  BRA    5A82
....................  
....................    // write the file's first entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
587A:  MOVFF  5B3,6C8
587E:  MOVFF  5B2,6C7
5882:  MOVFF  5B1,6C6
5886:  MOVFF  5B0,6C5
588A:  MOVLB  6
588C:  CLRF   xCA
588E:  MOVLW  20
5890:  MOVWF  xC9
5892:  MOVLW  05
5894:  MOVWF  xCC
5896:  MOVLW  8B
5898:  MOVWF  xCB
589A:  MOVLB  0
589C:  CALL   1EE8
58A0:  MOVF   01,F
58A2:  BZ    58AA
....................       return EOF; 
58A4:  MOVLW  FF
58A6:  MOVWF  01
58A8:  BRA    5A82
....................  
....................    // make the two links that point to the directory and the directory's parent 
....................    i = cluster_to_addr(Next_Free_Clust); 
58AA:  MOVFF  221,5EF
58AE:  MOVFF  220,5EE
58B2:  MOVFF  221,6C2
58B6:  MOVFF  220,6C1
58BA:  CALL   19DA
58BE:  MOVFF  03,5B3
58C2:  MOVFF  02,5B2
58C6:  MOVFF  01,5B1
58CA:  MOVFF  00,5B0
....................  
....................    // put in the first link that points to the directory itself 
....................    for(j = 0; j < 0x20; j += 1) 
58CE:  MOVLB  5
58D0:  CLRF   xAF
58D2:  MOVF   xAF,W
58D4:  SUBLW  1F
58D6:  BNC   593A
....................    { 
....................       if(j < 0x01) 
58D8:  MOVF   xAF,F
58DA:  BNZ   58F0
....................          entire_entry[j] = '.'; 
58DC:  CLRF   03
58DE:  MOVF   xAF,W
58E0:  ADDLW  8B
58E2:  MOVWF  FE9
58E4:  MOVLW  05
58E6:  ADDWFC 03,W
58E8:  MOVWF  FEA
58EA:  MOVLW  2E
58EC:  MOVWF  FEF
....................       else if(j < 0x0B) 
58EE:  BRA    5934
58F0:  MOVF   xAF,W
58F2:  SUBLW  0A
58F4:  BNC   590A
....................          entire_entry[j] = 0x20; 
58F6:  CLRF   03
58F8:  MOVF   xAF,W
58FA:  ADDLW  8B
58FC:  MOVWF  FE9
58FE:  MOVLW  05
5900:  ADDWFC 03,W
5902:  MOVWF  FEA
5904:  MOVLW  20
5906:  MOVWF  FEF
....................       else if(j == 0x0B) 
5908:  BRA    5934
590A:  MOVF   xAF,W
590C:  SUBLW  0B
590E:  BNZ   5924
....................          entire_entry[j] = 0x10; 
5910:  CLRF   03
5912:  MOVF   xAF,W
5914:  ADDLW  8B
5916:  MOVWF  FE9
5918:  MOVLW  05
591A:  ADDWFC 03,W
591C:  MOVWF  FEA
591E:  MOVLW  10
5920:  MOVWF  FEF
....................       else 
5922:  BRA    5934
....................          entire_entry[j] = 0x00; 
5924:  CLRF   03
5926:  MOVF   xAF,W
5928:  ADDLW  8B
592A:  MOVWF  FE9
592C:  MOVLW  05
592E:  ADDWFC 03,W
5930:  MOVWF  FEA
5932:  CLRF   FEF
....................    } 
5934:  MOVLW  01
5936:  ADDWF  xAF,F
5938:  BRA    58D2
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
593A:  MOVFF  220,5A5
593E:  MOVLB  5
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
5940:  MOVFF  221,5A6
5944:  MOVLB  5
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
5946:  MOVFF  5B3,6C8
594A:  MOVFF  5B2,6C7
594E:  MOVFF  5B1,6C6
5952:  MOVFF  5B0,6C5
5956:  MOVLB  6
5958:  CLRF   xCA
595A:  MOVLW  20
595C:  MOVWF  xC9
595E:  MOVLW  05
5960:  MOVWF  xCC
5962:  MOVLW  8B
5964:  MOVWF  xCB
5966:  MOVLB  0
5968:  CALL   1EE8
596C:  MOVF   01,F
596E:  BZ    5976
....................       return EOF; 
5970:  MOVLW  FF
5972:  MOVWF  01
5974:  BRA    5A82
....................  
....................    for(j = 0; j < 0x0C; j += 1) 
5976:  MOVLB  5
5978:  CLRF   xAF
597A:  MOVF   xAF,W
597C:  SUBLW  0B
597E:  BNC   59CC
....................    { 
....................       if(j < 0x02) 
5980:  MOVF   xAF,W
5982:  SUBLW  01
5984:  BNC   599A
....................          entire_entry[j] = '.'; 
5986:  CLRF   03
5988:  MOVF   xAF,W
598A:  ADDLW  8B
598C:  MOVWF  FE9
598E:  MOVLW  05
5990:  ADDWFC 03,W
5992:  MOVWF  FEA
5994:  MOVLW  2E
5996:  MOVWF  FEF
....................       else if(j < 0x0B) 
5998:  BRA    59C6
599A:  MOVF   xAF,W
599C:  SUBLW  0A
599E:  BNC   59B4
....................          entire_entry[j] = 0x20; 
59A0:  CLRF   03
59A2:  MOVF   xAF,W
59A4:  ADDLW  8B
59A6:  MOVWF  FE9
59A8:  MOVLW  05
59AA:  ADDWFC 03,W
59AC:  MOVWF  FEA
59AE:  MOVLW  20
59B0:  MOVWF  FEF
....................       else 
59B2:  BRA    59C6
....................          entire_entry[j] = 0x10; 
59B4:  CLRF   03
59B6:  MOVF   xAF,W
59B8:  ADDLW  8B
59BA:  MOVWF  FE9
59BC:  MOVLW  05
59BE:  ADDWFC 03,W
59C0:  MOVWF  FEA
59C2:  MOVLW  10
59C4:  MOVWF  FEF
....................    } 
59C6:  MOVLW  01
59C8:  ADDWF  xAF,F
59CA:  BRA    597A
....................  
....................    if(stream.Parent_Start_Addr == Root_Dir) 
59CC:  MOVLB  2
59CE:  MOVF   x24,W
59D0:  MOVLB  5
59D2:  SUBWF  xC0,W
59D4:  BNZ   59FE
59D6:  MOVLB  2
59D8:  MOVF   x25,W
59DA:  MOVLB  5
59DC:  SUBWF  xC1,W
59DE:  BNZ   59FE
59E0:  MOVLB  2
59E2:  MOVF   x26,W
59E4:  MOVLB  5
59E6:  SUBWF  xC2,W
59E8:  BNZ   59FE
59EA:  MOVLB  2
59EC:  MOVF   x27,W
59EE:  MOVLB  5
59F0:  SUBWF  xC3,W
59F2:  BNZ   59FE
....................    { 
....................       entire_entry[0x14] = 0x00; 
59F4:  CLRF   x9F
....................       entire_entry[0x15] = 0x00; 
59F6:  CLRF   xA0
....................       entire_entry[0x1A] = 0x00; 
59F8:  CLRF   xA5
....................       entire_entry[0x1B] = 0x00; 
59FA:  CLRF   xA6
....................    } 
....................    else 
59FC:  BRA    5A36
....................    { 
....................       entire_entry[0x1A] = make8(addr_to_cluster(stream.Parent_Start_Addr), 0); 
59FE:  MOVFF  5C3,69D
5A02:  MOVFF  5C2,69C
5A06:  MOVFF  5C1,69B
5A0A:  MOVFF  5C0,69A
5A0E:  MOVLB  0
5A10:  CALL   188E
5A14:  MOVLB  5
5A16:  MOVFF  01,5A5
....................       entire_entry[0x1B] = make8(addr_to_cluster(stream.Parent_Start_Addr), 1); 
5A1A:  MOVFF  5C3,69D
5A1E:  MOVFF  5C2,69C
5A22:  MOVFF  5C1,69B
5A26:  MOVFF  5C0,69A
5A2A:  MOVLB  0
5A2C:  CALL   188E
5A30:  MOVLB  5
5A32:  MOVFF  02,5A6
.................... #ifdef FAT32 
....................       entire_entry[0x14] = make8(addr_to_cluster(stream.Parent_Start_Addr), 2); 
....................       entire_entry[0x15] = make8(addr_to_cluster(stream.Parent_Start_Addr), 3); 
.................... #endif // #ifdef FAT32 
....................    } 
....................  
....................    if(mmcsd_write_data(i + 0x20, 0x20, entire_entry) != GOODEC) 
5A36:  MOVLW  20
5A38:  ADDWF  xB0,W
5A3A:  MOVWF  xEE
5A3C:  MOVLW  00
5A3E:  ADDWFC xB1,W
5A40:  MOVWF  xEF
5A42:  MOVLW  00
5A44:  ADDWFC xB2,W
5A46:  MOVWF  xF0
5A48:  MOVLW  00
5A4A:  ADDWFC xB3,W
5A4C:  MOVWF  xF1
5A4E:  MOVFF  FE8,6C8
5A52:  MOVFF  5F0,6C7
5A56:  MOVFF  5EF,6C6
5A5A:  MOVFF  5EE,6C5
5A5E:  MOVLB  6
5A60:  CLRF   xCA
5A62:  MOVLW  20
5A64:  MOVWF  xC9
5A66:  MOVLW  05
5A68:  MOVWF  xCC
5A6A:  MOVLW  8B
5A6C:  MOVWF  xCB
5A6E:  MOVLB  0
5A70:  CALL   1EE8
5A74:  MOVF   01,F
5A76:  BZ    5A7E
....................       return EOF; 
5A78:  MOVLW  FF
5A7A:  MOVWF  01
5A7C:  BRA    5A82
....................  
....................    return GOODEC; 
5A7E:  MOVLW  00
5A80:  MOVWF  01
.................... } 
5A82:  GOTO   5B08 (RETURN)
....................  
.................... /// Functions' Utility Functions /// 
.................... /// NOTE: A library user should not need to use any of the functions in this section /// 
....................  
.................... /* 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
.................... Summary: This will set the stream to point to the specified file. 
.................... Param fname: The file name to search for. 
.................... Param attrib: The file attributes to search for. 0x10 is a directory, 0x20 is a file. 
.................... Param stream: The stream to set. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: The stream has to be pointing to the parent directory's start address when coming in to this function. 
.................... */ 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
.................... { 
*
2D8A:  MOVLB  6
2D8C:  CLRF   x58
....................    int 
....................       cur_attrib,    // the attribute of the most recently read entry 
....................       cur_state,     // the state of the most recently read entry 
....................       ec = 0;        // error checking byte 
....................  
....................    int32 i;   // pointer to memory 
.................... #ifndef FAST_FAT 
....................    char name_buffer[MAX_FILE_NAME_LENGTH];   // buffer to hold in the most recently read in name 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set the memory pointer to the parent start address 
....................    i = stream->Start_Addr; 
2D8E:  MOVLW  14
2D90:  ADDWF  x54,W
2D92:  MOVWF  FE9
2D94:  MOVLW  00
2D96:  ADDWFC x55,W
2D98:  MOVWF  FEA
2D9A:  MOVFF  FEF,00
2D9E:  MOVFF  FEC,01
2DA2:  MOVFF  FEC,02
2DA6:  MOVFF  FEC,03
2DAA:  MOVFF  03,65C
2DAE:  MOVFF  02,65B
2DB2:  MOVFF  01,65A
2DB6:  MOVFF  00,659
....................  
....................    // search for the name of our target file inside of the parent directory 
....................    do 
....................    { 
....................       // read the state and the attribute of the current entry 
....................       ec += mmcsd_read_data(i, 1, &cur_state); 
2DBA:  MOVFF  65C,6AD
2DBE:  MOVFF  65B,6AC
2DC2:  MOVFF  65A,6AB
2DC6:  MOVFF  659,6AA
2DCA:  CLRF   xAF
2DCC:  MOVLW  01
2DCE:  MOVWF  xAE
2DD0:  MOVLW  06
2DD2:  MOVWF  xB1
2DD4:  MOVLW  57
2DD6:  MOVWF  xB0
2DD8:  MOVLB  0
2DDA:  CALL   0DD6
2DDE:  MOVF   01,W
2DE0:  MOVLB  6
2DE2:  ADDWF  x58,F
....................       ec += mmcsd_read_data(i + 0x0B, 1, &cur_attrib); 
2DE4:  MOVLW  0B
2DE6:  ADDWF  x59,W
2DE8:  MOVWF  x7D
2DEA:  MOVLW  00
2DEC:  ADDWFC x5A,W
2DEE:  MOVWF  x7E
2DF0:  MOVLW  00
2DF2:  ADDWFC x5B,W
2DF4:  MOVWF  x7F
2DF6:  MOVLW  00
2DF8:  ADDWFC x5C,W
2DFA:  MOVWF  x80
2DFC:  MOVWF  xAD
2DFE:  MOVFF  67F,6AC
2E02:  MOVFF  67E,6AB
2E06:  MOVFF  67D,6AA
2E0A:  CLRF   xAF
2E0C:  MOVLW  01
2E0E:  MOVWF  xAE
2E10:  MOVLW  06
2E12:  MOVWF  xB1
2E14:  MOVLW  56
2E16:  MOVWF  xB0
2E18:  MOVLB  0
2E1A:  CALL   0DD6
2E1E:  MOVF   01,W
2E20:  MOVLB  6
2E22:  ADDWF  x58,F
....................       if(ec != GOODEC) 
2E24:  MOVF   x58,F
2E26:  BZ    2E40
....................       { 
....................          stream->Flags |= Read_Error; 
2E28:  MOVLW  19
2E2A:  ADDWF  x54,W
2E2C:  MOVWF  FE9
2E2E:  MOVLW  00
2E30:  ADDWFC x55,W
2E32:  MOVWF  FEA
2E34:  MOVF   FEF,W
2E36:  IORLW  20
2E38:  MOVWF  FEF
....................          return EOF; 
2E3A:  MOVLW  FF
2E3C:  MOVWF  01
2E3E:  BRA    3470
....................       } 
....................  
....................        // check to make sure that this entry exists and the entry is the type we're looking for 
....................       if((cur_state != 0xE5) && (cur_attrib == attrib)) 
2E40:  MOVF   x57,W
2E42:  SUBLW  E5
2E44:  BTFSC  FD8.2
2E46:  BRA    3434
2E48:  MOVF   x53,W
2E4A:  SUBWF  x56,W
2E4C:  BTFSS  FD8.2
2E4E:  BRA    3434
....................       { 
.................... #ifndef FAST_FAT 
....................          // get the long file name of the current entry 
....................          if(get_file_name(i, name_buffer) == EOF) 
2E50:  MOVFF  65C,680
2E54:  MOVFF  65B,67F
2E58:  MOVFF  65A,67E
2E5C:  MOVFF  659,67D
2E60:  MOVLW  06
2E62:  MOVWF  x82
2E64:  MOVLW  5D
2E66:  MOVWF  x81
2E68:  MOVLB  0
2E6A:  CALL   1C4A
2E6E:  MOVF   01,W
2E70:  SUBLW  FF
2E72:  BNZ   2E7C
....................             return EOF; 
2E74:  MOVLW  FF
2E76:  MOVWF  01
2E78:  MOVLB  6
2E7A:  BRA    3470
....................  
....................          // if the target entry and the long file name are equal, strcmp will return a zero 
....................          if(strcmp(fname, name_buffer) == 0) 
2E7C:  MOVFF  652,67E
2E80:  MOVFF  651,67D
2E84:  MOVLW  06
2E86:  MOVLB  6
2E88:  MOVWF  x80
2E8A:  MOVLW  5D
2E8C:  MOVWF  x7F
2E8E:  MOVLB  0
2E90:  CALL   1DC4
2E94:  MOVF   01,F
2E96:  BTFSS  FD8.2
2E98:  BRA    3436
.................... #endif // #ifndef FAST_FAT 
....................          { 
....................             // we have found our target entry, set the current entry and break out of this function 
....................             // set stream's parent address 
....................             stream->Parent_Start_Addr = stream->Start_Addr; 
2E9A:  MOVLW  0C
2E9C:  MOVLB  6
2E9E:  ADDWF  x54,W
2EA0:  MOVWF  01
2EA2:  MOVLW  00
2EA4:  ADDWFC x55,W
2EA6:  MOVWF  03
2EA8:  MOVFF  01,67D
2EAC:  MOVWF  x7E
2EAE:  MOVLW  14
2EB0:  ADDWF  x54,W
2EB2:  MOVWF  FE9
2EB4:  MOVLW  00
2EB6:  ADDWFC x55,W
2EB8:  MOVWF  FEA
2EBA:  MOVFF  FEF,00
2EBE:  MOVFF  FEC,01
2EC2:  MOVFF  FEC,02
2EC6:  MOVFF  FEC,03
2ECA:  MOVFF  67E,FEA
2ECE:  MOVFF  67D,FE9
2ED2:  MOVFF  00,FEF
2ED6:  MOVFF  01,FEC
2EDA:  MOVFF  02,FEC
2EDE:  MOVFF  03,FEC
....................  
....................             ec += mmcsd_read_data(i + 0x1C, 4, &(stream->Size)); 
2EE2:  MOVLW  1C
2EE4:  ADDWF  x59,W
2EE6:  MOVWF  x7D
2EE8:  MOVLW  00
2EEA:  ADDWFC x5A,W
2EEC:  MOVWF  x7E
2EEE:  MOVLW  00
2EF0:  ADDWFC x5B,W
2EF2:  MOVWF  x7F
2EF4:  MOVLW  00
2EF6:  ADDWFC x5C,W
2EF8:  MOVWF  x80
2EFA:  MOVLW  10
2EFC:  ADDWF  x54,W
2EFE:  MOVWF  01
2F00:  MOVLW  00
2F02:  ADDWFC x55,W
2F04:  MOVWF  03
2F06:  MOVFF  01,681
2F0A:  MOVWF  x82
2F0C:  MOVFF  680,6AD
2F10:  MOVFF  67F,6AC
2F14:  MOVFF  67E,6AB
2F18:  MOVFF  67D,6AA
2F1C:  CLRF   xAF
2F1E:  MOVLW  04
2F20:  MOVWF  xAE
2F22:  MOVFF  03,6B1
2F26:  MOVFF  01,6B0
2F2A:  MOVLB  0
2F2C:  CALL   0DD6
2F30:  MOVF   01,W
2F32:  MOVLB  6
2F34:  ADDWF  x58,F
....................  
....................             // stream->Start_Addr is going to temporarily have a cluster number 
....................             ec += mmcsd_read_data(i + 0x14, 2, (int16*)&stream->Start_Addr + 1); 
2F36:  MOVLW  14
2F38:  ADDWF  x59,W
2F3A:  MOVWF  x7D
2F3C:  MOVLW  00
2F3E:  ADDWFC x5A,W
2F40:  MOVWF  x7E
2F42:  MOVLW  00
2F44:  ADDWFC x5B,W
2F46:  MOVWF  x7F
2F48:  MOVLW  00
2F4A:  ADDWFC x5C,W
2F4C:  MOVWF  x80
2F4E:  MOVLW  14
2F50:  ADDWF  x54,W
2F52:  MOVWF  01
2F54:  MOVLW  00
2F56:  ADDWFC x55,W
2F58:  MOVWF  03
2F5A:  MOVFF  01,681
2F5E:  MOVWF  x82
2F60:  MOVLW  02
2F62:  ADDWF  x81,F
2F64:  MOVLW  00
2F66:  ADDWFC x82,F
2F68:  MOVFF  680,6AD
2F6C:  MOVFF  67F,6AC
2F70:  MOVFF  67E,6AB
2F74:  MOVFF  67D,6AA
2F78:  CLRF   xAF
2F7A:  MOVLW  02
2F7C:  MOVWF  xAE
2F7E:  MOVFF  682,6B1
2F82:  MOVFF  681,6B0
2F86:  MOVLB  0
2F88:  CALL   0DD6
2F8C:  MOVF   01,W
2F8E:  MOVLB  6
2F90:  ADDWF  x58,F
....................             ec += mmcsd_read_data(i + 0x1A, 2, &stream->Start_Addr); 
2F92:  MOVLW  1A
2F94:  ADDWF  x59,W
2F96:  MOVWF  x7D
2F98:  MOVLW  00
2F9A:  ADDWFC x5A,W
2F9C:  MOVWF  x7E
2F9E:  MOVLW  00
2FA0:  ADDWFC x5B,W
2FA2:  MOVWF  x7F
2FA4:  MOVLW  00
2FA6:  ADDWFC x5C,W
2FA8:  MOVWF  x80
2FAA:  MOVLW  14
2FAC:  ADDWF  x54,W
2FAE:  MOVWF  01
2FB0:  MOVLW  00
2FB2:  ADDWFC x55,W
2FB4:  MOVWF  03
2FB6:  MOVFF  01,681
2FBA:  MOVWF  x82
2FBC:  MOVFF  680,6AD
2FC0:  MOVFF  67F,6AC
2FC4:  MOVFF  67E,6AB
2FC8:  MOVFF  67D,6AA
2FCC:  CLRF   xAF
2FCE:  MOVLW  02
2FD0:  MOVWF  xAE
2FD2:  MOVFF  03,6B1
2FD6:  MOVFF  01,6B0
2FDA:  MOVLB  0
2FDC:  CALL   0DD6
2FE0:  MOVF   01,W
2FE2:  MOVLB  6
2FE4:  ADDWF  x58,F
....................  
....................             if(ec != GOODEC) 
2FE6:  MOVF   x58,F
2FE8:  BZ    3002
....................             { 
....................                stream->Flags |= Read_Error; 
2FEA:  MOVLW  19
2FEC:  ADDWF  x54,W
2FEE:  MOVWF  FE9
2FF0:  MOVLW  00
2FF2:  ADDWFC x55,W
2FF4:  MOVWF  FEA
2FF6:  MOVF   FEF,W
2FF8:  IORLW  20
2FFA:  MOVWF  FEF
....................                return EOF; 
2FFC:  MOVLW  FF
2FFE:  MOVWF  01
3000:  BRA    3470
....................             } 
....................  
....................             // convert stream->Start_Addr to an address 
....................             stream->Start_Addr = cluster_to_addr(stream->Start_Addr); 
3002:  MOVLW  14
3004:  ADDWF  x54,W
3006:  MOVWF  01
3008:  MOVLW  00
300A:  ADDWFC x55,W
300C:  MOVWF  03
300E:  MOVFF  01,67D
3012:  MOVWF  x7E
3014:  MOVLW  14
3016:  ADDWF  x54,W
3018:  MOVWF  FE9
301A:  MOVLW  00
301C:  ADDWFC x55,W
301E:  MOVWF  FEA
3020:  MOVFF  FEF,67F
3024:  MOVFF  FEC,680
3028:  MOVFF  680,6C2
302C:  MOVFF  67F,6C1
3030:  MOVLB  0
3032:  CALL   19DA
3036:  MOVFF  67E,FEA
303A:  MOVFF  67D,FE9
303E:  MOVFF  00,FEF
3042:  MOVFF  01,FEC
3046:  MOVFF  02,FEC
304A:  MOVFF  03,FEC
....................  
....................             stream->Entry_Addr = i; 
304E:  MOVLW  08
3050:  MOVLB  6
3052:  ADDWF  x54,W
3054:  MOVWF  FE9
3056:  MOVLW  00
3058:  ADDWFC x55,W
305A:  MOVWF  FEA
305C:  MOVFF  659,FEF
3060:  MOVFF  65A,FEC
3064:  MOVFF  65B,FEC
3068:  MOVFF  65C,FEC
....................             stream->Bytes_Until_EOF = stream->Size; 
306C:  MOVLW  10
306E:  ADDWF  x54,W
3070:  MOVWF  FE9
3072:  MOVLW  00
3074:  ADDWFC x55,W
3076:  MOVWF  FEA
3078:  MOVFF  FEF,00
307C:  MOVFF  FEC,01
3080:  MOVFF  FEC,02
3084:  MOVFF  FEC,03
3088:  MOVFF  655,FEA
308C:  MOVFF  654,FE9
3090:  MOVFF  00,FEF
3094:  MOVFF  01,FEC
3098:  MOVFF  02,FEC
309C:  MOVFF  03,FEC
....................  
....................             // set up some permission-specific parameters if we're at a file 
....................             if(attrib == 0x20) 
30A0:  MOVF   x53,W
30A2:  SUBLW  20
30A4:  BTFSS  FD8.2
30A6:  BRA    341E
....................             { 
....................                stream->File_Type = Data_File; 
30A8:  MOVLW  18
30AA:  ADDWF  x54,W
30AC:  MOVWF  FE9
30AE:  MOVLW  00
30B0:  ADDWFC x55,W
30B2:  MOVWF  FEA
30B4:  CLRF   FEF
....................                if(stream->Flags & Write) 
30B6:  MOVLW  19
30B8:  ADDWF  x54,W
30BA:  MOVWF  FE9
30BC:  MOVLW  00
30BE:  ADDWFC x55,W
30C0:  MOVWF  FEA
30C2:  BTFSS  FEF.1
30C4:  BRA    31BC
....................                { 
....................                   // delete all previous data in the file 
....................                   stream->Bytes_Until_EOF = stream->Size = 0; 
30C6:  MOVLW  10
30C8:  ADDWF  x54,W
30CA:  MOVWF  FE9
30CC:  MOVLW  00
30CE:  ADDWFC x55,W
30D0:  MOVWF  FEA
30D2:  MOVF   FEE,F
30D4:  MOVF   FEE,F
30D6:  CLRF   FEC
30D8:  MOVF   FED,F
30DA:  CLRF   FEF
30DC:  MOVF   FED,F
30DE:  CLRF   FEF
30E0:  MOVF   FED,F
30E2:  CLRF   FEF
30E4:  MOVLW  00
30E6:  MOVFF  655,FEA
30EA:  MOVFF  654,FE9
30EE:  MOVFF  00,FEF
30F2:  MOVFF  654,FEC
30F6:  MOVFF  02,FEC
30FA:  MOVFF  655,FEC
....................  
....................                   // if there is already space allocated, get rid of it 
....................                   if(stream->Start_Addr >= Data_Start) 
30FE:  MOVLW  14
3100:  ADDWF  x54,W
3102:  MOVWF  FE9
3104:  MOVLW  00
3106:  ADDWFC x55,W
3108:  MOVWF  FEA
310A:  MOVFF  FEF,67D
310E:  MOVFF  FEC,67E
3112:  MOVFF  FEC,67F
3116:  MOVFF  FEC,680
311A:  MOVLB  2
311C:  MOVF   x1B,W
311E:  MOVLB  6
3120:  SUBWF  x80,W
3122:  BNC   319C
3124:  BNZ   3148
3126:  MOVLB  2
3128:  MOVF   x1A,W
312A:  MOVLB  6
312C:  SUBWF  x7F,W
312E:  BNC   319C
3130:  BNZ   3148
3132:  MOVLB  2
3134:  MOVF   x19,W
3136:  MOVLB  6
3138:  SUBWF  x7E,W
313A:  BNC   319C
313C:  BNZ   3148
313E:  MOVLB  2
3140:  MOVF   x18,W
3142:  MOVLB  6
3144:  SUBWF  x7D,W
3146:  BNC   319C
....................                      if(dealloc_clusters(addr_to_cluster(stream->Start_Addr)) == EOF) 
3148:  MOVLW  14
314A:  ADDWF  x54,W
314C:  MOVWF  FE9
314E:  MOVLW  00
3150:  ADDWFC x55,W
3152:  MOVWF  FEA
3154:  MOVFF  FEF,67D
3158:  MOVFF  FEC,67E
315C:  MOVFF  FEC,67F
3160:  MOVFF  FEC,680
3164:  MOVFF  680,69D
3168:  MOVFF  67F,69C
316C:  MOVFF  67E,69B
3170:  MOVFF  67D,69A
3174:  MOVLB  0
3176:  CALL   188E
317A:  MOVFF  02,67E
317E:  MOVFF  01,67D
3182:  MOVFF  02,680
3186:  MOVFF  01,67F
318A:  CALL   1FC4
318E:  MOVF   01,W
3190:  SUBLW  FF
3192:  BNZ   319C
....................                         return EOF; 
3194:  MOVLW  FF
3196:  MOVWF  01
3198:  MOVLB  6
319A:  BRA    3470
....................                   stream->Cur_Char = 0; 
319C:  MOVLW  04
319E:  MOVLB  6
31A0:  ADDWF  x54,W
31A2:  MOVWF  FE9
31A4:  MOVLW  00
31A6:  ADDWFC x55,W
31A8:  MOVWF  FEA
31AA:  MOVF   FEE,F
31AC:  MOVF   FEE,F
31AE:  CLRF   FEC
31B0:  MOVF   FED,F
31B2:  CLRF   FEF
31B4:  MOVF   FED,F
31B6:  CLRF   FEF
31B8:  MOVF   FED,F
31BA:  CLRF   FEF
....................                } 
....................  
....................                if((stream->Flags & Append) && (stream->Size != 0)) 
31BC:  MOVLW  19
31BE:  ADDWF  x54,W
31C0:  MOVWF  FE9
31C2:  MOVLW  00
31C4:  ADDWFC x55,W
31C6:  MOVWF  FEA
31C8:  BTFSS  FEF.2
31CA:  BRA    3352
31CC:  MOVLW  10
31CE:  ADDWF  x54,W
31D0:  MOVWF  FE9
31D2:  MOVLW  00
31D4:  ADDWFC x55,W
31D6:  MOVWF  FEA
31D8:  MOVFF  FEF,67D
31DC:  MOVFF  FEC,67E
31E0:  MOVFF  FEC,67F
31E4:  MOVFF  FEC,680
31E8:  MOVF   x7D,F
31EA:  BNZ   31FA
31EC:  MOVF   x7E,F
31EE:  BNZ   31FA
31F0:  MOVF   x7F,F
31F2:  BNZ   31FA
31F4:  MOVF   x80,F
31F6:  BTFSC  FD8.2
31F8:  BRA    3352
....................                { 
....................                   // set the position to the end of the file and fill the buffer with the contents of the end of the file 
....................                   ec = fatsetpos(stream, &(stream->Size)); 
31FA:  MOVLW  10
31FC:  ADDWF  x54,W
31FE:  MOVWF  01
3200:  MOVLW  00
3202:  ADDWFC x55,W
3204:  MOVWF  03
3206:  MOVFF  01,67D
320A:  MOVWF  x7E
320C:  MOVFF  655,680
3210:  MOVFF  654,67F
3214:  MOVWF  x82
3216:  MOVFF  01,681
321A:  MOVLB  0
321C:  CALL   28FC
3220:  MOVFF  01,658
....................                   if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
3224:  MOVLW  04
3226:  MOVLB  6
3228:  ADDWF  x54,W
322A:  MOVWF  FE9
322C:  MOVLW  00
322E:  ADDWFC x55,W
3230:  MOVWF  FEA
3232:  MOVFF  FEF,67D
3236:  MOVFF  FEC,67E
323A:  MOVFF  FEC,67F
323E:  MOVFF  FEC,680
3242:  MOVLW  1F
3244:  ANDWF  x7D,F
3246:  CLRF   x7E
3248:  CLRF   x7F
324A:  CLRF   x80
324C:  MOVF   x7D,F
324E:  BNZ   32C2
3250:  MOVF   x7E,F
3252:  BNZ   32C2
3254:  MOVF   x7F,F
3256:  BNZ   32C2
3258:  MOVF   x80,F
325A:  BNZ   32C2
....................                      ec += mmcsd_read_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf); 
325C:  MOVLW  04
325E:  ADDWF  x54,W
3260:  MOVWF  FE9
3262:  MOVLW  00
3264:  ADDWFC x55,W
3266:  MOVWF  FEA
3268:  MOVFF  FEF,67D
326C:  MOVFF  FEC,67E
3270:  MOVFF  FEC,67F
3274:  MOVFF  FEC,680
3278:  MOVLW  20
327A:  SUBWF  x7D,F
327C:  MOVLW  00
327E:  SUBWFB x7E,F
3280:  SUBWFB x7F,F
3282:  SUBWFB x80,F
3284:  MOVLW  1A
3286:  ADDWF  x54,W
3288:  MOVWF  01
328A:  MOVLW  00
328C:  ADDWFC x55,W
328E:  MOVWF  03
3290:  MOVFF  01,681
3294:  MOVWF  x82
3296:  MOVFF  680,6AD
329A:  MOVFF  67F,6AC
329E:  MOVFF  67E,6AB
32A2:  MOVFF  67D,6AA
32A6:  CLRF   xAF
32A8:  MOVLW  20
32AA:  MOVWF  xAE
32AC:  MOVFF  03,6B1
32B0:  MOVFF  01,6B0
32B4:  MOVLB  0
32B6:  CALL   0DD6
32BA:  MOVF   01,W
32BC:  MOVLB  6
32BE:  ADDWF  x58,F
....................                   else 
32C0:  BRA    3352
....................                      ec += mmcsd_read_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf); 
32C2:  MOVLW  04
32C4:  ADDWF  x54,W
32C6:  MOVWF  FE9
32C8:  MOVLW  00
32CA:  ADDWFC x55,W
32CC:  MOVWF  FEA
32CE:  MOVFF  FEF,67D
32D2:  MOVFF  FEC,67E
32D6:  MOVFF  FEC,67F
32DA:  MOVFF  FEC,680
32DE:  MOVLW  04
32E0:  ADDWF  x54,W
32E2:  MOVWF  FE9
32E4:  MOVLW  00
32E6:  ADDWFC x55,W
32E8:  MOVWF  FEA
32EA:  MOVFF  FEF,681
32EE:  MOVFF  FEC,682
32F2:  MOVFF  FEC,683
32F6:  MOVFF  FEC,684
32FA:  MOVF   x81,W
32FC:  ANDLW  1F
32FE:  MOVWF  00
3300:  CLRF   01
3302:  CLRF   02
3304:  CLRF   03
3306:  MOVF   00,W
3308:  SUBWF  x7D,F
330A:  MOVF   01,W
330C:  SUBWFB x7E,F
330E:  MOVF   02,W
3310:  SUBWFB x7F,F
3312:  MOVF   03,W
3314:  SUBWFB x80,F
3316:  MOVLW  1A
3318:  ADDWF  x54,W
331A:  MOVWF  01
331C:  MOVLW  00
331E:  ADDWFC x55,W
3320:  MOVWF  03
3322:  MOVFF  01,681
3326:  MOVWF  x82
3328:  MOVFF  680,6AD
332C:  MOVFF  67F,6AC
3330:  MOVFF  67E,6AB
3334:  MOVFF  67D,6AA
3338:  CLRF   xAF
333A:  MOVLW  20
333C:  MOVWF  xAE
333E:  MOVFF  03,6B1
3342:  MOVFF  01,6B0
3346:  MOVLB  0
3348:  CALL   0DD6
334C:  MOVF   01,W
334E:  MOVLB  6
3350:  ADDWF  x58,F
....................                } 
.................... #ifndef FAST_FAT 
....................                if(stream->Flags & Read) 
3352:  MOVLW  19
3354:  ADDWF  x54,W
3356:  MOVWF  FE9
3358:  MOVLW  00
335A:  ADDWFC x55,W
335C:  MOVWF  FEA
335E:  BTFSS  FEF.0
3360:  BRA    3400
....................                { 
....................                   stream->Cur_Char = stream->Start_Addr; 
3362:  MOVLW  04
3364:  ADDWF  x54,W
3366:  MOVWF  01
3368:  MOVLW  00
336A:  ADDWFC x55,W
336C:  MOVWF  03
336E:  MOVFF  01,67D
3372:  MOVWF  x7E
3374:  MOVLW  14
3376:  ADDWF  x54,W
3378:  MOVWF  FE9
337A:  MOVLW  00
337C:  ADDWFC x55,W
337E:  MOVWF  FEA
3380:  MOVFF  FEF,00
3384:  MOVFF  FEC,01
3388:  MOVFF  FEC,02
338C:  MOVFF  FEC,03
3390:  MOVFF  67E,FEA
3394:  MOVFF  67D,FE9
3398:  MOVFF  00,FEF
339C:  MOVFF  01,FEC
33A0:  MOVFF  02,FEC
33A4:  MOVFF  03,FEC
....................  
....................                   // fill up the read buffer for reading 
....................                   ec = mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf); 
33A8:  MOVLW  04
33AA:  ADDWF  x54,W
33AC:  MOVWF  FE9
33AE:  MOVLW  00
33B0:  ADDWFC x55,W
33B2:  MOVWF  FEA
33B4:  MOVFF  FEF,67D
33B8:  MOVFF  FEC,67E
33BC:  MOVFF  FEC,67F
33C0:  MOVFF  FEC,680
33C4:  MOVLW  1A
33C6:  ADDWF  x54,W
33C8:  MOVWF  01
33CA:  MOVLW  00
33CC:  ADDWFC x55,W
33CE:  MOVWF  03
33D0:  MOVFF  01,681
33D4:  MOVWF  x82
33D6:  MOVFF  680,6AD
33DA:  MOVFF  67F,6AC
33DE:  MOVFF  67E,6AB
33E2:  MOVFF  67D,6AA
33E6:  CLRF   xAF
33E8:  MOVLW  20
33EA:  MOVWF  xAE
33EC:  MOVFF  03,6B1
33F0:  MOVFF  01,6B0
33F4:  MOVLB  0
33F6:  CALL   0DD6
33FA:  MOVFF  01,658
33FE:  MOVLB  6
....................                } 
.................... #endif // #ifndef FAST_FAT 
....................                if(ec != GOODEC) 
3400:  MOVF   x58,F
3402:  BZ    341C
....................                { 
....................                   stream->Flags |= Read_Error; 
3404:  MOVLW  19
3406:  ADDWF  x54,W
3408:  MOVWF  FE9
340A:  MOVLW  00
340C:  ADDWFC x55,W
340E:  MOVWF  FEA
3410:  MOVF   FEF,W
3412:  IORLW  20
3414:  MOVWF  FEF
....................                   return EOF; 
3416:  MOVLW  FF
3418:  MOVWF  01
341A:  BRA    3470
....................                }                
....................             } 
....................             else 
341C:  BRA    342E
....................                stream->File_Type = Directory; 
341E:  MOVLW  18
3420:  ADDWF  x54,W
3422:  MOVWF  FE9
3424:  MOVLW  00
3426:  ADDWFC x55,W
3428:  MOVWF  FEA
342A:  MOVLW  01
342C:  MOVWF  FEF
....................             return GOODEC; 
342E:  MOVLW  00
3430:  MOVWF  01
3432:  BRA    3470
3434:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // check to make sure that the next iteration will give us a contiguous cluster 
....................       if(get_next_entry(&i) == EOF) 
3436:  MOVLW  06
3438:  MOVLB  6
343A:  MOVWF  x7E
343C:  MOVLW  59
343E:  MOVWF  x7D
3440:  MOVLB  0
3442:  RCALL  2D18
3444:  MOVF   01,W
3446:  SUBLW  FF
3448:  BNZ   3452
....................          return EOF; 
344A:  MOVLW  FF
344C:  MOVWF  01
344E:  MOVLB  6
3450:  BRA    3470
....................  
....................    } while(cur_state != 0x00); 
3452:  MOVLB  6
3454:  MOVF   x57,F
3456:  BTFSS  FD8.2
3458:  BRA    2DBA
....................  
....................    // if we reach this point, we know that the file won't be found 
....................    stream->Flags |= File_Not_Found; 
345A:  MOVLW  19
345C:  ADDWF  x54,W
345E:  MOVWF  FE9
3460:  MOVLW  00
3462:  ADDWFC x55,W
3464:  MOVWF  FEA
3466:  MOVF   FEF,W
3468:  IORLW  80
346A:  MOVWF  FEF
....................    return EOF; 
346C:  MOVLW  FF
346E:  MOVWF  01
.................... } 
3470:  MOVLB  0
3472:  RETLW  00
....................  
.................... /* 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
.................... Summary: This will get a name of a file. 
.................... Param file_entry_addr: The position in memory that the file's entry is. 
.................... Param name[]: The place to put the name of the file into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
.................... { 
*
1C4A:  MOVLB  6
1C4C:  CLRF   x84
....................    int 
....................       j,       // counter for loops 
....................       k = 0,   // current character in array 
....................       order,   // byte to hold the current long file name order 
....................       type;    // the type of entry that was just read in 
....................  
....................    int32 i;          // pointer for memory 
....................  
....................    // the long file name isn't fragmented across clusters 
....................    i = file_entry_addr; 
1C4E:  MOVFF  680,68A
1C52:  MOVFF  67F,689
1C56:  MOVFF  67E,688
1C5A:  MOVFF  67D,687
....................  
....................    // check to make sure that this file has a long file name 
....................    if(mmcsd_read_data(i - 0x15, 1, &type) != GOODEC) 
1C5E:  MOVLW  15
1C60:  SUBWF  x87,W
1C62:  MOVWF  x8B
1C64:  MOVLW  00
1C66:  SUBWFB x88,W
1C68:  MOVWF  x8C
1C6A:  MOVLW  00
1C6C:  SUBWFB x89,W
1C6E:  MOVWF  x8D
1C70:  MOVLW  00
1C72:  SUBWFB x8A,W
1C74:  MOVWF  x8E
1C76:  MOVWF  xAD
1C78:  MOVFF  68D,6AC
1C7C:  MOVFF  68C,6AB
1C80:  MOVFF  68B,6AA
1C84:  CLRF   xAF
1C86:  MOVLW  01
1C88:  MOVWF  xAE
1C8A:  MOVLW  06
1C8C:  MOVWF  xB1
1C8E:  MOVLW  86
1C90:  MOVWF  xB0
1C92:  MOVLB  0
1C94:  CALL   0DD6
1C98:  MOVF   01,F
1C9A:  BZ    1CA2
....................       return EOF; 
1C9C:  MOVLW  FF
1C9E:  MOVWF  01
1CA0:  BRA    1DC0
....................  
....................    if(type != 0x0F) 
1CA2:  MOVLB  6
1CA4:  MOVF   x86,W
1CA6:  SUBLW  0F
1CA8:  BZ    1CDE
....................    { 
....................       // this file doesn't have a long file name 
....................       if(get_short_file_name(i, name, type) == EOF) 
1CAA:  MOVFF  68A,68E
1CAE:  MOVFF  689,68D
1CB2:  MOVFF  688,68C
1CB6:  MOVFF  687,68B
1CBA:  MOVFF  682,690
1CBE:  MOVFF  681,68F
1CC2:  MOVFF  686,691
1CC6:  MOVLB  0
1CC8:  BRA    17BA
1CCA:  MOVF   01,W
1CCC:  SUBLW  FF
1CCE:  BNZ   1CD6
....................          return EOF; 
1CD0:  MOVLW  FF
1CD2:  MOVWF  01
1CD4:  BRA    1DC0
....................       return GOODEC; 
1CD6:  MOVLW  00
1CD8:  MOVWF  01
1CDA:  BRA    1DC0
1CDC:  MOVLB  6
....................    } 
....................  
....................    do 
....................    { 
....................       // head to the previous entry 
....................       if(get_prev_entry(&i) == EOF) 
1CDE:  MOVLW  06
1CE0:  MOVWF  x8C
1CE2:  MOVLW  87
1CE4:  MOVWF  x8B
1CE6:  MOVLB  0
1CE8:  RCALL  1BDA
1CEA:  MOVF   01,W
1CEC:  SUBLW  FF
1CEE:  BNZ   1CF6
....................          return EOF; 
1CF0:  MOVLW  FF
1CF2:  MOVWF  01
1CF4:  BRA    1DC0
....................  
....................       for(j = 1; j < 0x20; j += 2, k += 1) 
1CF6:  MOVLW  01
1CF8:  MOVLB  6
1CFA:  MOVWF  x83
1CFC:  MOVF   x83,W
1CFE:  SUBLW  1F
1D00:  BNC   1D78
....................       { 
....................          if(j == 11) 
1D02:  MOVF   x83,W
1D04:  SUBLW  0B
1D06:  BNZ   1D0E
....................             j = 14; 
1D08:  MOVLW  0E
1D0A:  MOVWF  x83
....................          else if(j == 26) 
1D0C:  BRA    1D18
1D0E:  MOVF   x83,W
1D10:  SUBLW  1A
1D12:  BNZ   1D18
....................             j = 28; 
1D14:  MOVLW  1C
1D16:  MOVWF  x83
....................          if(mmcsd_read_data(j + i, 1, &(name[k])) != GOODEC) 
1D18:  MOVF   x83,W
1D1A:  ADDWF  x87,W
1D1C:  MOVWF  x8B
1D1E:  MOVLW  00
1D20:  ADDWFC x88,W
1D22:  MOVWF  x8C
1D24:  MOVLW  00
1D26:  ADDWFC x89,W
1D28:  MOVWF  x8D
1D2A:  MOVLW  00
1D2C:  ADDWFC x8A,W
1D2E:  MOVWF  x8E
1D30:  CLRF   03
1D32:  MOVF   x84,W
1D34:  ADDWF  x81,W
1D36:  MOVWF  x8F
1D38:  MOVF   x82,W
1D3A:  ADDWFC 03,W
1D3C:  MOVWF  x90
1D3E:  MOVFF  68E,6AD
1D42:  MOVFF  68D,6AC
1D46:  MOVFF  68C,6AB
1D4A:  MOVFF  68B,6AA
1D4E:  CLRF   xAF
1D50:  MOVLW  01
1D52:  MOVWF  xAE
1D54:  MOVFF  690,6B1
1D58:  MOVFF  68F,6B0
1D5C:  MOVLB  0
1D5E:  CALL   0DD6
1D62:  MOVF   01,F
1D64:  BZ    1D6C
....................             return EOF; 
1D66:  MOVLW  FF
1D68:  MOVWF  01
1D6A:  BRA    1DC0
....................       } 
1D6C:  MOVLW  02
1D6E:  MOVLB  6
1D70:  ADDWF  x83,F
1D72:  MOVLW  01
1D74:  ADDWF  x84,F
1D76:  BRA    1CFC
....................  
....................       // now that that's done with, get the entry's order 
....................       if(mmcsd_read_data(i, 1, &order) != GOODEC) 
1D78:  MOVFF  68A,6AD
1D7C:  MOVFF  689,6AC
1D80:  MOVFF  688,6AB
1D84:  MOVFF  687,6AA
1D88:  CLRF   xAF
1D8A:  MOVLW  01
1D8C:  MOVWF  xAE
1D8E:  MOVLW  06
1D90:  MOVWF  xB1
1D92:  MOVLW  85
1D94:  MOVWF  xB0
1D96:  MOVLB  0
1D98:  CALL   0DD6
1D9C:  MOVF   01,F
1D9E:  BZ    1DA6
....................          return EOF; 
1DA0:  MOVLW  FF
1DA2:  MOVWF  01
1DA4:  BRA    1DC0
....................  
....................    } while(!(order & 0x40));  // the last entry will be 0b01xxxxxx 
1DA6:  MOVLB  6
1DA8:  BTFSS  x85.6
1DAA:  BRA    1CDE
....................  
....................    // end the name[] buffer with a \0 
....................    name[k] = '\0'; 
1DAC:  CLRF   03
1DAE:  MOVF   x84,W
1DB0:  ADDWF  x81,W
1DB2:  MOVWF  FE9
1DB4:  MOVF   x82,W
1DB6:  ADDWFC 03,W
1DB8:  MOVWF  FEA
1DBA:  CLRF   FEF
....................  
....................    return GOODEC; 
1DBC:  MOVLW  00
1DBE:  MOVWF  01
1DC0:  MOVLB  0
.................... } 
1DC2:  RETLW  00
....................  
.................... /* 
.................... signed int set_file_name(int32 parent_dir_addr, int32 entry_addr, char name[]) 
.................... Summary: Creates both a short and long file name at the first free entry in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param entry_addr: The address the function put the short file name entry. 
.................... Param name: The full file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]) 
.................... { 
*
46DC:  MOVLB  6
46DE:  CLRF   x02
46E0:  MOVLW  01
46E2:  MOVWF  x25
....................    char sname[12];   // place to hold the short file name 
....................  
....................    signed int name_pos = 0;   // the current parse position of name[] 
....................  
....................    int 
....................       chksum,               // the long file name checksum 
....................       entire_entry[0x20],   // the entire entry to put write onto the media 
....................       entry_pos,            // the current position inside of entire_entry 
....................       long_entry = 1;       // the current long entry number we're on 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    // check for invalid characters 
....................    if(check_invalid_char(name) == EOF) 
46E4:  MOVFF  5F5,62B
46E8:  MOVFF  5F4,62A
46EC:  MOVLB  0
46EE:  GOTO   3EAA
46F2:  MOVF   01,W
46F4:  SUBLW  FF
46F6:  BNZ   46FE
....................       return EOF; 
46F8:  MOVLW  FF
46FA:  MOVWF  01
46FC:  BRA    49B8
....................  
....................    // make a short file name of this 
....................    if(make_short_file_name(parent_dir_addr, name, sname) == EOF) 
46FE:  MOVFF  5F1,62D
4702:  MOVFF  5F0,62C
4706:  MOVFF  5EF,62B
470A:  MOVFF  5EE,62A
470E:  MOVFF  5F5,62F
4712:  MOVFF  5F4,62E
4716:  MOVLW  05
4718:  MOVLB  6
471A:  MOVWF  x31
471C:  MOVLW  F6
471E:  MOVWF  x30
4720:  MOVLB  0
4722:  BRA    4034
4724:  MOVF   01,W
4726:  SUBLW  FF
4728:  BNZ   4730
....................       return EOF; 
472A:  MOVLW  FF
472C:  MOVWF  01
472E:  BRA    49B8
....................  
....................    // get a checksum for the long file name entries 
....................    chksum = long_name_chksum(sname); 
4730:  MOVLW  05
4732:  MOVLB  6
4734:  MOVWF  x2B
4736:  MOVLW  F6
4738:  MOVWF  x2A
473A:  MOVLB  0
473C:  BRA    448E
473E:  MOVFF  01,603
....................  
....................    // start writing the long file name 
....................    // zero out entry[] 
....................    for(entry_pos = 0; entry_pos < 0x20; entry_pos += 1) 
4742:  MOVLB  6
4744:  CLRF   x24
4746:  MOVF   x24,W
4748:  SUBLW  1F
474A:  BNC   4762
....................       entire_entry[entry_pos] = 0;    
474C:  CLRF   03
474E:  MOVF   x24,W
4750:  ADDLW  04
4752:  MOVWF  FE9
4754:  MOVLW  06
4756:  ADDWFC 03,W
4758:  MOVWF  FEA
475A:  CLRF   FEF
475C:  MOVLW  01
475E:  ADDWF  x24,F
4760:  BRA    4746
....................  
....................    i = parent_dir_addr; 
4762:  MOVFF  5F1,629
4766:  MOVFF  5F0,628
476A:  MOVFF  5EF,627
476E:  MOVFF  5EE,626
....................    if(get_next_free_entry(&i) == EOF) 
4772:  MOVLW  06
4774:  MOVWF  x2B
4776:  MOVLW  26
4778:  MOVWF  x2A
477A:  MOVLB  0
477C:  RCALL  44D4
477E:  MOVF   01,W
4780:  SUBLW  FF
4782:  BNZ   478A
....................       return EOF; 
4784:  MOVLW  FF
4786:  MOVWF  01
4788:  BRA    49B8
....................  
....................    // 0x0F signifies an file entry 
....................    entire_entry[11] = 0x0F; 
478A:  MOVLW  0F
478C:  MOVLB  6
478E:  MOVWF  x0F
....................  
....................    // since we're working in reverse, write the final long name entry 
....................    name_pos = strlen(name); 
4790:  MOVFF  5F5,65E
4794:  MOVFF  5F4,65D
4798:  MOVLB  0
479A:  CALL   14F4
479E:  MOVFF  01,602
....................    name_pos %= 13; 
47A2:  MOVFF  602,62A
47A6:  MOVLW  0D
47A8:  MOVLB  6
47AA:  MOVWF  x2B
47AC:  MOVLB  0
47AE:  RCALL  45E6
47B0:  MOVFF  00,602
....................  
....................    if(name_pos != 0) 
47B4:  MOVLB  6
47B6:  MOVF   x02,F
47B8:  BZ    47D2
....................    { 
....................       // add 1 to account for the \0 terminator 
....................       name_pos += 1; 
47BA:  MOVLW  01
47BC:  ADDWF  x02,F
....................  
....................       fill_entry(entire_entry, 0xFF, name_pos); 
47BE:  MOVLW  06
47C0:  MOVWF  x2B
47C2:  MOVLW  04
47C4:  MOVWF  x2A
47C6:  MOVLW  FF
47C8:  MOVWF  x2C
47CA:  MOVFF  602,62D
47CE:  MOVLB  0
47D0:  RCALL  4632
....................    } 
....................  
....................    // start writing the long file name entries 
....................    name_pos = strlen(name); 
47D2:  MOVFF  5F5,65E
47D6:  MOVFF  5F4,65D
47DA:  MOVLB  0
47DC:  CALL   14F4
47E0:  MOVFF  01,602
....................  
....................    // figure out how many entries this name will take up 
....................    long_entry = (name_pos / 13) + 1; 
47E4:  MOVFF  602,62A
47E8:  MOVLW  0D
47EA:  MOVLB  6
47EC:  MOVWF  x2B
47EE:  MOVLB  0
47F0:  RCALL  45E6
47F2:  MOVLW  01
47F4:  ADDWF  01,W
47F6:  MOVLB  6
47F8:  MOVWF  x25
....................  
....................    if(name_pos % 13 == 0) 
47FA:  MOVFF  602,62A
47FE:  MOVLW  0D
4800:  MOVWF  x2B
4802:  MOVLB  0
4804:  RCALL  45E6
4806:  MOVF   00,F
4808:  BNZ   4810
....................       long_entry -= 1; 
480A:  MOVLW  01
480C:  MOVLB  6
480E:  SUBWF  x25,F
....................  
....................    // set the bit to signify this is the final entry 
....................    long_entry |= 0x40; 
4810:  MOVLB  6
4812:  BSF    x25.6
....................  
....................    while(name_pos >= 0) 
....................    { 
4814:  BTFSC  x02.7
4816:  BRA    496C
....................       entry_pos = name_pos % 13; 
4818:  MOVFF  602,62A
481C:  MOVLW  0D
481E:  MOVWF  x2B
4820:  MOVLB  0
4822:  RCALL  45E6
4824:  MOVFF  00,624
4828:  MOVLB  6
....................  
....................       if(entry_pos < 5) 
482A:  MOVF   x24,W
482C:  SUBLW  04
482E:  BNC   4868
....................          entire_entry[(entry_pos << 1) + 1] = name[name_pos]; 
4830:  BCF    FD8.0
4832:  RLCF   x24,W
4834:  ADDLW  01
4836:  CLRF   03
4838:  ADDLW  04
483A:  MOVWF  01
483C:  MOVLW  06
483E:  ADDWFC 03,F
4840:  MOVFF  03,62B
4844:  CLRF   03
4846:  MOVF   x02,W
4848:  MOVLB  5
484A:  ADDWF  xF4,W
484C:  MOVWF  FE9
484E:  MOVF   xF5,W
4850:  ADDWFC 03,W
4852:  MOVWF  FEA
4854:  MOVFF  FEF,62C
4858:  MOVLB  6
485A:  MOVFF  62B,FEA
485E:  MOVFF  01,FE9
4862:  MOVFF  62C,FEF
....................  
....................       else if(entry_pos < 11) 
4866:  BRA    48DC
4868:  MOVF   x24,W
486A:  SUBLW  0A
486C:  BNC   48A6
....................          entire_entry[(entry_pos << 1) + 4] = name[name_pos]; 
486E:  BCF    FD8.0
4870:  RLCF   x24,W
4872:  ADDLW  04
4874:  CLRF   03
4876:  ADDLW  04
4878:  MOVWF  01
487A:  MOVLW  06
487C:  ADDWFC 03,F
487E:  MOVFF  03,62B
4882:  CLRF   03
4884:  MOVF   x02,W
4886:  MOVLB  5
4888:  ADDWF  xF4,W
488A:  MOVWF  FE9
488C:  MOVF   xF5,W
488E:  ADDWFC 03,W
4890:  MOVWF  FEA
4892:  MOVFF  FEF,62C
4896:  MOVLB  6
4898:  MOVFF  62B,FEA
489C:  MOVFF  01,FE9
48A0:  MOVFF  62C,FEF
....................  
....................       else 
48A4:  BRA    48DC
....................          entire_entry[(entry_pos << 1) + 6] = name[name_pos]; 
48A6:  BCF    FD8.0
48A8:  RLCF   x24,W
48AA:  ADDLW  06
48AC:  CLRF   03
48AE:  ADDLW  04
48B0:  MOVWF  01
48B2:  MOVLW  06
48B4:  ADDWFC 03,F
48B6:  MOVFF  03,62B
48BA:  CLRF   03
48BC:  MOVF   x02,W
48BE:  MOVLB  5
48C0:  ADDWF  xF4,W
48C2:  MOVWF  FE9
48C4:  MOVF   xF5,W
48C6:  ADDWFC 03,W
48C8:  MOVWF  FEA
48CA:  MOVFF  FEF,62C
48CE:  MOVLB  6
48D0:  MOVFF  62B,FEA
48D4:  MOVFF  01,FE9
48D8:  MOVFF  62C,FEF
....................  
....................       if((entry_pos == 0) 
....................          && (name_pos != strlen (name))) 
48DC:  MOVF   x24,F
48DE:  BNZ   4966
48E0:  MOVFF  5F5,65E
48E4:  MOVFF  5F4,65D
48E8:  MOVLB  0
48EA:  CALL   14F4
48EE:  MOVF   01,W
48F0:  MOVLB  6
48F2:  SUBWF  x02,W
48F4:  BZ    4966
....................       { 
....................          entire_entry[0] = long_entry; 
48F6:  MOVFF  625,604
....................  
....................          // clear off the bits at positions 6 and 7 if the most recent entry was the final one. 
....................          if(name_pos != 0) 
48FA:  MOVF   x02,F
48FC:  BZ    4902
....................             long_entry &= 0x3F; 
48FE:  MOVLW  3F
4900:  ANDWF  x25,F
....................  
....................          long_entry -= 1; 
4902:  MOVLW  01
4904:  SUBWF  x25,F
....................  
....................          entire_entry[13] = chksum; 
4906:  MOVFF  603,611
....................          if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
490A:  MOVFF  629,6C8
490E:  MOVFF  628,6C7
4912:  MOVFF  627,6C6
4916:  MOVFF  626,6C5
491A:  CLRF   xCA
491C:  MOVLW  20
491E:  MOVWF  xC9
4920:  MOVLW  06
4922:  MOVWF  xCC
4924:  MOVLW  04
4926:  MOVWF  xCB
4928:  MOVLB  0
492A:  CALL   1EE8
492E:  MOVF   01,F
4930:  BZ    4938
....................             return EOF; 
4932:  MOVLW  FF
4934:  MOVWF  01
4936:  BRA    49B8
....................          if(get_next_free_entry(&i) == EOF) 
4938:  MOVLW  06
493A:  MOVLB  6
493C:  MOVWF  x2B
493E:  MOVLW  26
4940:  MOVWF  x2A
4942:  MOVLB  0
4944:  RCALL  44D4
4946:  MOVF   01,W
4948:  SUBLW  FF
494A:  BNZ   4952
....................             return EOF; 
494C:  MOVLW  FF
494E:  MOVWF  01
4950:  BRA    49B8
....................          fill_entry(entire_entry, 0x00, 0); 
4952:  MOVLW  06
4954:  MOVLB  6
4956:  MOVWF  x2B
4958:  MOVLW  04
495A:  MOVWF  x2A
495C:  CLRF   x2C
495E:  CLRF   x2D
4960:  MOVLB  0
4962:  RCALL  4632
4964:  MOVLB  6
....................       } 
....................       name_pos -= 1; 
4966:  MOVLW  01
4968:  SUBWF  x02,F
....................    } 
496A:  BRA    4814
....................  
....................    // write the short file name to the entry 
....................    if(mmcsd_write_data(i, 11, sname) != GOODEC) 
496C:  MOVFF  629,6C8
4970:  MOVFF  628,6C7
4974:  MOVFF  627,6C6
4978:  MOVFF  626,6C5
497C:  CLRF   xCA
497E:  MOVLW  0B
4980:  MOVWF  xC9
4982:  MOVLW  05
4984:  MOVWF  xCC
4986:  MOVLW  F6
4988:  MOVWF  xCB
498A:  MOVLB  0
498C:  CALL   1EE8
4990:  MOVF   01,F
4992:  BZ    499A
....................       return EOF; 
4994:  MOVLW  FF
4996:  MOVWF  01
4998:  BRA    49B8
....................  
....................    // set the new entry addr 
....................    *entry_addr = i; 
499A:  MOVLB  5
499C:  MOVFF  5F2,FE9
49A0:  MOVFF  5F3,FEA
49A4:  MOVFF  626,FEF
49A8:  MOVFF  627,FEC
49AC:  MOVFF  628,FEC
49B0:  MOVFF  629,FEC
....................  
....................    return GOODEC; 
49B4:  MOVLW  00
49B6:  MOVWF  01
49B8:  MOVLB  0
.................... } 
49BA:  RETLW  00
....................  
.................... /* 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
.................... Summary: Reads a file's short file name, puts all the characters into lower case, and puts it into a buffer. 
.................... Param file_entry_addr: Where the file's entry address is located. 
.................... Param sname: The buffer to put the short file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
.................... { 
*
17BA:  MOVLB  6
17BC:  CLRF   x94
.................... 	int 
.................... 		buf, 
.................... 		i, 
.................... 		j = 0; 
.................... 	// one short file name has, at the most, 11 characters  
.................... 	for(i = 0; i < 11; ++i) 
17BE:  CLRF   x93
17C0:  MOVF   x93,W
17C2:  SUBLW  0A
17C4:  BNC   185C
.................... 	{ 
.................... 		// read in a character  
.................... 		if(mmcsd_read_data(i + file_entry_addr, 1, &buf) != GOODEC) 
17C6:  MOVF   x93,W
17C8:  ADDWF  x8B,W
17CA:  MOVWF  x95
17CC:  MOVLW  00
17CE:  ADDWFC x8C,W
17D0:  MOVWF  x96
17D2:  MOVLW  00
17D4:  ADDWFC x8D,W
17D6:  MOVWF  x97
17D8:  MOVLW  00
17DA:  ADDWFC x8E,W
17DC:  MOVWF  x98
17DE:  MOVWF  xAD
17E0:  MOVFF  697,6AC
17E4:  MOVFF  696,6AB
17E8:  MOVFF  695,6AA
17EC:  CLRF   xAF
17EE:  MOVLW  01
17F0:  MOVWF  xAE
17F2:  MOVLW  06
17F4:  MOVWF  xB1
17F6:  MOVLW  92
17F8:  MOVWF  xB0
17FA:  MOVLB  0
17FC:  CALL   0DD6
1800:  MOVF   01,F
1802:  BZ    180A
.................... 			return EOF; 
1804:  MOVLW  FF
1806:  MOVWF  01
1808:  BRA    1888
.................... 		// convert the character  
.................... 		if(buf != ' ') 
180A:  MOVLB  6
180C:  MOVF   x92,W
180E:  SUBLW  20
1810:  BZ    1858
.................... 		{ 
.................... 			if (i == 8 && type != 0x10) sname[j++] = '.'; 
1812:  MOVF   x93,W
1814:  SUBLW  08
1816:  BNZ   1832
1818:  MOVF   x91,W
181A:  SUBLW  10
181C:  BZ    1832
181E:  MOVF   x94,W
1820:  INCF   x94,F
1822:  CLRF   03
1824:  ADDWF  x8F,W
1826:  MOVWF  FE9
1828:  MOVF   x90,W
182A:  ADDWFC 03,W
182C:  MOVWF  FEA
182E:  MOVLW  2E
1830:  MOVWF  FEF
.................... 			sname[j++] = tolower(buf); 
1832:  MOVF   x94,W
1834:  INCF   x94,F
1836:  CLRF   03
1838:  ADDWF  x8F,W
183A:  MOVWF  FE9
183C:  MOVF   x90,W
183E:  ADDWFC 03,W
1840:  MOVWF  FEA
1842:  MOVF   x92,W
1844:  SUBLW  40
1846:  BC    1854
1848:  MOVF   x92,W
184A:  SUBLW  5A
184C:  BNC   1854
184E:  MOVF   x92,W
1850:  IORLW  20
1852:  BRA    1856
1854:  MOVF   x92,W
1856:  MOVWF  FEF
.................... 		} 
.................... 	} 
1858:  INCF   x93,F
185A:  BRA    17C0
.................... 	if (sname[j - 1] == '.') --j; 
185C:  MOVLW  01
185E:  SUBWF  x94,W
1860:  CLRF   03
1862:  ADDWF  x8F,W
1864:  MOVWF  FE9
1866:  MOVF   x90,W
1868:  ADDWFC 03,W
186A:  MOVWF  FEA
186C:  MOVF   FEF,W
186E:  SUBLW  2E
1870:  BTFSC  FD8.2
1872:  DECF   x94,F
.................... 	sname[j] = '\0'; 
1874:  CLRF   03
1876:  MOVF   x94,W
1878:  ADDWF  x8F,W
187A:  MOVWF  FE9
187C:  MOVF   x90,W
187E:  ADDWFC 03,W
1880:  MOVWF  FEA
1882:  CLRF   FEF
.................... 	return GOODEC; 
1884:  MOVLW  00
1886:  MOVWF  01
1888:  MOVLB  0
.................... } 
188A:  GOTO   1CCA (RETURN)
....................  
.................... /* 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
.................... Summary: Creates a unique short file name in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param fname: The full file name. 
.................... Param sname: Character array that will hold the short file name upon function completion. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
.................... { 
*
4076:  CLRF   x53
4078:  CLRF   x54
407A:  CLRF   x58
407C:  CLRF   x57
407E:  CLRF   x56
4080:  CLRF   x55
....................    char 
....................       val[12] = "           ", 
*
4034:  MOVLW  20
4036:  MOVLB  6
4038:  MOVWF  x32
403A:  MOVWF  x33
403C:  MOVWF  x34
403E:  MOVWF  x35
4040:  MOVWF  x36
4042:  MOVWF  x37
4044:  MOVWF  x38
4046:  MOVWF  x39
4048:  MOVWF  x3A
404A:  MOVWF  x3B
404C:  MOVWF  x3C
404E:  CLRF   x3D
....................       cur_fname[12] = "           ", 
4050:  MOVWF  x3E
4052:  MOVWF  x3F
4054:  MOVWF  x40
4056:  MOVWF  x41
4058:  MOVWF  x42
405A:  MOVWF  x43
405C:  MOVWF  x44
405E:  MOVWF  x45
4060:  MOVWF  x46
4062:  MOVWF  x47
4064:  MOVWF  x48
4066:  CLRF   x49
....................       cur_fnum[7] = "      "; 
4068:  MOVWF  x4A
406A:  MOVWF  x4B
406C:  MOVWF  x4C
406E:  MOVWF  x4D
4070:  MOVWF  x4E
4072:  MOVWF  x4F
4074:  CLRF   x50
....................  
....................    int 
....................       buf, 
....................       ext_pos, 
....................       fname_parse_pos = 0, 
....................       val_parse_pos = 0; 
....................  
....................    int32 
....................       fnum = 0, 
....................       i; 
....................  
....................    // figure out where the extension position is 
....................    ext_pos = strchr(fname, '.'); 
*
4082:  MOVFF  62F,65E
4086:  MOVFF  62E,65D
408A:  MOVLW  2E
408C:  MOVWF  x5F
408E:  MOVLB  0
4090:  RCALL  3F24
4092:  MOVFF  01,652
....................  
....................    // check to see if this file has an extension 
....................    if(ext_pos == 0) 
4096:  MOVLB  6
4098:  MOVF   x52,F
409A:  BNZ   4130
....................    { 
....................       while((val_parse_pos < 8) && (fname[fname_parse_pos] != '\0')) 
....................       { 
409C:  MOVF   x54,W
409E:  SUBLW  07
40A0:  BNC   412E
40A2:  CLRF   03
40A4:  MOVF   x53,W
40A6:  ADDWF  x2E,W
40A8:  MOVWF  FE9
40AA:  MOVF   x2F,W
40AC:  ADDWFC 03,W
40AE:  MOVWF  FEA
40B0:  MOVF   FEF,F
40B2:  BZ    412E
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
40B4:  CLRF   03
40B6:  MOVF   x54,W
40B8:  ADDLW  32
40BA:  MOVWF  01
40BC:  MOVLW  06
40BE:  ADDWFC 03,F
40C0:  MOVFF  01,65D
40C4:  MOVFF  03,65E
40C8:  CLRF   03
40CA:  MOVF   x53,W
40CC:  ADDWF  x2E,W
40CE:  MOVWF  FE9
40D0:  MOVF   x2F,W
40D2:  ADDWFC 03,W
40D4:  MOVWF  FEA
40D6:  MOVFF  FEF,65F
40DA:  MOVF   x5F,W
40DC:  SUBLW  60
40DE:  BC    40EC
40E0:  MOVF   x5F,W
40E2:  SUBLW  7A
40E4:  BNC   40EC
40E6:  MOVF   x5F,W
40E8:  ANDLW  DF
40EA:  BRA    40EE
40EC:  MOVF   x5F,W
40EE:  MOVFF  65E,FEA
40F2:  MOVFF  65D,FE9
40F6:  MOVWF  FEF
....................          val_parse_pos += 1; 
40F8:  MOVLW  01
40FA:  ADDWF  x54,F
....................          fname_parse_pos += 1; 
40FC:  ADDWF  x53,F
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
....................             fname_parse_pos += 1; 
40FE:  CLRF   03
4100:  MOVF   x53,W
4102:  ADDWF  x2E,W
4104:  MOVWF  FE9
4106:  MOVF   x2F,W
4108:  ADDWFC 03,W
410A:  MOVWF  FEA
410C:  MOVF   FEF,W
410E:  SUBLW  2E
4110:  BZ    4126
4112:  CLRF   03
4114:  MOVF   x53,W
4116:  ADDWF  x2E,W
4118:  MOVWF  FE9
411A:  MOVF   x2F,W
411C:  ADDWFC 03,W
411E:  MOVWF  FEA
4120:  MOVF   FEF,W
4122:  SUBLW  20
4124:  BNZ   412C
4126:  MOVLW  01
4128:  ADDWF  x53,F
412A:  BRA    40FE
....................       } 
412C:  BRA    409C
....................    } 
....................    else 
412E:  BRA    41E6
....................    { 
....................       ext_pos -= fname - 1; 
4130:  MOVLW  01
4132:  SUBWF  x2E,W
4134:  MOVWF  00
4136:  MOVLW  00
4138:  SUBWFB x2F,W
413A:  MOVF   00,W
413C:  SUBWF  x52,F
....................       while((val_parse_pos < 11) && (fname[fname_parse_pos] != '\0')) 
....................       { 
413E:  MOVF   x54,W
4140:  SUBLW  0A
4142:  BNC   41E6
4144:  CLRF   03
4146:  MOVF   x53,W
4148:  ADDWF  x2E,W
414A:  MOVWF  FE9
414C:  MOVF   x2F,W
414E:  ADDWFC 03,W
4150:  MOVWF  FEA
4152:  MOVF   FEF,F
4154:  BZ    41E6
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
4156:  CLRF   03
4158:  MOVF   x54,W
415A:  ADDLW  32
415C:  MOVWF  01
415E:  MOVLW  06
4160:  ADDWFC 03,F
4162:  MOVFF  01,65D
4166:  MOVFF  03,65E
416A:  CLRF   03
416C:  MOVF   x53,W
416E:  ADDWF  x2E,W
4170:  MOVWF  FE9
4172:  MOVF   x2F,W
4174:  ADDWFC 03,W
4176:  MOVWF  FEA
4178:  MOVFF  FEF,65F
417C:  MOVF   x5F,W
417E:  SUBLW  60
4180:  BC    418E
4182:  MOVF   x5F,W
4184:  SUBLW  7A
4186:  BNC   418E
4188:  MOVF   x5F,W
418A:  ANDLW  DF
418C:  BRA    4190
418E:  MOVF   x5F,W
4190:  MOVFF  65E,FEA
4194:  MOVFF  65D,FE9
4198:  MOVWF  FEF
....................          val_parse_pos += 1; 
419A:  MOVLW  01
419C:  ADDWF  x54,F
....................          fname_parse_pos += 1; 
419E:  ADDWF  x53,F
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
....................             fname_parse_pos += 1; 
41A0:  CLRF   03
41A2:  MOVF   x53,W
41A4:  ADDWF  x2E,W
41A6:  MOVWF  FE9
41A8:  MOVF   x2F,W
41AA:  ADDWFC 03,W
41AC:  MOVWF  FEA
41AE:  MOVF   FEF,W
41B0:  SUBLW  2E
41B2:  BZ    41C8
41B4:  CLRF   03
41B6:  MOVF   x53,W
41B8:  ADDWF  x2E,W
41BA:  MOVWF  FE9
41BC:  MOVF   x2F,W
41BE:  ADDWFC 03,W
41C0:  MOVWF  FEA
41C2:  MOVF   FEF,W
41C4:  SUBLW  20
41C6:  BNZ   41CE
41C8:  MOVLW  01
41CA:  ADDWF  x53,F
41CC:  BRA    41A0
....................  
....................          // check to see if it's time to skip val_parse_pos ahead to the file extension 
....................          if(fname_parse_pos == ext_pos) 
41CE:  MOVF   x52,W
41D0:  SUBWF  x53,W
41D2:  BNZ   41DA
....................             val_parse_pos = 8; 
41D4:  MOVLW  08
41D6:  MOVWF  x54
....................  
....................          // check to see if it's time to skip name_parse_pos ahead to the file extension 
....................          else if(val_parse_pos == 8) 
41D8:  BRA    41E4
41DA:  MOVF   x54,W
41DC:  SUBLW  08
41DE:  BNZ   41E4
....................             fname_parse_pos = ext_pos; 
41E0:  MOVFF  652,653
....................       } 
41E4:  BRA    413E
....................    } 
....................  
....................    // now that we've got the short file name, we need to make it unique 
....................    i = parent_dir_addr; 
41E6:  MOVFF  62D,65C
41EA:  MOVFF  62C,65B
41EE:  MOVFF  62B,65A
41F2:  MOVFF  62A,659
....................    if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
41F6:  MOVLW  0B
41F8:  ADDWF  x59,W
41FA:  MOVWF  x5D
41FC:  MOVLW  00
41FE:  ADDWFC x5A,W
4200:  MOVWF  x5E
4202:  MOVLW  00
4204:  ADDWFC x5B,W
4206:  MOVWF  x5F
4208:  MOVLW  00
420A:  ADDWFC x5C,W
420C:  MOVWF  x60
420E:  MOVWF  xAD
4210:  MOVFF  65F,6AC
4214:  MOVFF  65E,6AB
4218:  MOVFF  65D,6AA
421C:  CLRF   xAF
421E:  MOVLW  01
4220:  MOVWF  xAE
4222:  MOVLW  06
4224:  MOVWF  xB1
4226:  MOVLW  51
4228:  MOVWF  xB0
422A:  MOVLB  0
422C:  CALL   0DD6
4230:  MOVF   01,F
4232:  BZ    423A
....................       return EOF; 
4234:  MOVLW  FF
4236:  MOVWF  01
4238:  BRA    4488
....................  
....................    // keep reading until we hit empty space 
....................    while(buf != 0x00) 
....................    { 
423A:  MOVLB  6
423C:  MOVF   x51,F
423E:  BTFSC  FD8.2
4240:  BRA    4434
....................       // check to see if this is a short file name entry 
....................       if((buf == 0x20) || (buf == 0x10)) 
4242:  MOVF   x51,W
4244:  SUBLW  20
4246:  BZ    4250
4248:  MOVF   x51,W
424A:  SUBLW  10
424C:  BTFSS  FD8.2
424E:  BRA    4392
....................       { 
....................          // read in the short file name that we're currently pointing at 
....................          if(mmcsd_read_data(i, 11, cur_fname) != GOODEC) 
4250:  MOVFF  65C,6AD
4254:  MOVFF  65B,6AC
4258:  MOVFF  65A,6AB
425C:  MOVFF  659,6AA
4260:  CLRF   xAF
4262:  MOVLW  0B
4264:  MOVWF  xAE
4266:  MOVLW  06
4268:  MOVWF  xB1
426A:  MOVLW  3E
426C:  MOVWF  xB0
426E:  MOVLB  0
4270:  CALL   0DD6
4274:  MOVF   01,F
4276:  BZ    427E
....................             return EOF; 
4278:  MOVLW  FF
427A:  MOVWF  01
427C:  BRA    4488
....................  
....................          cur_fname[11] = '\0'; 
427E:  MOVLB  6
4280:  CLRF   x49
....................  
....................          // strcmp will return a 0 if the file name we're currently pointing at and the file name that we created above are the same 
....................          if(strcmp(cur_fname, val) == 0) 
4282:  MOVLW  06
4284:  MOVWF  x7E
4286:  MOVLW  3E
4288:  MOVWF  x7D
428A:  MOVLW  06
428C:  MOVWF  x80
428E:  MOVLW  32
4290:  MOVWF  x7F
4292:  MOVLB  0
4294:  CALL   1DC4
4298:  MOVF   01,F
429A:  BTFSS  FD8.2
429C:  BRA    4394
....................          { 
....................             // we now need to create a unique file name 
....................             //  increment the unique file number by one 
....................             fnum += 1; 
429E:  MOVLW  01
42A0:  MOVLB  6
42A2:  ADDWF  x55,F
42A4:  MOVLW  00
42A6:  ADDWFC x56,F
42A8:  ADDWFC x57,F
42AA:  ADDWFC x58,F
....................  
....................             // convert the unique file number to a string 
....................             sprintf(cur_fnum, "%u", fnum); 
42AC:  MOVLW  06
42AE:  MOVLB  2
42B0:  MOVWF  x29
42B2:  MOVLW  4A
42B4:  MOVWF  x28
42B6:  MOVFF  655,65D
42BA:  MOVLW  1B
42BC:  MOVLB  6
42BE:  MOVWF  x5E
42C0:  MOVLB  0
42C2:  BRA    3FB6
....................  
....................             // put the unique file number, along with a '~' into our short file name 
....................             fname_parse_pos = 0; 
42C4:  MOVLB  6
42C6:  CLRF   x53
....................  
....................             // find out the last posiiton of a space 
....................             val_parse_pos = strchr(val, ' '); 
42C8:  MOVLW  06
42CA:  MOVWF  x5E
42CC:  MOVLW  32
42CE:  MOVWF  x5D
42D0:  MOVLW  20
42D2:  MOVWF  x5F
42D4:  MOVLB  0
42D6:  RCALL  3F24
42D8:  MOVFF  01,654
....................             if(val_parse_pos == 0) 
42DC:  MOVLB  6
42DE:  MOVF   x54,F
42E0:  BNZ   42FC
....................                // if there isn't a space, then we're going to have to put the ~x at the end of the short name 
....................                val_parse_pos = 7 - strlen(cur_fnum); 
42E2:  MOVLW  06
42E4:  MOVWF  x5E
42E6:  MOVLW  4A
42E8:  MOVWF  x5D
42EA:  MOVLB  0
42EC:  CALL   14F4
42F0:  MOVLW  07
42F2:  BSF    FD8.0
42F4:  SUBFWB 01,W
42F6:  MOVLB  6
42F8:  MOVWF  x54
....................             else 
42FA:  BRA    4300
....................                // if there is a space, then put the ~x there 
....................                val_parse_pos -= val + 2; 
42FC:  MOVLW  34
42FE:  SUBWF  x54,F
....................  
....................             // make some room for extra digits 
....................             buf = 10; 
4300:  MOVLW  0A
4302:  MOVWF  x51
....................             while(fnum >= buf) 
....................             { 
4304:  MOVF   x58,F
4306:  BNZ   4316
4308:  MOVF   x57,F
430A:  BNZ   4316
430C:  MOVF   x56,F
430E:  BNZ   4316
4310:  MOVF   x51,W
4312:  SUBWF  x55,W
4314:  BNC   4324
....................                val_parse_pos -= 1; 
4316:  MOVLW  01
4318:  SUBWF  x54,F
....................                buf *= 10; 
431A:  MOVF   x51,W
431C:  MULLW  0A
431E:  MOVFF  FF3,651
....................             } 
4322:  BRA    4304
....................  
....................             // write in the ~ 
....................             val[val_parse_pos] = '~'; 
4324:  CLRF   03
4326:  MOVF   x54,W
4328:  ADDLW  32
432A:  MOVWF  FE9
432C:  MOVLW  06
432E:  ADDWFC 03,W
4330:  MOVWF  FEA
4332:  MOVLW  7E
4334:  MOVWF  FEF
....................  
....................             // write in the number 
....................             val_parse_pos += 1; 
4336:  MOVLW  01
4338:  ADDWF  x54,F
....................             while(cur_fnum[fname_parse_pos] != '\0') 
....................             { 
433A:  CLRF   03
433C:  MOVF   x53,W
433E:  ADDLW  4A
4340:  MOVWF  FE9
4342:  MOVLW  06
4344:  ADDWFC 03,W
4346:  MOVWF  FEA
4348:  MOVF   FEF,F
434A:  BZ    4382
....................                val[val_parse_pos] = cur_fnum[fname_parse_pos]; 
434C:  CLRF   03
434E:  MOVF   x54,W
4350:  ADDLW  32
4352:  MOVWF  01
4354:  MOVLW  06
4356:  ADDWFC 03,F
4358:  MOVFF  03,65E
435C:  CLRF   03
435E:  MOVF   x53,W
4360:  ADDLW  4A
4362:  MOVWF  FE9
4364:  MOVLW  06
4366:  ADDWFC 03,W
4368:  MOVWF  FEA
436A:  MOVFF  FEF,65F
436E:  MOVFF  65E,FEA
4372:  MOVFF  01,FE9
4376:  MOVFF  65F,FEF
....................                val_parse_pos += 1; 
437A:  MOVLW  01
437C:  ADDWF  x54,F
....................                fname_parse_pos += 1; 
437E:  ADDWF  x53,F
....................             } 
4380:  BRA    433A
....................  
....................             // start the search over again to see if that unique file name/number combination is still taken up 
....................             i = parent_dir_addr; 
4382:  MOVFF  62D,65C
4386:  MOVFF  62C,65B
438A:  MOVFF  62B,65A
438E:  MOVFF  62A,659
4392:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // head to the next entry 
....................       if(get_next_entry(&i) == EOF) 
4394:  MOVLW  06
4396:  MOVLB  6
4398:  MOVWF  x7E
439A:  MOVLW  59
439C:  MOVWF  x7D
439E:  MOVLB  0
43A0:  CALL   2D18
43A4:  MOVF   01,W
43A6:  SUBLW  FF
43A8:  BNZ   43EA
....................       { 
....................          // we're going to have to allocate another cluster 
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
43AA:  MOVFF  65C,69D
43AE:  MOVFF  65B,69C
43B2:  MOVFF  65A,69B
43B6:  MOVFF  659,69A
43BA:  CALL   188E
43BE:  MOVFF  02,65E
43C2:  MOVFF  01,65D
43C6:  MOVFF  02,691
43CA:  MOVFF  01,690
43CE:  MOVLW  06
43D0:  MOVLB  6
43D2:  MOVWF  x93
43D4:  MOVLW  59
43D6:  MOVWF  x92
43D8:  MOVLB  0
43DA:  CALL   2568
43DE:  MOVF   01,W
43E0:  SUBLW  FF
43E2:  BNZ   43EA
....................             return EOF;          
43E4:  MOVLW  FF
43E6:  MOVWF  01
43E8:  BRA    4488
....................       } 
....................       if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
43EA:  MOVLW  0B
43EC:  MOVLB  6
43EE:  ADDWF  x59,W
43F0:  MOVWF  x5D
43F2:  MOVLW  00
43F4:  ADDWFC x5A,W
43F6:  MOVWF  x5E
43F8:  MOVLW  00
43FA:  ADDWFC x5B,W
43FC:  MOVWF  x5F
43FE:  MOVLW  00
4400:  ADDWFC x5C,W
4402:  MOVWF  x60
4404:  MOVWF  xAD
4406:  MOVFF  65F,6AC
440A:  MOVFF  65E,6AB
440E:  MOVFF  65D,6AA
4412:  CLRF   xAF
4414:  MOVLW  01
4416:  MOVWF  xAE
4418:  MOVLW  06
441A:  MOVWF  xB1
441C:  MOVLW  51
441E:  MOVWF  xB0
4420:  MOVLB  0
4422:  CALL   0DD6
4426:  MOVF   01,F
4428:  BZ    4430
....................          return EOF; 
442A:  MOVLW  FF
442C:  MOVWF  01
442E:  BRA    4488
....................    } 
4430:  BRA    423A
4432:  MOVLB  6
....................  
....................    // copy the short name into the input buffer 
....................    for(i = 0; i < 12; i += 1) 
4434:  CLRF   x5C
4436:  CLRF   x5B
4438:  CLRF   x5A
443A:  CLRF   x59
443C:  MOVF   x5C,F
443E:  BNZ   4484
4440:  MOVF   x5B,F
4442:  BNZ   4484
4444:  MOVF   x5A,F
4446:  BNZ   4484
4448:  MOVF   x59,W
444A:  SUBLW  0B
444C:  BNC   4484
....................       sname[i] = val[i]; 
444E:  MOVF   x30,W
4450:  ADDWF  x59,W
4452:  MOVWF  01
4454:  MOVF   x31,W
4456:  ADDWFC x5A,W
4458:  MOVWF  03
445A:  MOVLW  32
445C:  ADDWF  x59,W
445E:  MOVWF  FE9
4460:  MOVLW  06
4462:  ADDWFC x5A,W
4464:  MOVWF  FEA
4466:  MOVFF  FEF,65F
446A:  MOVFF  03,FEA
446E:  MOVFF  01,FE9
4472:  MOVFF  65F,FEF
4476:  MOVLW  01
4478:  ADDWF  x59,F
447A:  MOVLW  00
447C:  ADDWFC x5A,F
447E:  ADDWFC x5B,F
4480:  ADDWFC x5C,F
4482:  BRA    443C
....................  
....................    return GOODEC; 
4484:  MOVLW  00
4486:  MOVWF  01
4488:  MOVLB  0
.................... } 
448A:  GOTO   4724 (RETURN)
....................  
.................... /* 
.................... int long_name_chksum (int* FcbName) 
.................... Summary: Returns an unsigned byte checksum computed on an unsigned byte 
....................           array. The array must be 11 bytes long and is assumed to contain 
....................           a name stored in the format of a MS-DOS directory entry. 
.................... Param: Pointer to an unsigned byte array assumed to be 11 bytes long. 
.................... Returns: Sum An 8-bit unsigned checksum of the array pointed to by pFcbName. 
.................... */ 
.................... int long_name_chksum (int* pFcbName) 
.................... { 
448E:  MOVLB  6
4490:  CLRF   x2D
....................    int 
....................       FcbNameLen, 
....................       Sum = 0; 
....................  
....................    for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen -= 1) 
4492:  MOVLW  0B
4494:  MOVWF  x2C
4496:  MOVF   x2C,F
4498:  BZ    44CA
....................       // The operation is an unsigned char rotate right 
....................       Sum = ((Sum & 1) ? 0x80 : 0) + (Sum >> 1) + *pFcbName++; 
449A:  BTFSS  x2D.0
449C:  BRA    44A2
449E:  MOVLW  80
44A0:  BRA    44A4
44A2:  MOVLW  00
44A4:  MOVWF  x2E
44A6:  BCF    FD8.0
44A8:  RRCF   x2D,W
44AA:  ADDWF  x2E,F
44AC:  MOVFF  62B,03
44B0:  MOVF   x2A,W
44B2:  INCF   x2A,F
44B4:  BTFSC  FD8.2
44B6:  INCF   x2B,F
44B8:  MOVWF  FE9
44BA:  MOVFF  03,FEA
44BE:  MOVF   FEF,W
44C0:  ADDWF  x2E,W
44C2:  MOVWF  x2D
44C4:  MOVLW  01
44C6:  SUBWF  x2C,F
44C8:  BRA    4496
....................  
....................    return Sum; 
44CA:  MOVFF  62D,01
.................... } 
44CE:  MOVLB  0
44D0:  GOTO   473E (RETURN)
....................  
.................... /* 
.................... signed int check_invalid_char(char fname[]) 
.................... Summary: Checks the filename for any invalid characters. 
.................... Param: The name of the file to check. 
.................... Returns: EOF if an invalid character was found, GOODEC otherwise. 
.................... */ 
.................... signed int check_invalid_char(char fname[]) 
.................... { 
....................    int fname_pos; 
....................  
....................    for(fname_pos = 0; (fname[fname_pos] != '\0') && (fname_pos < MAX_FILE_NAME_LENGTH); fname_pos += 1) 
*
3EAA:  MOVLB  6
3EAC:  CLRF   x2C
3EAE:  CLRF   03
3EB0:  MOVF   x2C,W
3EB2:  ADDWF  x2A,W
3EB4:  MOVWF  FE9
3EB6:  MOVF   x2B,W
3EB8:  ADDWFC 03,W
3EBA:  MOVWF  FEA
3EBC:  MOVF   FEF,F
3EBE:  BZ    3F1A
3EC0:  MOVF   x2C,W
3EC2:  SUBLW  1F
3EC4:  BNC   3F1A
....................       if(isamoung(fname[fname_pos], "\\/:*?\"<>|")) 
3EC6:  CLRF   03
3EC8:  MOVF   x2C,W
3ECA:  ADDWF  x2A,W
3ECC:  MOVWF  FE9
3ECE:  MOVF   x2B,W
3ED0:  ADDWFC 03,W
3ED2:  MOVWF  FEA
3ED4:  MOVFF  FEF,62D
3ED8:  MOVF   x2D,W
3EDA:  SUBLW  22
3EDC:  BZ    3F0E
3EDE:  MOVF   x2D,W
3EE0:  SUBLW  2A
3EE2:  BZ    3F0E
3EE4:  MOVF   x2D,W
3EE6:  SUBLW  2F
3EE8:  BZ    3F0E
3EEA:  MOVF   x2D,W
3EEC:  SUBLW  3A
3EEE:  BZ    3F0E
3EF0:  MOVF   x2D,W
3EF2:  SUBLW  3C
3EF4:  BZ    3F0E
3EF6:  MOVF   x2D,W
3EF8:  SUBLW  3D
3EFA:  BC    3F02
3EFC:  MOVF   x2D,W
3EFE:  SUBLW  3F
3F00:  BC    3F0E
3F02:  MOVF   x2D,W
3F04:  SUBLW  5C
3F06:  BZ    3F0E
3F08:  MOVF   x2D,W
3F0A:  SUBLW  7C
3F0C:  BNZ   3F14
....................          return EOF; 
3F0E:  MOVLW  FF
3F10:  MOVWF  01
3F12:  BRA    3F1E
3F14:  MOVLW  01
3F16:  ADDWF  x2C,F
3F18:  BRA    3EAE
....................  
....................    return GOODEC; 
3F1A:  MOVLW  00
3F1C:  MOVWF  01
.................... } 
3F1E:  MOVLB  0
3F20:  GOTO   46F2 (RETURN)
....................  
.................... /* 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... Summary: Will go through the FAT and find the first unallocated cluster. 
.................... Param: Pointer to a variable that will the the starting cluster of the serach. 
....................         When a free cluster is found, the cluster number will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This gets a little slow when dealing with a card with lots of stuff on it; sorry about that. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAST_FAT 
....................    *my_cluster += 1; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................  
.................... #ifdef FAT32 
....................    int val[4];            // buffer to hold values 
....................  
....................    int32 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 2) + FAT_Start; 
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 4) 
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 4, val) != GOODEC) 
....................          return EOF; 
....................  
....................       cur_cluster = make32(val[3], val[2], val[1], val[0]); 
....................  
....................       if(cur_cluster == 0) 
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 2; 
....................          return GOODEC; 
....................       } 
....................    } 
.................... #else // FAT16 
....................    int val[2]; 
....................  
....................    int16 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 1) + FAT_Start; 
*
20B4:  MOVLB  6
20B6:  MOVFF  698,FE9
20BA:  MOVFF  699,FEA
20BE:  MOVFF  FEC,6A7
20C2:  MOVF   FED,F
20C4:  MOVFF  FEF,6A6
20C8:  BCF    FD8.0
20CA:  RLCF   xA6,F
20CC:  RLCF   xA7,F
20CE:  MOVLB  2
20D0:  MOVF   x16,W
20D2:  MOVLB  6
20D4:  ADDWF  xA6,W
20D6:  MOVWF  x9E
20D8:  MOVLB  2
20DA:  MOVF   x17,W
20DC:  MOVLB  6
20DE:  ADDWFC xA7,W
20E0:  MOVWF  x9F
20E2:  CLRF   xA0
20E4:  CLRF   xA1
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 2) 
20E6:  CLRF   xA5
20E8:  CLRF   xA4
20EA:  CLRF   xA3
20EC:  CLRF   xA2
20EE:  MOVF   xA5,W
20F0:  MOVLB  2
20F2:  SUBWF  x1F,W
20F4:  BTFSS  FD8.0
20F6:  BRA    21DE
20F8:  BNZ   2122
20FA:  MOVLB  6
20FC:  MOVF   xA4,W
20FE:  MOVLB  2
2100:  SUBWF  x1E,W
2102:  BNC   21DE
2104:  BNZ   2122
2106:  MOVLB  6
2108:  MOVF   xA3,W
210A:  MOVLB  2
210C:  SUBWF  x1D,W
210E:  BNC   21DE
2110:  BNZ   2122
2112:  MOVF   x1C,W
2114:  MOVLB  6
2116:  SUBWF  xA2,W
2118:  BTFSS  FD8.0
211A:  BRA    2120
211C:  MOVLB  2
211E:  BRA    21DE
2120:  MOVLB  2
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 2, val) != GOODEC) 
2122:  MOVLB  6
2124:  MOVF   xA2,W
2126:  ADDWF  x9E,W
2128:  MOVWF  xA6
212A:  MOVF   xA3,W
212C:  ADDWFC x9F,W
212E:  MOVWF  xA7
2130:  MOVF   xA4,W
2132:  ADDWFC xA0,W
2134:  MOVWF  xA8
2136:  MOVF   xA5,W
2138:  ADDWFC xA1,W
213A:  MOVWF  xA9
213C:  MOVWF  xAD
213E:  MOVFF  6A8,6AC
2142:  MOVFF  6A7,6AB
2146:  MOVFF  6A6,6AA
214A:  CLRF   xAF
214C:  MOVLW  02
214E:  MOVWF  xAE
2150:  MOVLW  06
2152:  MOVWF  xB1
2154:  MOVLW  9A
2156:  MOVWF  xB0
2158:  MOVLB  0
215A:  CALL   0DD6
215E:  MOVF   01,F
2160:  BZ    2168
....................          return EOF; 
2162:  MOVLW  FF
2164:  MOVWF  01
2166:  BRA    21E2
....................  
....................       cur_cluster = make16(val[1], val[0]); 
2168:  MOVFF  69B,69D
216C:  MOVFF  69A,69C
....................  
....................       if(cur_cluster == 0) 
2170:  MOVLB  6
2172:  MOVF   x9C,F
2174:  BNZ   21CE
2176:  MOVF   x9D,F
2178:  BNZ   21CE
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
217A:  MOVF   xA2,W
217C:  ADDWF  x9E,F
217E:  MOVF   xA3,W
2180:  ADDWFC x9F,F
2182:  MOVF   xA4,W
2184:  ADDWFC xA0,F
2186:  MOVF   xA5,W
2188:  ADDWFC xA1,F
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 1; 
218A:  MOVFF  698,FE9
218E:  MOVFF  699,FEA
2192:  MOVLB  2
2194:  MOVF   x16,W
2196:  MOVLB  6
2198:  SUBWF  x9E,W
219A:  MOVWF  xA8
219C:  MOVLB  2
219E:  MOVF   x17,W
21A0:  MOVLB  6
21A2:  SUBWFB x9F,W
21A4:  MOVWF  xA9
21A6:  MOVLW  00
21A8:  SUBWFB xA0,W
21AA:  MOVWF  xAA
21AC:  MOVLW  00
21AE:  SUBWFB xA1,W
21B0:  MOVWF  xAB
21B2:  BCF    FD8.0
21B4:  RRCF   xAB,W
21B6:  RRCF   xAA,W
21B8:  RRCF   xA9,W
21BA:  MOVWF  01
21BC:  RRCF   xA8,W
21BE:  MOVWF  FEF
21C0:  MOVFF  01,FEC
....................          return GOODEC; 
21C4:  MOVLW  00
21C6:  MOVWF  01
21C8:  MOVLB  0
21CA:  BRA    21E2
21CC:  MOVLB  6
....................       } 
....................    } 
21CE:  MOVLW  02
21D0:  ADDWF  xA2,F
21D2:  MOVLW  00
21D4:  ADDWFC xA3,F
21D6:  ADDWFC xA4,F
21D8:  ADDWFC xA5,F
21DA:  BRA    20EE
21DC:  MOVLB  2
....................  
.................... #endif // #ifdef FAT32 
....................    // if we reach this point, we are out of disk space 
....................    return EOF; 
21DE:  MOVLW  FF
21E0:  MOVWF  01
21E2:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
.................... } 
21E4:  RETLW  00
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the next file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_next_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry, 
....................       filetype; 
....................     
....................    cur_addr = stream->Entry_Addr; 
*
4EDE:  MOVLW  08
4EE0:  MOVLB  5
4EE2:  ADDWF  xC5,W
4EE4:  MOVWF  FE9
4EE6:  MOVLW  00
4EE8:  ADDWFC xC6,W
4EEA:  MOVWF  FEA
4EEC:  MOVFF  FEF,00
4EF0:  MOVFF  FEC,01
4EF4:  MOVFF  FEC,02
4EF8:  MOVFF  FEC,03
4EFC:  MOVFF  03,5CE
4F00:  MOVFF  02,5CD
4F04:  MOVFF  01,5CC
4F08:  MOVFF  00,5CB
....................      
....................    do 
....................    {      
....................       // go forward an entry 
....................       if(get_next_entry(&cur_addr) == EOF) 
4F0C:  MOVLW  05
4F0E:  MOVLB  6
4F10:  MOVWF  x7E
4F12:  MOVLW  CB
4F14:  MOVWF  x7D
4F16:  MOVLB  0
4F18:  CALL   2D18
4F1C:  MOVF   01,W
4F1E:  SUBLW  FF
4F20:  BNZ   4F3A
....................       { 
....................          stream->File_Type = None; 
4F22:  MOVLW  18
4F24:  MOVLB  5
4F26:  ADDWF  xC5,W
4F28:  MOVWF  FE9
4F2A:  MOVLW  00
4F2C:  ADDWFC xC6,W
4F2E:  MOVWF  FEA
4F30:  MOVLW  02
4F32:  MOVWF  FEF
....................          return EOF; 
4F34:  MOVLW  FF
4F36:  MOVWF  01
4F38:  BRA    5176
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
4F3A:  MOVFF  5CE,6AD
4F3E:  MOVFF  5CD,6AC
4F42:  MOVFF  5CC,6AB
4F46:  MOVFF  5CB,6AA
4F4A:  MOVLB  6
4F4C:  CLRF   xAF
4F4E:  MOVLW  01
4F50:  MOVWF  xAE
4F52:  MOVLW  05
4F54:  MOVWF  xB1
4F56:  MOVLW  D3
4F58:  MOVWF  xB0
4F5A:  MOVLB  0
4F5C:  CALL   0DD6
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
4F60:  MOVLW  0B
4F62:  MOVLB  5
4F64:  ADDWF  xCB,W
4F66:  MOVWF  xD5
4F68:  MOVLW  00
4F6A:  ADDWFC xCC,W
4F6C:  MOVWF  xD6
4F6E:  MOVLW  00
4F70:  ADDWFC xCD,W
4F72:  MOVWF  xD7
4F74:  MOVLW  00
4F76:  ADDWFC xCE,W
4F78:  MOVWF  xD8
4F7A:  MOVFF  FE8,6AD
4F7E:  MOVFF  5D7,6AC
4F82:  MOVFF  5D6,6AB
4F86:  MOVFF  5D5,6AA
4F8A:  MOVLB  6
4F8C:  CLRF   xAF
4F8E:  MOVLW  01
4F90:  MOVWF  xAE
4F92:  MOVLW  05
4F94:  MOVWF  xB1
4F96:  MOVLW  D4
4F98:  MOVWF  xB0
4F9A:  MOVLB  0
4F9C:  CALL   0DD6
....................  
....................       if(fileentry == 0) 
4FA0:  MOVLB  5
4FA2:  MOVF   xD3,F
4FA4:  BNZ   4FBC
....................       { 
....................          stream->File_Type = None; 
4FA6:  MOVLW  18
4FA8:  ADDWF  xC5,W
4FAA:  MOVWF  FE9
4FAC:  MOVLW  00
4FAE:  ADDWFC xC6,W
4FB0:  MOVWF  FEA
4FB2:  MOVLW  02
4FB4:  MOVWF  FEF
....................          return EOF; 
4FB6:  MOVLW  FF
4FB8:  MOVWF  01
4FBA:  BRA    5176
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
4FBC:  MOVF   xD3,W
4FBE:  SUBLW  E5
4FC0:  BZ    4F0C
4FC2:  MOVF   xD4,W
4FC4:  SUBLW  0F
4FC6:  BZ    4F0C
....................     
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
4FC8:  MOVF   xD4,W
4FCA:  SUBLW  10
4FCC:  BNZ   4FE0
....................       stream->File_Type = Directory; 
4FCE:  MOVLW  18
4FD0:  ADDWF  xC5,W
4FD2:  MOVWF  FE9
4FD4:  MOVLW  00
4FD6:  ADDWFC xC6,W
4FD8:  MOVWF  FEA
4FDA:  MOVLW  01
4FDC:  MOVWF  FEF
....................    else 
4FDE:  BRA    4FEE
....................       stream->File_Type = Data_File; 
4FE0:  MOVLW  18
4FE2:  ADDWF  xC5,W
4FE4:  MOVWF  FE9
4FE6:  MOVLW  00
4FE8:  ADDWFC xC6,W
4FEA:  MOVWF  FEA
4FEC:  CLRF   FEF
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
4FEE:  MOVLW  08
4FF0:  ADDWF  xC5,W
4FF2:  MOVWF  FE9
4FF4:  MOVLW  00
4FF6:  ADDWFC xC6,W
4FF8:  MOVWF  FEA
4FFA:  MOVFF  5CB,FEF
4FFE:  MOVFF  5CC,FEC
5002:  MOVFF  5CD,FEC
5006:  MOVFF  5CE,FEC
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
500A:  MOVLW  1A
500C:  ADDWF  xCB,W
500E:  MOVWF  xD5
5010:  MOVLW  00
5012:  ADDWFC xCC,W
5014:  MOVWF  xD6
5016:  MOVLW  00
5018:  ADDWFC xCD,W
501A:  MOVWF  xD7
501C:  MOVLW  00
501E:  ADDWFC xCE,W
5020:  MOVWF  xD8
5022:  MOVFF  FE8,6AD
5026:  MOVFF  5D7,6AC
502A:  MOVFF  5D6,6AB
502E:  MOVFF  5D5,6AA
5032:  MOVLB  6
5034:  CLRF   xAF
5036:  MOVLW  02
5038:  MOVWF  xAE
503A:  MOVLW  05
503C:  MOVWF  xB1
503E:  MOVLW  C7
5040:  MOVWF  xB0
5042:  MOVLB  0
5044:  CALL   0DD6
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
5048:  MOVLW  14
504A:  MOVLB  5
504C:  ADDWF  xCB,W
504E:  MOVWF  xD5
5050:  MOVLW  00
5052:  ADDWFC xCC,W
5054:  MOVWF  xD6
5056:  MOVLW  00
5058:  ADDWFC xCD,W
505A:  MOVWF  xD7
505C:  MOVLW  00
505E:  ADDWFC xCE,W
5060:  MOVWF  xD8
5062:  MOVFF  FE8,6AD
5066:  MOVFF  5D7,6AC
506A:  MOVFF  5D6,6AB
506E:  MOVFF  5D5,6AA
5072:  MOVLB  6
5074:  CLRF   xAF
5076:  MOVLW  02
5078:  MOVWF  xAE
507A:  MOVLW  05
507C:  MOVWF  xB1
507E:  MOVLW  C9
5080:  MOVWF  xB0
5082:  MOVLB  0
5084:  CALL   0DD6
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  cluster_to_addr(cluster); 
5088:  MOVLW  14
508A:  MOVLB  5
508C:  ADDWF  xC5,W
508E:  MOVWF  01
5090:  MOVLW  00
5092:  ADDWFC xC6,W
5094:  MOVWF  03
5096:  MOVFF  01,5D5
509A:  MOVWF  xD6
509C:  MOVLW  04
509E:  ADDWF  xC5,W
50A0:  MOVWF  01
50A2:  MOVLW  00
50A4:  ADDWFC xC6,W
50A6:  MOVWF  03
50A8:  MOVFF  01,5D7
50AC:  MOVWF  xD8
50AE:  MOVFF  5C8,5DA
50B2:  MOVFF  5C7,5D9
50B6:  MOVFF  5C8,6C2
50BA:  MOVFF  5C7,6C1
50BE:  MOVLB  0
50C0:  CALL   19DA
50C4:  MOVFF  5D8,FEA
50C8:  MOVFF  5D7,FE9
50CC:  MOVFF  00,FEF
50D0:  MOVFF  01,FEC
50D4:  MOVFF  02,FEC
50D8:  MOVFF  03,FEC
50DC:  MOVFF  5D6,FEA
50E0:  MOVFF  5D5,FE9
50E4:  MOVFF  00,FEF
50E8:  MOVFF  01,FEC
50EC:  MOVFF  02,FEC
50F0:  MOVFF  03,FEC
....................     
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
50F4:  MOVLW  1C
50F6:  MOVLB  5
50F8:  ADDWF  xCB,W
50FA:  MOVWF  xD5
50FC:  MOVLW  00
50FE:  ADDWFC xCC,W
5100:  MOVWF  xD6
5102:  MOVLW  00
5104:  ADDWFC xCD,W
5106:  MOVWF  xD7
5108:  MOVLW  00
510A:  ADDWFC xCE,W
510C:  MOVWF  xD8
510E:  MOVFF  FE8,6AD
5112:  MOVFF  5D7,6AC
5116:  MOVFF  5D6,6AB
511A:  MOVFF  5D5,6AA
511E:  MOVLB  6
5120:  CLRF   xAF
5122:  MOVLW  04
5124:  MOVWF  xAE
5126:  MOVLW  05
5128:  MOVWF  xB1
512A:  MOVLW  CF
512C:  MOVWF  xB0
512E:  MOVLB  0
5130:  CALL   0DD6
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
5134:  MOVLW  10
5136:  MOVLB  5
5138:  ADDWF  xC5,W
513A:  MOVWF  01
513C:  MOVLW  00
513E:  ADDWFC xC6,W
5140:  MOVFF  01,5D5
5144:  MOVFF  5C5,FE9
5148:  MOVFF  5C6,FEA
514C:  MOVFF  5CF,FEF
5150:  MOVFF  5D0,FEC
5154:  MOVFF  5D1,FEC
5158:  MOVFF  5D2,FEC
515C:  MOVWF  FEA
515E:  MOVFF  5D5,FE9
5162:  MOVFF  5CF,FEF
5166:  MOVFF  5D0,FEC
516A:  MOVFF  5D1,FEC
516E:  MOVFF  5D2,FEC
....................  
....................    return GOODEC; 
5172:  MOVLW  00
5174:  MOVWF  01
.................... } 
5176:  MOVLB  0
5178:  RETLW  00
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the previous file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_prev_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry = 0xE5, 
....................       filetype = 0; 
....................     
....................    cur_addr = stream->Entry_Addr; 
....................      
....................    do 
....................    {      
....................       // go backward an entry 
....................       if(get_prev_entry(&cur_addr) == EOF) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
....................  
....................       if(fileentry == 0) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
....................  
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
....................       stream->File_Type = Directory; 
....................    else 
....................       stream->File_Type = Data_File; 
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  addr_to_cluster(cluster); 
....................  
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... Summary: Finds the next unallocated address. 
.................... Param: Pointer to a variable that will the the starting address of the serach. 
....................         When a free address is found, the address will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... { 
....................    int val;   // buffer to hold values 
....................  
....................    int32 cur_addr;   // pointer to memory 
....................  
....................    // make a copy of *my_addr 
....................    cur_addr = *my_addr; 
....................  
....................    // keep on getting addresses until we hit a free one 
....................    do 
....................    { 
....................       if(mmcsd_read_data(cur_addr, 1, &val) != GOODEC) 
....................          return EOF; 
....................  
....................       if(get_next_addr(&cur_addr) == EOF) 
....................          return EOF; 
....................    } while(val != 0); 
....................  
....................    *my_addr = cur_addr; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_entry(int32* start_addr) 
.................... Summary: Gets the next entry in a directory. 
.................... Param: The address to start looking for an entry. 
....................    If an entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
2D18:  MOVLB  6
2D1A:  MOVFF  67D,FE9
2D1E:  MOVFF  67E,FEA
2D22:  MOVFF  FEF,00
2D26:  MOVFF  FEC,01
2D2A:  MOVFF  FEC,02
2D2E:  MOVFF  FEC,03
2D32:  MOVFF  03,682
2D36:  MOVFF  02,681
2D3A:  MOVFF  01,680
2D3E:  MOVFF  00,67F
....................     
....................    i += 0x1F; 
2D42:  MOVLW  1F
2D44:  ADDWF  x7F,F
2D46:  MOVLW  00
2D48:  ADDWFC x80,F
2D4A:  ADDWFC x81,F
2D4C:  ADDWFC x82,F
....................     
....................    if(get_next_addr(&i) == EOF) 
2D4E:  MOVLW  06
2D50:  MOVWF  x8F
2D52:  MOVLW  7F
2D54:  MOVWF  x8E
2D56:  MOVLB  0
2D58:  CALL   23EC
2D5C:  MOVF   01,W
2D5E:  SUBLW  FF
2D60:  BNZ   2D68
....................       return EOF; 
2D62:  MOVLW  FF
2D64:  MOVWF  01
2D66:  BRA    2D86
....................     
....................    *start_addr = i; 
2D68:  MOVLB  6
2D6A:  MOVFF  67D,FE9
2D6E:  MOVFF  67E,FEA
2D72:  MOVFF  67F,FEF
2D76:  MOVFF  680,FEC
2D7A:  MOVFF  681,FEC
2D7E:  MOVFF  682,FEC
....................     
....................    return GOODEC; 
2D82:  MOVLW  00
2D84:  MOVWF  01
2D86:  MOVLB  0
.................... } 
2D88:  RETLW  00
....................  
.................... /* 
.................... signed int get_prev_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
1BDA:  MOVLB  6
1BDC:  MOVFF  68B,FE9
1BE0:  MOVFF  68C,FEA
1BE4:  MOVFF  FEF,00
1BE8:  MOVFF  FEC,01
1BEC:  MOVFF  FEC,02
1BF0:  MOVFF  FEC,03
1BF4:  MOVFF  03,690
1BF8:  MOVFF  02,68F
1BFC:  MOVFF  01,68E
1C00:  MOVFF  00,68D
....................  
....................    i -= 0x1F; 
1C04:  MOVLW  1F
1C06:  SUBWF  x8D,F
1C08:  MOVLW  00
1C0A:  SUBWFB x8E,F
1C0C:  SUBWFB x8F,F
1C0E:  SUBWFB x90,F
....................  
....................    if(get_prev_addr(&i) == EOF) 
1C10:  MOVLW  06
1C12:  MOVWF  x92
1C14:  MOVLW  8D
1C16:  MOVWF  x91
1C18:  MOVLB  0
1C1A:  BRA    1A46
1C1C:  MOVF   01,W
1C1E:  SUBLW  FF
1C20:  BNZ   1C28
....................       return EOF; 
1C22:  MOVLW  FF
1C24:  MOVWF  01
1C26:  BRA    1C46
....................  
....................    *start_addr = i; 
1C28:  MOVLB  6
1C2A:  MOVFF  68B,FE9
1C2E:  MOVFF  68C,FEA
1C32:  MOVFF  68D,FEF
1C36:  MOVFF  68E,FEC
1C3A:  MOVFF  68F,FEC
1C3E:  MOVFF  690,FEC
....................     
....................    return GOODEC; 
1C42:  MOVLW  00
1C44:  MOVWF  01
1C46:  MOVLB  0
.................... } 
1C48:  RETLW  00
....................  
.................... /* 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... { 
....................    int buf; 
....................  
....................    int32 i; 
....................  
....................    i = *start_addr; 
*
44D4:  MOVLB  6
44D6:  MOVFF  62A,FE9
44DA:  MOVFF  62B,FEA
44DE:  MOVFF  FEF,00
44E2:  MOVFF  FEC,01
44E6:  MOVFF  FEC,02
44EA:  MOVFF  FEC,03
44EE:  MOVFF  03,630
44F2:  MOVFF  02,62F
44F6:  MOVFF  01,62E
44FA:  MOVFF  00,62D
....................  
....................    if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
44FE:  MOVFF  630,6AD
4502:  MOVFF  62F,6AC
4506:  MOVFF  62E,6AB
450A:  MOVFF  62D,6AA
450E:  CLRF   xAF
4510:  MOVLW  01
4512:  MOVWF  xAE
4514:  MOVLW  06
4516:  MOVWF  xB1
4518:  MOVLW  2C
451A:  MOVWF  xB0
451C:  MOVLB  0
451E:  CALL   0DD6
4522:  MOVF   01,F
4524:  BZ    452C
....................      return EOF; 
4526:  MOVLW  FF
4528:  MOVWF  01
452A:  BRA    45E2
....................  
....................    while(buf != 0) 
....................    { 
452C:  MOVLB  6
452E:  MOVF   x2C,F
4530:  BZ    45C6
....................       i += 0x1F; 
4532:  MOVLW  1F
4534:  ADDWF  x2D,F
4536:  MOVLW  00
4538:  ADDWFC x2E,F
453A:  ADDWFC x2F,F
453C:  ADDWFC x30,F
....................       // get the next address 
....................       if(get_next_addr(&i) == EOF) 
453E:  MOVLW  06
4540:  MOVWF  x8F
4542:  MOVLW  2D
4544:  MOVWF  x8E
4546:  MOVLB  0
4548:  CALL   23EC
454C:  MOVF   01,W
454E:  SUBLW  FF
4550:  BNZ   4592
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
4552:  MOVFF  630,69D
4556:  MOVFF  62F,69C
455A:  MOVFF  62E,69B
455E:  MOVFF  62D,69A
4562:  CALL   188E
4566:  MOVFF  02,632
456A:  MOVFF  01,631
456E:  MOVFF  02,691
4572:  MOVFF  01,690
4576:  MOVLW  06
4578:  MOVLB  6
457A:  MOVWF  x93
457C:  MOVLW  2D
457E:  MOVWF  x92
4580:  MOVLB  0
4582:  CALL   2568
4586:  MOVF   01,W
4588:  SUBLW  FF
458A:  BNZ   4592
....................             return EOF; 
458C:  MOVLW  FF
458E:  MOVWF  01
4590:  BRA    45E2
....................  
....................       if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
4592:  MOVFF  630,6AD
4596:  MOVFF  62F,6AC
459A:  MOVFF  62E,6AB
459E:  MOVFF  62D,6AA
45A2:  MOVLB  6
45A4:  CLRF   xAF
45A6:  MOVLW  01
45A8:  MOVWF  xAE
45AA:  MOVLW  06
45AC:  MOVWF  xB1
45AE:  MOVLW  2C
45B0:  MOVWF  xB0
45B2:  MOVLB  0
45B4:  CALL   0DD6
45B8:  MOVF   01,F
45BA:  BZ    45C2
....................         return EOF; 
45BC:  MOVLW  FF
45BE:  MOVWF  01
45C0:  BRA    45E2
....................    } 
45C2:  BRA    452C
45C4:  MOVLB  6
....................  
....................    *start_addr = i; 
45C6:  MOVFF  62A,FE9
45CA:  MOVFF  62B,FEA
45CE:  MOVFF  62D,FEF
45D2:  MOVFF  62E,FEC
45D6:  MOVFF  62F,FEC
45DA:  MOVFF  630,FEC
....................  
....................    return GOODEC; 
45DE:  MOVLW  00
45E0:  MOVWF  01
45E2:  MOVLB  0
.................... } 
45E4:  RETLW  00
....................  
.................... /* 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... Summary: Find, allocate, and link a free cluster. 
.................... Param start_cluster: The cluster to begin looking for free clusters. This cluster will be linked to the newfound cluster in the FAT. 
.................... Param new_cluster_addr: The address of the newly allocated cluster. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr) 
.................... #else 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster, 
....................       next_cluster; 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster, 
....................       next_cluster; 
.................... #endif // #ifdef FAT32 
....................  
....................    // if we're at the end of the file's allocated space, then we need to allocate some more space 
....................    //  figure out where the current character is pointing to 
....................    next_cluster = cur_cluster = start_cluster; 
*
2568:  MOVFF  691,695
256C:  MOVFF  690,694
2570:  MOVFF  695,697
2574:  MOVFF  694,696
....................  
....................    // get the next free cluster 
....................    if(get_next_free_cluster(&next_cluster) == EOF) 
2578:  MOVLW  06
257A:  MOVLB  6
257C:  MOVWF  x99
257E:  MOVLW  96
2580:  MOVWF  x98
2582:  MOVLB  0
2584:  RCALL  20B4
2586:  MOVF   01,W
2588:  SUBLW  FF
258A:  BNZ   2592
....................       return EOF; 
258C:  MOVLW  FF
258E:  MOVWF  01
2590:  BRA    261C
....................  
....................    if(write_fat(cur_cluster, next_cluster) == EOF) 
2592:  MOVFF  695,699
2596:  MOVFF  694,698
259A:  MOVFF  697,69B
259E:  MOVFF  696,69A
25A2:  RCALL  1F7A
25A4:  MOVF   01,W
25A6:  SUBLW  FF
25A8:  BNZ   25B0
....................       return EOF; 
25AA:  MOVLW  FF
25AC:  MOVWF  01
25AE:  BRA    261C
....................  
.................... #ifdef FAT32 
....................    if(write_fat(next_cluster, 0x0FFFFFFF) == EOF) 
....................       return EOF; 
....................  
.................... #else // FAT16 
....................    if(write_fat(next_cluster, 0xFFFF) == EOF) 
25B0:  MOVFF  697,699
25B4:  MOVFF  696,698
25B8:  MOVLW  FF
25BA:  MOVLB  6
25BC:  MOVWF  x9B
25BE:  MOVWF  x9A
25C0:  MOVLB  0
25C2:  RCALL  1F7A
25C4:  MOVF   01,W
25C6:  SUBLW  FF
25C8:  BNZ   25D0
....................       return EOF; 
25CA:  MOVLW  FF
25CC:  MOVWF  01
25CE:  BRA    261C
.................... #endif // #ifdef FAT32 
....................  
....................    // erase all of the data in the newly linked cluster 
....................    if(clear_cluster(next_cluster) == EOF) 
25D0:  MOVFF  697,699
25D4:  MOVFF  696,698
25D8:  RCALL  21E6
25DA:  MOVF   01,W
25DC:  SUBLW  FF
25DE:  BNZ   25E6
....................       return EOF; 
25E0:  MOVLW  FF
25E2:  MOVWF  01
25E4:  BRA    261C
....................  
....................    // put the current character to this position 
....................    *new_cluster_addr = cluster_to_addr(next_cluster); 
25E6:  MOVFF  693,03
25EA:  MOVFF  692,698
25EE:  MOVFF  693,699
25F2:  MOVFF  697,6C2
25F6:  MOVFF  696,6C1
25FA:  MOVLB  0
25FC:  CALL   19DA
2600:  MOVFF  699,FEA
2604:  MOVFF  698,FE9
2608:  MOVFF  00,FEF
260C:  MOVFF  01,FEC
2610:  MOVFF  02,FEC
2614:  MOVFF  03,FEC
....................  
....................    return GOODEC; 
2618:  MOVLW  00
261A:  MOVWF  01
.................... } 
261C:  RETLW  00
....................  
.................... /* 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... Summary: De-allocates linked clusters from the FAT. 
.................... Param: The starting cluster to deallocate. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int dealloc_clusters(int32 start_cluster) 
.................... #else 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #endif // #ifdef FAT32 
....................  
....................    //  figure out where the first cluster is 
....................    next_cluster = cur_cluster = start_cluster; 
*
1FC4:  MOVFF  680,682
1FC8:  MOVFF  67F,681
1FCC:  MOVFF  682,684
1FD0:  MOVFF  681,683
....................    do 
....................    { 
....................       // get the next cluster 
....................       if(get_next_cluster(&next_cluster) == EOF) 
1FD4:  MOVLW  06
1FD6:  MOVLB  6
1FD8:  MOVWF  x97
1FDA:  MOVLW  83
1FDC:  MOVWF  x96
1FDE:  MOVLB  0
1FE0:  RCALL  1E3C
1FE2:  MOVF   01,W
1FE4:  SUBLW  FF
1FE6:  BNZ   1FEE
....................          return EOF; 
1FE8:  MOVLW  FF
1FEA:  MOVWF  01
1FEC:  BRA    202E
....................  
....................       // unlink the current cluster in the FAT 
....................       if(write_fat(cur_cluster, 0) == EOF) 
1FEE:  MOVFF  682,699
1FF2:  MOVFF  681,698
1FF6:  MOVLB  6
1FF8:  CLRF   x9B
1FFA:  CLRF   x9A
1FFC:  MOVLB  0
1FFE:  RCALL  1F7A
2000:  MOVF   01,W
2002:  SUBLW  FF
2004:  BNZ   200C
....................          return EOF; 
2006:  MOVLW  FF
2008:  MOVWF  01
200A:  BRA    202E
....................  
....................       cur_cluster = next_cluster; 
200C:  MOVFF  684,682
2010:  MOVFF  683,681
....................    } 
.................... #ifdef FAT32 
....................     while(cur_cluster != 0x0FFFFFFF); 
.................... #else // FAT16 
....................     while(cur_cluster != 0xFFFF); 
2014:  MOVLB  6
2016:  INCFSZ x81,W
2018:  BRA    201C
201A:  BRA    2020
201C:  MOVLB  0
201E:  BRA    1FD4
2020:  INCFSZ x82,W
2022:  BRA    2026
2024:  BRA    202A
2026:  MOVLB  0
2028:  BRA    1FD4
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
202A:  MOVLW  00
202C:  MOVWF  01
202E:  MOVLB  0
.................... } 
2030:  RETLW  00
....................  
.................... /* 
.................... signed int clear_cluster(int16 cluster) 
.................... Summary: Clears out all of the data in a given cluster. 
.................... Param: The cluster to clear out. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int clear_cluster(int32 cluster) 
.................... #else 
.................... signed int clear_cluster(int16 cluster) 
.................... #endif 
.................... { 
....................    int 
....................       clear_entry[0x20], 
....................       j; 
....................  
....................    int16 i; 
....................  
....................    int32 start_addr; 
....................  
....................    start_addr = cluster_to_addr(cluster); 
*
21E6:  MOVFF  699,6C2
21EA:  MOVFF  698,6C1
21EE:  CALL   19DA
21F2:  MOVFF  03,6C0
21F6:  MOVFF  02,6BF
21FA:  MOVFF  01,6BE
21FE:  MOVFF  00,6BD
....................     
....................    for(j = 0; j < 0x20; j += 1) 
2202:  MOVLB  6
2204:  CLRF   xBA
2206:  MOVF   xBA,W
2208:  SUBLW  1F
220A:  BNC   2222
....................       clear_entry[j] = 0; 
220C:  CLRF   03
220E:  MOVF   xBA,W
2210:  ADDLW  9A
2212:  MOVWF  FE9
2214:  MOVLW  06
2216:  ADDWFC 03,W
2218:  MOVWF  FEA
221A:  CLRF   FEF
221C:  MOVLW  01
221E:  ADDWF  xBA,F
2220:  BRA    2206
....................  
....................    for(i = 0; i < Bytes_Per_Cluster; i += 0x20) 
2222:  CLRF   xBC
2224:  CLRF   xBB
2226:  MOVF   xBC,W
2228:  MOVLB  2
222A:  SUBWF  x15,W
222C:  BNC   2292
222E:  BNZ   2240
2230:  MOVF   x14,W
2232:  MOVLB  6
2234:  SUBWF  xBB,W
2236:  BTFSS  FD8.0
2238:  BRA    223E
223A:  MOVLB  2
223C:  BRA    2292
223E:  MOVLB  2
....................       if(mmcsd_write_data(start_addr + i, 0x20, clear_entry) != GOODEC) 
2240:  MOVLB  6
2242:  MOVF   xBB,W
2244:  ADDWF  xBD,W
2246:  MOVWF  xC1
2248:  MOVF   xBC,W
224A:  ADDWFC xBE,W
224C:  MOVWF  xC2
224E:  MOVLW  00
2250:  ADDWFC xBF,W
2252:  MOVWF  xC3
2254:  MOVLW  00
2256:  ADDWFC xC0,W
2258:  MOVWF  xC4
225A:  MOVWF  xC8
225C:  MOVFF  6C3,6C7
2260:  MOVFF  6C2,6C6
2264:  MOVFF  6C1,6C5
2268:  CLRF   xCA
226A:  MOVLW  20
226C:  MOVWF  xC9
226E:  MOVLW  06
2270:  MOVWF  xCC
2272:  MOVLW  9A
2274:  MOVWF  xCB
2276:  MOVLB  0
2278:  RCALL  1EE8
227A:  MOVF   01,F
227C:  BZ    2284
....................          return EOF; 
227E:  MOVLW  FF
2280:  MOVWF  01
2282:  BRA    2296
2284:  MOVLW  20
2286:  MOVLB  6
2288:  ADDWF  xBB,F
228A:  MOVLW  00
228C:  ADDWFC xBC,F
228E:  BRA    2226
2290:  MOVLB  2
....................  
....................    return GOODEC; 
2292:  MOVLW  00
2294:  MOVWF  01
2296:  MOVLB  0
.................... } 
2298:  RETLW  00
....................  
.................... /* 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... Summary: Writes specified data about a cluster to the FAT. 
.................... Param cluster: The cluster to modify the in the FAT. 
.................... Param data: The data about the cluster to put into the FAT. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 2) + FAT_Start, 4, &data) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
.................... #else // FAT16 
.................... signed int write_fat(int16 cluster, int16 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 1) + FAT_Start, 2, &data) != GOODEC) 
*
1F7A:  BCF    FD8.0
1F7C:  MOVLB  6
1F7E:  RLCF   x98,W
1F80:  MOVWF  x9D
1F82:  RLCF   x99,W
1F84:  MOVWF  x9E
1F86:  MOVLB  2
1F88:  MOVF   x16,W
1F8A:  MOVLB  6
1F8C:  ADDWF  x9D,F
1F8E:  MOVLB  2
1F90:  MOVF   x17,W
1F92:  MOVLB  6
1F94:  ADDWFC x9E,F
1F96:  CLRF   xC8
1F98:  CLRF   xC7
1F9A:  MOVFF  69E,6C6
1F9E:  MOVFF  69D,6C5
1FA2:  CLRF   xCA
1FA4:  MOVLW  02
1FA6:  MOVWF  xC9
1FA8:  MOVLW  06
1FAA:  MOVWF  xCC
1FAC:  MOVLW  9A
1FAE:  MOVWF  xCB
1FB0:  MOVLB  0
1FB2:  RCALL  1EE8
1FB4:  MOVF   01,F
1FB6:  BZ    1FBE
....................       return EOF; 
1FB8:  MOVLW  FF
1FBA:  MOVWF  01
1FBC:  BRA    1FC2
....................  
....................    return GOODEC; 
1FBE:  MOVLW  00
1FC0:  MOVWF  01
.................... } 
1FC2:  RETLW  00
.................... #endif // #ifdef FAT32 
....................  
.................... /* 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... Summary: Reads from the buffer. 
.................... Param stream: The stream whose buffer to read from. 
.................... Param val: A pointer to a varaible to put the read data into. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... { 
....................    int i;    // counter for loops 
....................  
....................    // check to see if we need to populate the buffer 
....................    if((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
*
539C:  MOVLW  04
539E:  MOVLB  5
53A0:  ADDWF  xAA,W
53A2:  MOVWF  FE9
53A4:  MOVLW  00
53A6:  ADDWFC xAB,W
53A8:  MOVWF  FEA
53AA:  MOVFF  FEF,5AF
53AE:  MOVFF  FEC,5B0
53B2:  MOVFF  FEC,5B1
53B6:  MOVFF  FEC,5B2
53BA:  MOVLW  1F
53BC:  ANDWF  xAF,F
53BE:  CLRF   xB0
53C0:  CLRF   xB1
53C2:  CLRF   xB2
53C4:  MOVF   xAF,F
53C6:  BNZ   5446
53C8:  MOVF   xB0,F
53CA:  BNZ   5446
53CC:  MOVF   xB1,F
53CE:  BNZ   5446
53D0:  MOVF   xB2,F
53D2:  BNZ   5446
....................    { 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
53D4:  MOVLW  04
53D6:  ADDWF  xAA,W
53D8:  MOVWF  FE9
53DA:  MOVLW  00
53DC:  ADDWFC xAB,W
53DE:  MOVWF  FEA
53E0:  MOVFF  FEF,5AF
53E4:  MOVFF  FEC,5B0
53E8:  MOVFF  FEC,5B1
53EC:  MOVFF  FEC,5B2
53F0:  MOVLW  1A
53F2:  ADDWF  xAA,W
53F4:  MOVWF  01
53F6:  MOVLW  00
53F8:  ADDWFC xAB,W
53FA:  MOVWF  03
53FC:  MOVFF  01,5B3
5400:  MOVWF  xB4
5402:  MOVFF  5B2,6AD
5406:  MOVFF  5B1,6AC
540A:  MOVFF  5B0,6AB
540E:  MOVFF  5AF,6AA
5412:  MOVLB  6
5414:  CLRF   xAF
5416:  MOVLW  20
5418:  MOVWF  xAE
541A:  MOVFF  03,6B1
541E:  MOVFF  01,6B0
5422:  MOVLB  0
5424:  CALL   0DD6
5428:  MOVF   01,F
542A:  BZ    5448
....................       { 
....................          stream->Flags |= Read_Error; 
542C:  MOVLW  19
542E:  MOVLB  5
5430:  ADDWF  xAA,W
5432:  MOVWF  FE9
5434:  MOVLW  00
5436:  ADDWFC xAB,W
5438:  MOVWF  FEA
543A:  MOVF   FEF,W
543C:  IORLW  20
543E:  MOVWF  FEF
....................          return EOF; 
5440:  MOVLW  FF
5442:  MOVWF  01
5444:  BRA    54AA
5446:  MOVLB  0
....................       } 
....................    } 
....................  
....................    // grab the value at the top of the buffer 
....................    *val = stream->Buf[0]; 
5448:  MOVLB  5
544A:  MOVLW  1A
544C:  ADDWF  xAA,W
544E:  MOVWF  FE9
5450:  MOVLW  00
5452:  ADDWFC xAB,W
5454:  MOVWF  FEA
5456:  MOVFF  FEF,5B1
545A:  MOVFF  5AD,FEA
545E:  MOVFF  5AC,FE9
5462:  MOVFF  5B1,FEF
....................  
....................    // shift everything over 1 byte to put a new value at the top of the buffer 
....................    for(i = 0; i < 8; i += 1) 
5466:  CLRF   xAE
5468:  MOVF   xAE,W
546A:  SUBLW  07
546C:  BNC   54A6
....................       rotate_right(stream->Buf, STREAM_BUF_SIZE); 
546E:  MOVLW  1A
5470:  ADDWF  xAA,W
5472:  MOVWF  01
5474:  MOVLW  00
5476:  ADDWFC xAB,W
5478:  MOVWF  03
547A:  MOVFF  01,5AF
547E:  MOVWF  xB0
5480:  MOVLW  20
5482:  MOVWF  00
5484:  MOVFF  03,FEA
5488:  MOVFF  01,FE9
548C:  MOVFF  FEF,03
5490:  MOVLW  1F
5492:  ADDWF  FE9,F
5494:  MOVLW  00
5496:  ADDWFC FEA,F
5498:  RRCF   03,W
549A:  RRCF   FED,F
549C:  DECFSZ 00,F
549E:  BRA    549A
54A0:  MOVLW  01
54A2:  ADDWF  xAE,F
54A4:  BRA    5468
....................  
....................    return GOODEC; 
54A6:  MOVLW  00
54A8:  MOVWF  01
.................... } 
54AA:  MOVLB  0
54AC:  GOTO   5516 (RETURN)
....................  
.................... /* 
.................... signed int write_buffer(FILE* stream, int val) 
.................... Summary: Writes to the buffer. 
.................... Param stream: The stream whose buffer to write to. 
.................... Param val: A variable to write to the buffer. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int write_buffer(FILE* stream, int val) 
.................... { 
....................    // check to see if we should dump the buffer to the card 
....................    if(((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
....................       && (stream->Cur_Char != stream->Start_Addr)) 
*
229A:  MOVLW  04
229C:  MOVLB  6
229E:  ADDWF  x8C,W
22A0:  MOVWF  FE9
22A2:  MOVLW  00
22A4:  ADDWFC x8D,W
22A6:  MOVWF  FEA
22A8:  MOVFF  FEF,68F
22AC:  MOVFF  FEC,690
22B0:  MOVFF  FEC,691
22B4:  MOVFF  FEC,692
22B8:  MOVLW  1F
22BA:  ANDWF  x8F,F
22BC:  CLRF   x90
22BE:  CLRF   x91
22C0:  CLRF   x92
22C2:  MOVF   x8F,F
22C4:  BNZ   239C
22C6:  MOVF   x90,F
22C8:  BNZ   239C
22CA:  MOVF   x91,F
22CC:  BNZ   239C
22CE:  MOVF   x92,F
22D0:  BNZ   239C
22D2:  MOVLW  04
22D4:  ADDWF  x8C,W
22D6:  MOVWF  FE9
22D8:  MOVLW  00
22DA:  ADDWFC x8D,W
22DC:  MOVWF  FEA
22DE:  MOVFF  FEF,68F
22E2:  MOVFF  FEC,690
22E6:  MOVFF  FEC,691
22EA:  MOVFF  FEC,692
22EE:  MOVLW  14
22F0:  ADDWF  x8C,W
22F2:  MOVWF  FE9
22F4:  MOVLW  00
22F6:  ADDWFC x8D,W
22F8:  MOVWF  FEA
22FA:  MOVFF  FEF,00
22FE:  MOVFF  FEC,01
2302:  MOVFF  FEC,02
2306:  MOVFF  FEC,03
230A:  MOVF   00,W
230C:  SUBWF  x8F,W
230E:  BNZ   2322
2310:  MOVF   01,W
2312:  SUBWF  x90,W
2314:  BNZ   2322
2316:  MOVF   02,W
2318:  SUBWF  x91,W
231A:  BNZ   2322
231C:  MOVF   03,W
231E:  SUBWF  x92,W
2320:  BZ    239C
....................    { 
....................       // dump the buffer to the card 
....................       if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
2322:  MOVLW  04
2324:  ADDWF  x8C,W
2326:  MOVWF  FE9
2328:  MOVLW  00
232A:  ADDWFC x8D,W
232C:  MOVWF  FEA
232E:  MOVFF  FEF,68F
2332:  MOVFF  FEC,690
2336:  MOVFF  FEC,691
233A:  MOVFF  FEC,692
233E:  MOVLW  20
2340:  SUBWF  x8F,F
2342:  MOVLW  00
2344:  SUBWFB x90,F
2346:  SUBWFB x91,F
2348:  SUBWFB x92,F
234A:  MOVLW  1A
234C:  ADDWF  x8C,W
234E:  MOVWF  01
2350:  MOVLW  00
2352:  ADDWFC x8D,W
2354:  MOVWF  03
2356:  MOVFF  01,693
235A:  MOVWF  x94
235C:  MOVFF  692,6C8
2360:  MOVFF  691,6C7
2364:  MOVFF  690,6C6
2368:  MOVFF  68F,6C5
236C:  CLRF   xCA
236E:  MOVLW  20
2370:  MOVWF  xC9
2372:  MOVFF  03,6CC
2376:  MOVFF  01,6CB
237A:  MOVLB  0
237C:  RCALL  1EE8
237E:  MOVF   01,F
2380:  BZ    239E
....................       { 
....................          stream->Flags |= Write_Error; 
2382:  MOVLW  19
2384:  MOVLB  6
2386:  ADDWF  x8C,W
2388:  MOVWF  FE9
238A:  MOVLW  00
238C:  ADDWFC x8D,W
238E:  MOVWF  FEA
2390:  MOVF   FEF,W
2392:  IORLW  40
2394:  MOVWF  FEF
....................          return EOF; 
2396:  MOVLW  FF
2398:  MOVWF  01
239A:  BRA    23E6
239C:  MOVLB  0
....................       } 
....................    } 
....................  
....................    // fill up a byte on the buffer 
....................    stream->Buf[stream->Cur_Char % STREAM_BUF_SIZE] = val; 
239E:  MOVLW  04
23A0:  MOVLB  6
23A2:  ADDWF  x8C,W
23A4:  MOVWF  FE9
23A6:  MOVLW  00
23A8:  ADDWFC x8D,W
23AA:  MOVWF  FEA
23AC:  MOVFF  FEF,68F
23B0:  MOVFF  FEC,690
23B4:  MOVFF  FEC,691
23B8:  MOVFF  FEC,692
23BC:  MOVLW  1F
23BE:  ANDWF  x8F,F
23C0:  CLRF   x90
23C2:  CLRF   x91
23C4:  CLRF   x92
23C6:  MOVLW  1A
23C8:  ADDWF  x8F,W
23CA:  MOVWF  01
23CC:  MOVLW  00
23CE:  ADDWFC x90,W
23D0:  MOVWF  03
23D2:  MOVF   01,W
23D4:  ADDWF  x8C,W
23D6:  MOVWF  FE9
23D8:  MOVF   x8D,W
23DA:  ADDWFC 03,W
23DC:  MOVWF  FEA
23DE:  MOVFF  68E,FEF
....................  
....................    return GOODEC; 
23E2:  MOVLW  00
23E4:  MOVWF  01
.................... } 
23E6:  MOVLB  0
23E8:  GOTO   2782 (RETURN)
....................  
.................... /* 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... Summary: This will fill up the unused spots in a standard FAT entry with a value. 
.................... Param the_entry[]: The entry that will be modified. 
.................... Param val: The value to fill the entry with. 
.................... Param start_ind: The beginning index to start filling the_entry. 
.................... Returns: Nothing. 
.................... */ 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = start_ind; i < 13; i += 1) 
*
4632:  MOVFF  62D,62E
4636:  MOVLB  6
4638:  MOVF   x2E,W
463A:  SUBLW  0C
463C:  BNC   46D8
....................    { 
....................       if(i < 5) 
463E:  MOVF   x2E,W
4640:  SUBLW  04
4642:  BNC   4672
....................       { 
....................          the_entry[(i << 1) + 1] = val; 
4644:  BCF    FD8.0
4646:  RLCF   x2E,W
4648:  ADDLW  01
464A:  CLRF   03
464C:  ADDWF  x2A,W
464E:  MOVWF  FE9
4650:  MOVF   x2B,W
4652:  ADDWFC 03,W
4654:  MOVWF  FEA
4656:  MOVFF  62C,FEF
....................          the_entry[(i << 1) + 2] = val; 
465A:  BCF    FD8.0
465C:  RLCF   x2E,W
465E:  ADDLW  02
4660:  CLRF   03
4662:  ADDWF  x2A,W
4664:  MOVWF  FE9
4666:  MOVF   x2B,W
4668:  ADDWFC 03,W
466A:  MOVWF  FEA
466C:  MOVFF  62C,FEF
....................       } 
....................  
....................       else if(i < 11) 
4670:  BRA    46D2
4672:  MOVF   x2E,W
4674:  SUBLW  0A
4676:  BNC   46A6
....................       { 
....................          the_entry[(i << 1) + 4] = val; 
4678:  BCF    FD8.0
467A:  RLCF   x2E,W
467C:  ADDLW  04
467E:  CLRF   03
4680:  ADDWF  x2A,W
4682:  MOVWF  FE9
4684:  MOVF   x2B,W
4686:  ADDWFC 03,W
4688:  MOVWF  FEA
468A:  MOVFF  62C,FEF
....................          the_entry[(i << 1) + 5] = val; 
468E:  BCF    FD8.0
4690:  RLCF   x2E,W
4692:  ADDLW  05
4694:  CLRF   03
4696:  ADDWF  x2A,W
4698:  MOVWF  FE9
469A:  MOVF   x2B,W
469C:  ADDWFC 03,W
469E:  MOVWF  FEA
46A0:  MOVFF  62C,FEF
....................       } 
....................  
....................       else 
46A4:  BRA    46D2
....................       { 
....................          the_entry[(i << 1) + 6] = val; 
46A6:  BCF    FD8.0
46A8:  RLCF   x2E,W
46AA:  ADDLW  06
46AC:  CLRF   03
46AE:  ADDWF  x2A,W
46B0:  MOVWF  FE9
46B2:  MOVF   x2B,W
46B4:  ADDWFC 03,W
46B6:  MOVWF  FEA
46B8:  MOVFF  62C,FEF
....................          the_entry[(i << 1) + 7] = val; 
46BC:  BCF    FD8.0
46BE:  RLCF   x2E,W
46C0:  ADDLW  07
46C2:  CLRF   03
46C4:  ADDWF  x2A,W
46C6:  MOVWF  FE9
46C8:  MOVF   x2B,W
46CA:  ADDWFC 03,W
46CC:  MOVWF  FEA
46CE:  MOVFF  62C,FEF
....................       } 
....................    } 
46D2:  MOVLW  01
46D4:  ADDWF  x2E,F
46D6:  BRA    4638
.................... } 
46D8:  MOVLB  0
46DA:  RETLW  00
....................  
.................... /* 
.................... void disp_timestamp(int16 timestamp) 
.................... Summary: Parses an timestamp from a file entry and displays it to the console 
.................... Param: The 16-bit timestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_timestamp(int16 timestamp) 
.................... { 
....................    // Hours:Minutes:Seconds 
....................    printf("%lu:%lu:%lu", 
....................       timestamp >> 11, 
....................       (timestamp & 0x07E0) >> 5, 
....................       (timestamp & 0x001F) << 1); 
.................... } 
....................  
.................... /* 
.................... void disp_datestamp(int16 datestamp) 
.................... Summary: Parses an datestamp from a file entry and displays it to the console 
.................... Param: The 16-bit datestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_datestamp(int16 datestamp) 
.................... { 
....................    // Month/Day/Year 
....................    printf("%lu/%lu/%lu", 
....................       (datestamp & 0x01F0) >> 5, 
....................       datestamp & 0x001F, 
....................       (1980 + (datestamp >> 9))); 
.................... } 
....................  
.................... /// Data Utility Functions /// 
....................  
.................... /* 
.................... signed int fat_init() 
.................... Summary: Initializes global variables that are essential for this library working 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: This must be called before any other function calls in this library. 
.................... */ 
.................... signed int fat_init() 
.................... { 
*
0F64:  MOVLB  5
0F66:  CLRF   xF0
....................    int ec = 0; 
....................  
....................    int 
....................       FATs, 
....................       Sectors_Per_Cluster; 
....................  
....................    int16 
....................       Bytes_Per_Sector, 
....................       Reserved_Sectors, 
....................       Small_Sectors; 
....................  
....................    int32 
....................       Hidden_Sectors, 
....................       Large_Sectors; 
....................  
.................... #ifdef FAT32 
....................    int32 Sectors_Per_FAT; 
.................... #else // FAT16 
....................    int16 
....................       Root_Entries, 
....................       Sectors_Per_FAT; 
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize the media 
....................    ec += mmcsd_init(); 
0F68:  MOVLB  0
0F6A:  BRA    0A3E
0F6C:  MOVF   01,W
0F6E:  MOVLB  5
0F70:  ADDWF  xF0,F
....................  
....................    // start filling up variables 
....................    ec += mmcsd_read_data(11, 2, &Bytes_Per_Sector); 
0F72:  MOVLB  6
0F74:  CLRF   xAD
0F76:  CLRF   xAC
0F78:  CLRF   xAB
0F7A:  MOVLW  0B
0F7C:  MOVWF  xAA
0F7E:  CLRF   xAF
0F80:  MOVLW  02
0F82:  MOVWF  xAE
0F84:  MOVLW  05
0F86:  MOVWF  xB1
0F88:  MOVLW  F3
0F8A:  MOVWF  xB0
0F8C:  MOVLB  0
0F8E:  RCALL  0DD6
0F90:  MOVF   01,W
0F92:  MOVLB  5
0F94:  ADDWF  xF0,F
....................    ec += mmcsd_read_data(13, 1, &Sectors_Per_Cluster); 
0F96:  MOVLB  6
0F98:  CLRF   xAD
0F9A:  CLRF   xAC
0F9C:  CLRF   xAB
0F9E:  MOVLW  0D
0FA0:  MOVWF  xAA
0FA2:  CLRF   xAF
0FA4:  MOVLW  01
0FA6:  MOVWF  xAE
0FA8:  MOVLW  05
0FAA:  MOVWF  xB1
0FAC:  MOVLW  F2
0FAE:  MOVWF  xB0
0FB0:  MOVLB  0
0FB2:  RCALL  0DD6
0FB4:  MOVF   01,W
0FB6:  MOVLB  5
0FB8:  ADDWF  xF0,F
....................    ec += mmcsd_read_data(14, 2, &Reserved_Sectors); 
0FBA:  MOVLB  6
0FBC:  CLRF   xAD
0FBE:  CLRF   xAC
0FC0:  CLRF   xAB
0FC2:  MOVLW  0E
0FC4:  MOVWF  xAA
0FC6:  CLRF   xAF
0FC8:  MOVLW  02
0FCA:  MOVWF  xAE
0FCC:  MOVLW  05
0FCE:  MOVWF  xB1
0FD0:  MOVLW  F5
0FD2:  MOVWF  xB0
0FD4:  MOVLB  0
0FD6:  RCALL  0DD6
0FD8:  MOVF   01,W
0FDA:  MOVLB  5
0FDC:  ADDWF  xF0,F
....................    ec += mmcsd_read_data(16, 1, &FATs); 
0FDE:  MOVLB  6
0FE0:  CLRF   xAD
0FE2:  CLRF   xAC
0FE4:  CLRF   xAB
0FE6:  MOVLW  10
0FE8:  MOVWF  xAA
0FEA:  CLRF   xAF
0FEC:  MOVLW  01
0FEE:  MOVWF  xAE
0FF0:  MOVLW  05
0FF2:  MOVWF  xB1
0FF4:  MOVLW  F1
0FF6:  MOVWF  xB0
0FF8:  MOVLB  0
0FFA:  RCALL  0DD6
0FFC:  MOVF   01,W
0FFE:  MOVLB  5
1000:  ADDWF  xF0,F
.................... #ifdef FAT16 
....................    ec += mmcsd_read_data(17, 2, &Root_Entries); 
1002:  MOVLB  6
1004:  CLRF   xAD
1006:  CLRF   xAC
1008:  CLRF   xAB
100A:  MOVLW  11
100C:  MOVWF  xAA
100E:  CLRF   xAF
1010:  MOVLW  02
1012:  MOVWF  xAE
1014:  MOVLW  06
1016:  MOVWF  xB1
1018:  MOVLW  01
101A:  MOVWF  xB0
101C:  MOVLB  0
101E:  RCALL  0DD6
1020:  MOVF   01,W
1022:  MOVLB  5
1024:  ADDWF  xF0,F
.................... #endif // #ifdef FAT16 
....................    ec += mmcsd_read_data(19, 2, &Small_Sectors); 
1026:  MOVLB  6
1028:  CLRF   xAD
102A:  CLRF   xAC
102C:  CLRF   xAB
102E:  MOVLW  13
1030:  MOVWF  xAA
1032:  CLRF   xAF
1034:  MOVLW  02
1036:  MOVWF  xAE
1038:  MOVLW  05
103A:  MOVWF  xB1
103C:  MOVLW  F7
103E:  MOVWF  xB0
1040:  MOVLB  0
1042:  RCALL  0DD6
1044:  MOVF   01,W
1046:  MOVLB  5
1048:  ADDWF  xF0,F
.................... #ifdef FAT32 
....................    ec += mmcsd_read_data(36, 4, &Sectors_Per_FAT); 
.................... #else // FAT16 
....................    ec += mmcsd_read_data(22, 2, &Sectors_Per_FAT); 
104A:  MOVLB  6
104C:  CLRF   xAD
104E:  CLRF   xAC
1050:  CLRF   xAB
1052:  MOVLW  16
1054:  MOVWF  xAA
1056:  CLRF   xAF
1058:  MOVLW  02
105A:  MOVWF  xAE
105C:  MOVLW  06
105E:  MOVWF  xB1
1060:  MOVLW  03
1062:  MOVWF  xB0
1064:  MOVLB  0
1066:  RCALL  0DD6
1068:  MOVF   01,W
106A:  MOVLB  5
106C:  ADDWF  xF0,F
.................... #endif // #ifdef FAT32 
....................    ec += mmcsd_read_data(28, 4, &Hidden_Sectors); 
106E:  MOVLB  6
1070:  CLRF   xAD
1072:  CLRF   xAC
1074:  CLRF   xAB
1076:  MOVLW  1C
1078:  MOVWF  xAA
107A:  CLRF   xAF
107C:  MOVLW  04
107E:  MOVWF  xAE
1080:  MOVLW  05
1082:  MOVWF  xB1
1084:  MOVLW  F9
1086:  MOVWF  xB0
1088:  MOVLB  0
108A:  RCALL  0DD6
108C:  MOVF   01,W
108E:  MOVLB  5
1090:  ADDWF  xF0,F
....................    ec += mmcsd_read_data(32, 4, &Large_Sectors); 
1092:  MOVLB  6
1094:  CLRF   xAD
1096:  CLRF   xAC
1098:  CLRF   xAB
109A:  MOVLW  20
109C:  MOVWF  xAA
109E:  CLRF   xAF
10A0:  MOVLW  04
10A2:  MOVWF  xAE
10A4:  MOVLW  05
10A6:  MOVWF  xB1
10A8:  MOVLW  FD
10AA:  MOVWF  xB0
10AC:  MOVLB  0
10AE:  RCALL  0DD6
10B0:  MOVF   01,W
10B2:  MOVLB  5
10B4:  ADDWF  xF0,F
.................... #ifdef FAT16 
....................    Next_Free_Clust = 2; 
10B6:  MOVLB  2
10B8:  CLRF   x23
10BA:  CLRF   x22
10BC:  CLRF   x21
10BE:  MOVLW  02
10C0:  MOVWF  x20
.................... #else 
....................    ec += mmcsd_read_data(0x3EC, 4, &Next_Free_Clust); 
.................... #endif 
....................    if(ec != GOODEC) 
10C2:  MOVLB  5
10C4:  MOVF   xF0,F
10C6:  BZ    10CE
....................       return EOF; 
10C8:  MOVLW  FF
10CA:  MOVWF  01
10CC:  BRA    126E
....................  
....................    // figure out the size of a cluster 
....................    Bytes_Per_Cluster = Sectors_Per_Cluster * Bytes_Per_Sector; 
10CE:  MOVLB  6
10D0:  CLRF   x06
10D2:  MOVFF  5F2,605
10D6:  MOVFF  5F4,608
10DA:  MOVFF  5F3,607
10DE:  MOVLB  0
10E0:  RCALL  0E66
10E2:  MOVFF  02,215
10E6:  MOVFF  01,214
....................  
....................    // figure out how long one FAT is 
....................    FAT_Length = Sectors_Per_FAT * (int32)Bytes_Per_Sector; 
10EA:  MOVFF  5F3,00
10EE:  MOVFF  5F4,01
10F2:  CLRF   02
10F4:  CLRF   03
10F6:  MOVFF  03,608
10FA:  MOVFF  02,607
10FE:  MOVFF  5F4,606
1102:  MOVFF  5F3,605
1106:  MOVLB  6
1108:  CLRF   xCC
110A:  CLRF   xCB
110C:  MOVFF  604,6CA
1110:  MOVFF  603,6C9
1114:  MOVFF  03,6D0
1118:  MOVFF  02,6CF
111C:  MOVFF  5F4,6CE
1120:  MOVFF  5F3,6CD
1124:  MOVLB  0
1126:  RCALL  0E88
1128:  MOVFF  03,21F
112C:  MOVFF  02,21E
1130:  MOVFF  01,21D
1134:  MOVFF  00,21C
....................  
....................    // figure out where the FAT starts 
....................    FAT_Start = Reserved_Sectors * Bytes_Per_Sector; 
1138:  MOVFF  5F6,606
113C:  MOVFF  5F5,605
1140:  MOVFF  5F4,608
1144:  MOVFF  5F3,607
1148:  RCALL  0E66
114A:  MOVFF  02,217
114E:  MOVFF  01,216
....................  
....................    // figure out where the root directory starts 
....................    Root_Dir = FAT_Start + (FATs * FAT_Length); 
1152:  MOVLB  6
1154:  CLRF   xCC
1156:  CLRF   xCB
1158:  CLRF   xCA
115A:  MOVFF  5F1,6C9
115E:  MOVFF  21F,6D0
1162:  MOVFF  21E,6CF
1166:  MOVFF  21D,6CE
116A:  MOVFF  21C,6CD
116E:  MOVLB  0
1170:  RCALL  0E88
1172:  MOVF   00,W
1174:  MOVLB  2
1176:  ADDWF  x16,W
1178:  MOVWF  x24
117A:  MOVF   01,W
117C:  ADDWFC x17,W
117E:  MOVWF  x25
1180:  MOVLW  00
1182:  ADDWFC 02,W
1184:  MOVWF  x26
1186:  MOVLW  00
1188:  ADDWFC 03,W
118A:  MOVWF  x27
....................  
....................    // figure out where data for files in the root directory starts 
.................... #ifdef FAT32 
....................    Data_Start = Root_Dir; 
.................... #else // FAT16 
....................    Data_Start = (Root_Entries * 0x20) + (Bytes_Per_Sector - 1); 
118C:  MOVLB  6
118E:  RLCF   x01,W
1190:  MOVWF  x05
1192:  RLCF   x02,W
1194:  MOVWF  x06
1196:  RLCF   x05,F
1198:  RLCF   x06,F
119A:  RLCF   x05,F
119C:  RLCF   x06,F
119E:  RLCF   x05,F
11A0:  RLCF   x06,F
11A2:  RLCF   x05,F
11A4:  RLCF   x06,F
11A6:  MOVLW  E0
11A8:  ANDWF  x05,F
11AA:  MOVLW  01
11AC:  MOVLB  5
11AE:  SUBWF  xF3,W
11B0:  MOVWF  00
11B2:  MOVLW  00
11B4:  SUBWFB xF4,W
11B6:  MOVWF  03
11B8:  MOVF   00,W
11BA:  MOVLB  6
11BC:  ADDWF  x05,W
11BE:  MOVLB  2
11C0:  MOVWF  x18
11C2:  MOVF   03,W
11C4:  MOVLB  6
11C6:  ADDWFC x06,W
11C8:  MOVLB  2
11CA:  MOVWF  x19
11CC:  CLRF   x1A
11CE:  CLRF   x1B
....................    Data_Start /= Bytes_Per_Sector; 
11D0:  MOVFF  21B,6A5
11D4:  MOVFF  21A,6A4
11D8:  MOVFF  219,6A3
11DC:  MOVFF  218,6A2
11E0:  MOVLB  6
11E2:  CLRF   xA9
11E4:  CLRF   xA8
11E6:  MOVFF  5F4,6A7
11EA:  MOVFF  5F3,6A6
11EE:  MOVLB  0
11F0:  RCALL  0EE4
11F2:  MOVFF  03,21B
11F6:  MOVFF  02,21A
11FA:  MOVFF  01,219
11FE:  MOVFF  00,218
....................    Data_Start += Reserved_Sectors + (FATs * Sectors_Per_FAT); 
1202:  MOVLB  6
1204:  CLRF   x06
1206:  MOVFF  5F1,605
120A:  MOVFF  604,608
120E:  MOVFF  603,607
1212:  MOVLB  0
1214:  RCALL  0E66
1216:  MOVFF  02,03
121A:  MOVF   01,W
121C:  MOVLB  5
121E:  ADDWF  xF5,W
1220:  MOVWF  01
1222:  MOVF   xF6,W
1224:  ADDWFC 03,F
1226:  MOVF   01,W
1228:  MOVLB  2
122A:  ADDWF  x18,F
122C:  MOVF   03,W
122E:  ADDWFC x19,F
1230:  MOVLW  00
1232:  ADDWFC x1A,F
1234:  ADDWFC x1B,F
....................    Data_Start *= Bytes_Per_Sector; 
1236:  MOVFF  21B,6CC
123A:  MOVFF  21A,6CB
123E:  MOVFF  219,6CA
1242:  MOVFF  218,6C9
1246:  MOVLB  6
1248:  CLRF   xD0
124A:  CLRF   xCF
124C:  MOVFF  5F4,6CE
1250:  MOVFF  5F3,6CD
1254:  MOVLB  0
1256:  RCALL  0E88
1258:  MOVFF  03,21B
125C:  MOVFF  02,21A
1260:  MOVFF  01,219
1264:  MOVFF  00,218
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
1268:  MOVLW  00
126A:  MOVWF  01
126C:  MOVLB  5
.................... } 
126E:  MOVLB  0
1270:  RETLW  00
....................  
.................... /* 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... Summary: Gets the next linked cluster from the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the next linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
....................    // convert the current cluster into the address of where information about 
....................    //  the cluster is stored in the FAT, and put this value into the current cluster 
.................... #ifdef FAT32 
....................    if(mmcsd_read_data((*my_cluster << 2) + FAT_Start, 4, my_cluster) != GOODEC) 
....................       return EOF; 
.................... #else // FAT16 
....................    if(mmcsd_read_data((*my_cluster << 1) + FAT_Start, 2, my_cluster) != GOODEC) 
*
1E3C:  MOVFF  697,03
1E40:  MOVLB  6
1E42:  MOVFF  696,FE9
1E46:  MOVFF  697,FEA
1E4A:  MOVFF  FEC,699
1E4E:  MOVF   FED,F
1E50:  MOVFF  FEF,698
1E54:  BCF    FD8.0
1E56:  RLCF   x98,F
1E58:  RLCF   x99,F
1E5A:  MOVLB  2
1E5C:  MOVF   x16,W
1E5E:  MOVLB  6
1E60:  ADDWF  x98,F
1E62:  MOVLB  2
1E64:  MOVF   x17,W
1E66:  MOVLB  6
1E68:  ADDWFC x99,F
1E6A:  CLRF   xAD
1E6C:  CLRF   xAC
1E6E:  MOVFF  699,6AB
1E72:  MOVFF  698,6AA
1E76:  CLRF   xAF
1E78:  MOVLW  02
1E7A:  MOVWF  xAE
1E7C:  MOVFF  697,6B1
1E80:  MOVFF  696,6B0
1E84:  MOVLB  0
1E86:  CALL   0DD6
1E8A:  MOVF   01,F
1E8C:  BZ    1E94
....................       return EOF; 
1E8E:  MOVLW  FF
1E90:  MOVWF  01
1E92:  BRA    1E98
.................... #endif // #ifdef FAT32 
....................    return GOODEC; 
1E94:  MOVLW  00
1E96:  MOVWF  01
.................... } 
1E98:  RETLW  00
....................  
.................... /* 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... Summary: Gets the previously linked cluster in the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the previous linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_prev_cluster(int16* my_cluster) 
.................... #endif // #ifdef FAT32 
.................... { 
*
1948:  MOVLB  6
194A:  CLRF   x9C
194C:  MOVLW  01
194E:  MOVWF  x9B
1950:  CLRF   x9E
1952:  CLRF   x9D
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #else 
....................    int16 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #endif // #ifdef FAT32 
....................     
....................    while(target_cluster != *my_cluster) 
....................    {    
1954:  MOVFF  699,FE9
1958:  MOVFF  69A,FEA
195C:  MOVFF  FEC,03
1960:  MOVF   FED,F
1962:  MOVF   FEF,W
1964:  SUBWF  x9D,W
1966:  BNZ   196E
1968:  MOVF   03,W
196A:  SUBWF  x9E,W
196C:  BZ    19BE
....................       cur_cluster += 1; 
196E:  MOVLW  01
1970:  ADDWF  x9B,F
1972:  MOVLW  00
1974:  ADDWFC x9C,F
.................... #ifdef FAT32 
....................       if(mmcsd_read_data((cur_cluster << 2) + FAT_Start, 4, &target_cluster) != GOODEC) 
....................          return EOF; 
.................... #else // FAT16 
....................       if(mmcsd_read_data((cur_cluster << 1) + FAT_Start, 2, &target_cluster) != GOODEC) 
1976:  BCF    FD8.0
1978:  RLCF   x9B,W
197A:  MOVWF  xA0
197C:  RLCF   x9C,W
197E:  MOVWF  xA1
1980:  MOVLB  2
1982:  MOVF   x16,W
1984:  MOVLB  6
1986:  ADDWF  xA0,F
1988:  MOVLB  2
198A:  MOVF   x17,W
198C:  MOVLB  6
198E:  ADDWFC xA1,F
1990:  CLRF   xAD
1992:  CLRF   xAC
1994:  MOVFF  6A1,6AB
1998:  MOVFF  6A0,6AA
199C:  CLRF   xAF
199E:  MOVLW  02
19A0:  MOVWF  xAE
19A2:  MOVLW  06
19A4:  MOVWF  xB1
19A6:  MOVLW  9D
19A8:  MOVWF  xB0
19AA:  MOVLB  0
19AC:  CALL   0DD6
19B0:  MOVF   01,F
19B2:  BZ    19BA
....................          return EOF; 
19B4:  MOVLW  FF
19B6:  MOVWF  01
19B8:  BRA    19D4
.................... #endif // #ifdef FAT32 
....................    } 
19BA:  MOVLB  6
19BC:  BRA    1954
....................     
.................... #ifdef FAT32 
....................    *my_cluster = cur_cluster;                         
.................... #else // FAT16 
....................    *my_cluster = cur_cluster; 
19BE:  MOVFF  699,FE9
19C2:  MOVFF  69A,FEA
19C6:  MOVFF  69C,FEC
19CA:  MOVF   FED,F
19CC:  MOVFF  69B,FEF
.................... #endif // #ifdef FAT32    
....................     
....................    return GOODEC; 
19D0:  MOVLW  00
19D2:  MOVWF  01
19D4:  MOVLB  0
.................... } 
19D6:  GOTO   1B68 (RETURN)
....................  
.................... /* 
.................... signed int get_next_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_addr(int32* my_addr) 
.................... { 
.................... 	int32 temp; 
.................... #ifdef FAT32 
.................... 	int32 c; 
.................... #else 
.................... 	int16 c; 
.................... #endif 
.................... 	// check to make sure that the next iteration will give us a contiguous address  
.................... 	temp = *my_addr + 1; 
*
23EC:  MOVLB  6
23EE:  MOVFF  68E,FE9
23F2:  MOVFF  68F,FEA
23F6:  MOVFF  FEF,696
23FA:  MOVFF  FEC,697
23FE:  MOVFF  FEC,698
2402:  MOVFF  FEC,699
2406:  MOVLW  01
2408:  ADDWF  x96,W
240A:  MOVWF  x90
240C:  MOVLW  00
240E:  ADDWFC x97,W
2410:  MOVWF  x91
2412:  MOVLW  00
2414:  ADDWFC x98,W
2416:  MOVWF  x92
2418:  MOVLW  00
241A:  ADDWFC x99,W
241C:  MOVWF  x93
.................... 	if((temp > Data_Start) && ((temp - Data_Start) % Bytes_Per_Cluster == 0)) 
241E:  MOVLB  2
2420:  MOVF   x1B,W
2422:  MOVLB  6
2424:  SUBWF  x93,W
2426:  BTFSS  FD8.0
2428:  BRA    2548
242A:  BNZ   2456
242C:  MOVLB  2
242E:  MOVF   x1A,W
2430:  MOVLB  6
2432:  SUBWF  x92,W
2434:  BTFSS  FD8.0
2436:  BRA    2548
2438:  BNZ   2456
243A:  MOVLB  2
243C:  MOVF   x19,W
243E:  MOVLB  6
2440:  SUBWF  x91,W
2442:  BTFSS  FD8.0
2444:  BRA    2548
2446:  BNZ   2456
2448:  MOVF   x90,W
244A:  MOVLB  2
244C:  SUBWF  x18,W
244E:  BTFSS  FD8.0
2450:  BRA    2456
2452:  MOVLB  6
2454:  BRA    2548
2456:  MOVLB  2
2458:  MOVF   x18,W
245A:  MOVLB  6
245C:  SUBWF  x90,W
245E:  MOVWF  x96
2460:  MOVLB  2
2462:  MOVF   x19,W
2464:  MOVLB  6
2466:  SUBWFB x91,W
2468:  MOVWF  x97
246A:  MOVLB  2
246C:  MOVF   x1A,W
246E:  MOVLB  6
2470:  SUBWFB x92,W
2472:  MOVWF  x98
2474:  MOVLB  2
2476:  MOVF   x1B,W
2478:  MOVLB  6
247A:  SUBWFB x93,W
247C:  MOVWF  x99
247E:  MOVWF  xA5
2480:  MOVFF  698,6A4
2484:  MOVFF  697,6A3
2488:  MOVFF  696,6A2
248C:  CLRF   xA9
248E:  CLRF   xA8
2490:  MOVFF  215,6A7
2494:  MOVFF  214,6A6
2498:  MOVLB  0
249A:  CALL   0EE4
249E:  MOVFF  FEF,696
24A2:  MOVFF  FEC,697
24A6:  MOVFF  FEC,698
24AA:  MOVFF  FEC,699
24AE:  MOVLB  6
24B0:  MOVF   x96,F
24B2:  BNZ   2548
24B4:  MOVF   x97,F
24B6:  BNZ   2548
24B8:  MOVF   x98,F
24BA:  BNZ   2548
24BC:  MOVF   x99,F
24BE:  BNZ   2548
.................... 	{ 
.................... 		// convert the current address into the address of where information about  
.................... 		//  the address is stored in the FAT, and put this value into the current address  
.................... 		c = addr_to_cluster(temp - 1); 
24C0:  MOVLW  01
24C2:  SUBWF  x90,W
24C4:  MOVWF  x96
24C6:  MOVLW  00
24C8:  SUBWFB x91,W
24CA:  MOVWF  x97
24CC:  MOVLW  00
24CE:  SUBWFB x92,W
24D0:  MOVWF  x98
24D2:  MOVLW  00
24D4:  SUBWFB x93,W
24D6:  MOVWF  x99
24D8:  MOVWF  x9D
24DA:  MOVFF  698,69C
24DE:  MOVFF  697,69B
24E2:  MOVFF  696,69A
24E6:  MOVLB  0
24E8:  CALL   188E
24EC:  MOVFF  02,695
24F0:  MOVFF  01,694
.................... 		if(get_next_cluster(&c) == EOF) 
24F4:  MOVLW  06
24F6:  MOVLB  6
24F8:  MOVWF  x97
24FA:  MOVLW  94
24FC:  MOVWF  x96
24FE:  MOVLB  0
2500:  RCALL  1E3C
2502:  MOVF   01,W
2504:  SUBLW  FF
2506:  BNZ   250E
.................... 			return EOF; 
2508:  MOVLW  FF
250A:  MOVWF  01
250C:  BRA    2564
.................... 		if (c >= 
.................... 			#ifdef FAT32 
.................... 				0x0FFFFFF8 
.................... 			#else 
.................... 				0xFFF8 
.................... 			#endif 
.................... 		) 
250E:  MOVLB  6
2510:  MOVF   x95,W
2512:  SUBLW  FE
2514:  BC    2528
2516:  XORLW  FF
2518:  BNZ   2520
251A:  MOVF   x94,W
251C:  SUBLW  F7
251E:  BC    2528
.................... 			return EOF; 
2520:  MOVLW  FF
2522:  MOVWF  01
2524:  MOVLB  0
2526:  BRA    2564
.................... 		temp = cluster_to_addr(c); 
2528:  MOVFF  695,6C2
252C:  MOVFF  694,6C1
2530:  MOVLB  0
2532:  CALL   19DA
2536:  MOVFF  03,693
253A:  MOVFF  02,692
253E:  MOVFF  01,691
2542:  MOVFF  00,690
2546:  MOVLB  6
.................... 	} 
.................... 	*my_addr = temp; 
2548:  MOVFF  68E,FE9
254C:  MOVFF  68F,FEA
2550:  MOVFF  690,FEF
2554:  MOVFF  691,FEC
2558:  MOVFF  692,FEC
255C:  MOVFF  693,FEC
.................... 	return GOODEC; 
2560:  MOVLW  00
2562:  MOVWF  01
2564:  MOVLB  0
.................... } 
2566:  RETLW  00
....................  
.................... /* 
.................... signed int get_prev_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_addr(int32* my_addr) 
.................... { 
.................... 	int32 temp; 
.................... #ifdef FAT32 
.................... 	int32 c; 
.................... #else 
.................... 	int16 c; 
.................... #endif 
.................... 	temp = *my_addr; 
*
1A46:  MOVLB  6
1A48:  MOVFF  691,FE9
1A4C:  MOVFF  692,FEA
1A50:  MOVFF  FEF,00
1A54:  MOVFF  FEC,01
1A58:  MOVFF  FEC,02
1A5C:  MOVFF  FEC,03
1A60:  MOVFF  03,696
1A64:  MOVFF  02,695
1A68:  MOVFF  01,694
1A6C:  MOVFF  00,693
.................... 	// if we're trying to go backwards one entry from the beginning of the root,  
.................... 	//  we won't be able to...  
.................... 	if(temp <= Root_Dir) 
1A70:  MOVF   x96,W
1A72:  MOVLB  2
1A74:  SUBWF  x27,W
1A76:  BNC   1AA2
1A78:  BNZ   1A9C
1A7A:  MOVLB  6
1A7C:  MOVF   x95,W
1A7E:  MOVLB  2
1A80:  SUBWF  x26,W
1A82:  BNC   1AA2
1A84:  BNZ   1A9C
1A86:  MOVLB  6
1A88:  MOVF   x94,W
1A8A:  MOVLB  2
1A8C:  SUBWF  x25,W
1A8E:  BNC   1AA2
1A90:  BNZ   1A9C
1A92:  MOVLB  6
1A94:  MOVF   x93,W
1A96:  MOVLB  2
1A98:  SUBWF  x24,W
1A9A:  BNC   1AA2
.................... 		return GOODEC; 
1A9C:  MOVLW  00
1A9E:  MOVWF  01
1AA0:  BRA    1BD4
.................... 	// check to make sure that the next iteration will give us a contiguous address  
.................... 	if((temp >= Data_Start) && ((temp - Data_Start) % Bytes_Per_Cluster == 0)) 
1AA2:  MOVF   x1B,W
1AA4:  MOVLB  6
1AA6:  SUBWF  x96,W
1AA8:  BTFSS  FD8.0
1AAA:  BRA    1BA2
1AAC:  BNZ   1AD4
1AAE:  MOVLB  2
1AB0:  MOVF   x1A,W
1AB2:  MOVLB  6
1AB4:  SUBWF  x95,W
1AB6:  BTFSS  FD8.0
1AB8:  BRA    1BA2
1ABA:  BNZ   1AD4
1ABC:  MOVLB  2
1ABE:  MOVF   x19,W
1AC0:  MOVLB  6
1AC2:  SUBWF  x94,W
1AC4:  BTFSS  FD8.0
1AC6:  BRA    1BA2
1AC8:  BNZ   1AD4
1ACA:  MOVLB  2
1ACC:  MOVF   x18,W
1ACE:  MOVLB  6
1AD0:  SUBWF  x93,W
1AD2:  BNC   1BA2
1AD4:  MOVLB  2
1AD6:  MOVF   x18,W
1AD8:  MOVLB  6
1ADA:  SUBWF  x93,W
1ADC:  MOVWF  x99
1ADE:  MOVLB  2
1AE0:  MOVF   x19,W
1AE2:  MOVLB  6
1AE4:  SUBWFB x94,W
1AE6:  MOVWF  x9A
1AE8:  MOVLB  2
1AEA:  MOVF   x1A,W
1AEC:  MOVLB  6
1AEE:  SUBWFB x95,W
1AF0:  MOVWF  x9B
1AF2:  MOVLB  2
1AF4:  MOVF   x1B,W
1AF6:  MOVLB  6
1AF8:  SUBWFB x96,W
1AFA:  MOVWF  x9C
1AFC:  MOVWF  xA5
1AFE:  MOVFF  69B,6A4
1B02:  MOVFF  69A,6A3
1B06:  MOVFF  699,6A2
1B0A:  CLRF   xA9
1B0C:  CLRF   xA8
1B0E:  MOVFF  215,6A7
1B12:  MOVFF  214,6A6
1B16:  MOVLB  0
1B18:  CALL   0EE4
1B1C:  MOVFF  FEF,699
1B20:  MOVFF  FEC,69A
1B24:  MOVFF  FEC,69B
1B28:  MOVFF  FEC,69C
1B2C:  MOVLB  6
1B2E:  MOVF   x99,F
1B30:  BNZ   1BA2
1B32:  MOVF   x9A,F
1B34:  BNZ   1BA2
1B36:  MOVF   x9B,F
1B38:  BNZ   1BA2
1B3A:  MOVF   x9C,F
1B3C:  BNZ   1BA2
.................... 	{ 
.................... 		c = addr_to_cluster(temp); 
1B3E:  MOVFF  696,69D
1B42:  MOVFF  695,69C
1B46:  MOVFF  694,69B
1B4A:  MOVFF  693,69A
1B4E:  MOVLB  0
1B50:  RCALL  188E
1B52:  MOVFF  02,698
1B56:  MOVFF  01,697
.................... 		if(get_prev_cluster(&c) == EOF) 
1B5A:  MOVLW  06
1B5C:  MOVLB  6
1B5E:  MOVWF  x9A
1B60:  MOVLW  97
1B62:  MOVWF  x99
1B64:  MOVLB  0
1B66:  BRA    1948
1B68:  MOVF   01,W
1B6A:  SUBLW  FF
1B6C:  BNZ   1B78
.................... 			return EOF; 
1B6E:  MOVLW  FF
1B70:  MOVWF  01
1B72:  MOVLB  2
1B74:  BRA    1BD4
1B76:  MOVLB  0
.................... 		temp = cluster_to_addr(c) + Bytes_Per_Cluster; 
1B78:  MOVFF  698,6C2
1B7C:  MOVFF  697,6C1
1B80:  RCALL  19DA
1B82:  MOVLB  2
1B84:  MOVF   x14,W
1B86:  MOVLB  6
1B88:  ADDWF  00,W
1B8A:  MOVWF  x93
1B8C:  MOVLB  2
1B8E:  MOVF   x15,W
1B90:  MOVLB  6
1B92:  ADDWFC 01,W
1B94:  MOVWF  x94
1B96:  MOVLW  00
1B98:  ADDWFC 02,W
1B9A:  MOVWF  x95
1B9C:  MOVLW  00
1B9E:  ADDWFC 03,W
1BA0:  MOVWF  x96
.................... 	} 
.................... 	*my_addr = temp - 1; 
1BA2:  MOVFF  691,FE9
1BA6:  MOVFF  692,FEA
1BAA:  MOVLW  01
1BAC:  SUBWF  x93,W
1BAE:  MOVWF  00
1BB0:  MOVLW  00
1BB2:  SUBWFB x94,W
1BB4:  MOVWF  01
1BB6:  MOVLW  00
1BB8:  SUBWFB x95,W
1BBA:  MOVWF  02
1BBC:  MOVLW  00
1BBE:  SUBWFB x96,W
1BC0:  MOVFF  00,FEF
1BC4:  MOVFF  01,FEC
1BC8:  MOVFF  02,FEC
1BCC:  MOVWF  FEC
.................... 	return GOODEC; 
1BCE:  MOVLW  00
1BD0:  MOVWF  01
1BD2:  MOVLB  2
.................... } 
1BD4:  MOVLB  0
1BD6:  GOTO   1C1C (RETURN)
....................  
.................... /* 
.................... int32 cluster_to_addr(int32 cluster) 
.................... Summary: Converts a cluster number to an address. 
.................... Param: The cluster to convert. 
.................... Returns: The cluster's address. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 cluster_to_addr(int32 cluster) 
.................... { 
....................    // in unit math: 
....................    //  return  Bytes+(Bytes  /  Cluster * (Clusters - Clusters)) 
....................    return Root_Dir + (Bytes_Per_Cluster * (cluster - 2)); 
.................... } 
.................... #else 
.................... int32 cluster_to_addr(int16 cluster) 
.................... { 
....................    if(cluster < 2) 
*
19DA:  MOVLB  6
19DC:  MOVF   xC2,F
19DE:  BNZ   19F0
19E0:  MOVF   xC1,W
19E2:  SUBLW  01
19E4:  BNC   19F0
....................       return 0; 
19E6:  CLRF   00
19E8:  CLRF   01
19EA:  CLRF   02
19EC:  CLRF   03
19EE:  BRA    1A42
....................    // in unit math: 
....................    //  return  Bytes + (       Bytes  /  Cluster * (Clusters- Clusters)) 
....................    return Data_Start + ((int32)Bytes_Per_Cluster * (cluster - 2)); 
19F0:  CLRF   xC6
19F2:  CLRF   xC5
19F4:  MOVFF  215,6C4
19F8:  MOVFF  214,6C3
19FC:  MOVLW  02
19FE:  SUBWF  xC1,W
1A00:  MOVWF  00
1A02:  MOVLW  00
1A04:  SUBWFB xC2,W
1A06:  MOVWF  03
1A08:  MOVFF  00,6C7
1A0C:  MOVWF  xC8
1A0E:  MOVFF  6C6,6CC
1A12:  MOVFF  6C5,6CB
1A16:  MOVFF  215,6CA
1A1A:  MOVFF  214,6C9
1A1E:  CLRF   xD0
1A20:  CLRF   xCF
1A22:  MOVWF  xCE
1A24:  MOVFF  00,6CD
1A28:  MOVLB  0
1A2A:  CALL   0E88
1A2E:  MOVLB  2
1A30:  MOVF   x18,W
1A32:  ADDWF  00,F
1A34:  MOVF   x19,W
1A36:  ADDWFC 01,F
1A38:  MOVF   x1A,W
1A3A:  ADDWFC 02,F
1A3C:  MOVF   x1B,W
1A3E:  ADDWFC 03,F
1A40:  MOVLB  6
.................... } 
1A42:  MOVLB  0
1A44:  RETLW  00
.................... #endif 
....................  
.................... /* 
.................... int32 addr_to_cluster(int32 addr) 
.................... Summary: Converts an address to a cluster number. 
.................... Param: The address to convert. 
.................... Returns: The address's cluster. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 addr_to_cluster(int32 addr) 
.................... { 
....................    // in unit math: 
....................    //  return (Bytes -Bytes) / Bytes  /  Cluster) + Clusters 
....................    return ((addr - Root_Dir) / Bytes_Per_Cluster) + 2; 
.................... } 
.................... #else 
.................... int16 addr_to_cluster(int32 addr) 
.................... { 
....................    if(addr < Data_Start) 
*
188E:  MOVLB  6
1890:  MOVF   x9D,W
1892:  MOVLB  2
1894:  SUBWF  x1B,W
1896:  BNC   18CA
1898:  BNZ   18C2
189A:  MOVLB  6
189C:  MOVF   x9C,W
189E:  MOVLB  2
18A0:  SUBWF  x1A,W
18A2:  BNC   18CA
18A4:  BNZ   18C2
18A6:  MOVLB  6
18A8:  MOVF   x9B,W
18AA:  MOVLB  2
18AC:  SUBWF  x19,W
18AE:  BNC   18CA
18B0:  BNZ   18C2
18B2:  MOVF   x18,W
18B4:  MOVLB  6
18B6:  SUBWF  x9A,W
18B8:  BTFSS  FD8.0
18BA:  BRA    18C0
18BC:  MOVLB  2
18BE:  BRA    18CA
18C0:  MOVLB  2
....................       return 0; 
18C2:  MOVLW  00
18C4:  MOVWF  01
18C6:  MOVWF  02
18C8:  BRA    1944
....................    // in unit math: 
....................    //  return (Bytes -Bytes)   /(Bytes  /  Cluster) + Clusters 
....................    return ((addr - Data_Start) / Bytes_Per_Cluster) + 2; 
18CA:  MOVF   x18,W
18CC:  MOVLB  6
18CE:  SUBWF  x9A,W
18D0:  MOVWF  x9E
18D2:  MOVLB  2
18D4:  MOVF   x19,W
18D6:  MOVLB  6
18D8:  SUBWFB x9B,W
18DA:  MOVWF  x9F
18DC:  MOVLB  2
18DE:  MOVF   x1A,W
18E0:  MOVLB  6
18E2:  SUBWFB x9C,W
18E4:  MOVWF  xA0
18E6:  MOVLB  2
18E8:  MOVF   x1B,W
18EA:  MOVLB  6
18EC:  SUBWFB x9D,W
18EE:  MOVWF  xA1
18F0:  MOVWF  xA5
18F2:  MOVFF  6A0,6A4
18F6:  MOVFF  69F,6A3
18FA:  MOVFF  69E,6A2
18FE:  CLRF   xA9
1900:  CLRF   xA8
1902:  MOVFF  215,6A7
1906:  MOVFF  214,6A6
190A:  MOVLB  0
190C:  CALL   0EE4
1910:  MOVFF  03,6A1
1914:  MOVFF  02,6A0
1918:  MOVFF  01,69F
191C:  MOVFF  00,69E
1920:  MOVLW  02
1922:  MOVLB  6
1924:  ADDWF  00,W
1926:  MOVWF  00
1928:  MOVLW  00
192A:  ADDWFC 01,W
192C:  MOVWF  01
192E:  MOVLW  00
1930:  ADDWFC 02,W
1932:  MOVWF  02
1934:  MOVLW  00
1936:  ADDWFC 03,W
1938:  MOVWF  03
193A:  MOVFF  01,02
193E:  MOVFF  00,01
1942:  MOVLB  2
.................... } 
1944:  MOVLB  0
1946:  RETLW  00
.................... #endif 
.................... /* 
.................... signed int format(int32 DskSize) 
.................... Summary: Formats media with a FAT filesystem. 
.................... Param: The size of the filesystem to create in kB. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: There are certain minimum and maximum size restrictions on the card and type of file system. The restrictions are as follows: 
....................        FAT16: DskSize < 2GB 
....................        FAT32: 33MB < DskSize < 32GB 
....................        In order to change the way that the drive is formatted, select the proper #define(FAT16 or FAT32) way up at the top of this file. 
.................... Note: In this context, 1kB = 1024B = 2^10B. Please don't confuse this with 10^3B, we don't want to be wasting thousands of bytes of information now, do we? 
.................... Note: DskSize has a lower limit of 64, anything lower becomes highly inefficient and runs the risk of very quick corruption. 
.................... Note: If this is called on an MMC/SD card, Windows will recognize it as a RAW filesystem. 
.................... */ 
.................... signed int format(int32 DskSize) 
.................... { 
*
6036:  MOVLW  F8
6038:  MOVLB  5
603A:  MOVWF  x6F
603C:  MOVLW  01
603E:  MOVWF  x70
6040:  MOVLW  02
6042:  MOVWF  x71
6044:  MOVLW  20
6046:  MOVWF  x73
6048:  MOVLW  02
604A:  MOVWF  x75
604C:  CLRF   x74
604E:  CLRF   x7F
6050:  CLRF   x7E
6052:  CLRF   x7D
6054:  CLRF   x7C
*
60A0:  MOVLW  29
60A2:  MOVWF  xA1
60A4:  MOVLW  3C
60A6:  MOVWF  xA2
60A8:  MOVLW  02
60AA:  MOVWF  xE4
60AC:  CLRF   xE3
60AE:  CLRF   xE6
60B0:  MOVLW  01
60B2:  MOVWF  xE5
....................    int 
....................       BPB_Media = 0xF8, 
....................       BPB_NumFATs = 1, 
....................       BPB_NumHeads = 2, 
....................       BPB_SecPerClus, 
....................       BPB_SecPerTrk = 0x20; 
....................  
....................    int16 
....................       BPB_BytsPerSec = 0x200, 
....................       i; 
....................  
....................    int32 
....................       BPB_TotSec, 
....................       BS_VolID = 0, 
....................       RootDirSectors, 
....................       TmpVal1, 
....................       TmpVal2; 
....................  
....................    char                
....................       BS_OEMName[] = "MSDOS5.0", 
*
6056:  MOVLW  4D
6058:  MOVWF  x8C
605A:  MOVLW  53
605C:  MOVWF  x8D
605E:  MOVLW  44
6060:  MOVWF  x8E
6062:  MOVLW  4F
6064:  MOVWF  x8F
6066:  MOVLW  53
6068:  MOVWF  x90
606A:  MOVLW  35
606C:  MOVWF  x91
606E:  MOVLW  2E
6070:  MOVWF  x92
6072:  MOVLW  30
6074:  MOVWF  x93
6076:  CLRF   x94
....................       BS_VolLab[] = "NO NAME    "; 
6078:  MOVLW  4E
607A:  MOVWF  x95
607C:  MOVLW  4F
607E:  MOVWF  x96
6080:  MOVLW  20
6082:  MOVWF  x97
6084:  MOVLW  4E
6086:  MOVWF  x98
6088:  MOVLW  41
608A:  MOVWF  x99
608C:  MOVLW  4D
608E:  MOVWF  x9A
6090:  MOVLW  45
6092:  MOVWF  x9B
6094:  MOVLW  20
6096:  MOVWF  x9C
6098:  MOVWF  x9D
609A:  MOVWF  x9E
609C:  MOVWF  x9F
609E:  CLRF   xA0
....................  
.................... #ifdef FAT32 
....................    int 
....................       BPB_BkBootSec = 6, 
....................       BPB_FSInfo = 1, 
....................       BPB_RootClus = 2, 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x58, 
....................       data[0x5A]; 
....................  
....................    int16 
....................       BPB_RootEntCnt = 0, 
....................       BPB_RsvdSecCnt = 32; 
....................     
....................    int32 BPB_FATSz; 
....................     
....................    char BS_FilSysType[] = "FAT32   "; 
.................... #else 
....................    int 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x3C, 
....................       data[0x3E]; 
....................        
....................    int16 
....................       BPB_FATSz, 
....................       BPB_RootEntCnt = 512, 
....................       BPB_RsvdSecCnt = 1; 
....................        
....................    char BS_FilSysType[] = "FAT12   "; 
*
60B4:  MOVLW  46
60B6:  MOVWF  xE7
60B8:  MOVLW  41
60BA:  MOVWF  xE8
60BC:  MOVLW  54
60BE:  MOVWF  xE9
60C0:  MOVLW  31
60C2:  MOVWF  xEA
60C4:  MOVLW  32
60C6:  MOVWF  xEB
60C8:  MOVLW  20
60CA:  MOVWF  xEC
60CC:  MOVWF  xED
60CE:  MOVWF  xEE
60D0:  CLRF   xEF
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize variables 
....................    // figure out total sectors 
....................    BPB_TotSec = (DskSize * 0x400) / BPB_BytsPerSec; 
60D2:  CLRF   xF0
60D4:  RLCF   x6B,W
60D6:  MOVWF  xF1
60D8:  RLCF   x6C,W
60DA:  MOVWF  xF2
60DC:  RLCF   x6D,W
60DE:  MOVWF  xF3
60E0:  RLCF   xF1,F
60E2:  RLCF   xF2,F
60E4:  RLCF   xF3,F
60E6:  MOVLW  FC
60E8:  ANDWF  xF1,F
60EA:  MOVFF  5F3,6A5
60EE:  MOVFF  5F2,6A4
60F2:  MOVFF  5F1,6A3
60F6:  MOVFF  5F0,6A2
60FA:  MOVLB  6
60FC:  CLRF   xA9
60FE:  CLRF   xA8
6100:  MOVFF  575,6A7
6104:  MOVFF  574,6A6
6108:  MOVLB  0
610A:  CALL   0EE4
610E:  MOVFF  03,57B
6112:  MOVFF  02,57A
6116:  MOVFF  01,579
611A:  MOVFF  00,578
....................     
....................    // use the magical table on page 20 of fatgen103.pdf to determine sectors per cluster 
.................... #ifdef FAT32 
....................    if(DskSize < 0x8400) // < 33 MB; this is too small 
....................       return EOF; 
....................    else if(DskSize < 0x41000) // 260 MB 
....................       BPB_SecPerClus = 1; 
....................    else if(DskSize < 0X800000) // 8 GB 
....................       BPB_SecPerClus = 8; 
....................    else if(DskSize < 0x1000000) // 16 GB 
....................       BPB_SecPerClus = 16; 
....................    else if(DskSize < 0x2000000) // 32 GB 
....................       BPB_SecPerClus = 32; 
....................    else // > 32 GB; this is too big 
....................       return EOF; 
.................... #else 
....................    if(DskSize < 0x1400) // < 5 MB 
611E:  MOVLB  5
6120:  MOVF   x6E,F
6122:  BNZ   6134
6124:  MOVF   x6D,F
6126:  BNZ   6134
6128:  MOVF   x6C,W
612A:  SUBLW  13
612C:  BNC   6134
....................       BPB_SecPerClus = 1; 
612E:  MOVLW  01
6130:  MOVWF  x72
....................    else if(DskSize < 0x4000) // 16 MB 
6132:  BRA    619E
6134:  MOVF   x6E,F
6136:  BNZ   6148
6138:  MOVF   x6D,F
613A:  BNZ   6148
613C:  MOVF   x6C,W
613E:  SUBLW  3F
6140:  BNC   6148
....................       BPB_SecPerClus = 2; 
6142:  MOVLW  02
6144:  MOVWF  x72
....................    else if(DskSize < 0X20000) // 128 MB 
6146:  BRA    619E
6148:  MOVF   x6E,F
614A:  BNZ   6158
614C:  MOVF   x6D,W
614E:  SUBLW  01
6150:  BNC   6158
....................       BPB_SecPerClus = 4; 
6152:  MOVLW  04
6154:  MOVWF  x72
....................    else if(DskSize < 0x40000) // 256 MB 
6156:  BRA    619E
6158:  MOVF   x6E,F
615A:  BNZ   6168
615C:  MOVF   x6D,W
615E:  SUBLW  03
6160:  BNC   6168
....................       BPB_SecPerClus = 8; 
6162:  MOVLW  08
6164:  MOVWF  x72
....................    else if(DskSize < 0x80000) // 512 MB 
6166:  BRA    619E
6168:  MOVF   x6E,F
616A:  BNZ   6178
616C:  MOVF   x6D,W
616E:  SUBLW  07
6170:  BNC   6178
....................       BPB_SecPerClus = 16; 
6172:  MOVLW  10
6174:  MOVWF  x72
....................    else if(DskSize < 0x100000) // 1 GB 
6176:  BRA    619E
6178:  MOVF   x6E,F
617A:  BNZ   6188
617C:  MOVF   x6D,W
617E:  SUBLW  0F
6180:  BNC   6188
....................       BPB_SecPerClus = 32; 
6182:  MOVLW  20
6184:  MOVWF  x72
....................    else if(DskSize < 0x200000) // 2 GB 
6186:  BRA    619E
6188:  MOVF   x6E,F
618A:  BNZ   6198
618C:  MOVF   x6D,W
618E:  SUBLW  1F
6190:  BNC   6198
....................       BPB_SecPerClus = 64; 
6192:  MOVLW  40
6194:  MOVWF  x72
....................    else // > 2 GB; this is too big 
6196:  BRA    619E
....................       return EOF; 
6198:  MOVLW  FF
619A:  MOVWF  01
619C:  BRA    656C
.................... #endif // #ifdef FAT32 
....................  
....................    // figure out how many sectors one FAT takes up 
....................    RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec;  
619E:  RLCF   xE3,W
61A0:  MOVWF  xF0
61A2:  RLCF   xE4,W
61A4:  MOVWF  xF1
61A6:  RLCF   xF0,F
61A8:  RLCF   xF1,F
61AA:  RLCF   xF0,F
61AC:  RLCF   xF1,F
61AE:  RLCF   xF0,F
61B0:  RLCF   xF1,F
61B2:  RLCF   xF0,F
61B4:  RLCF   xF1,F
61B6:  MOVLW  E0
61B8:  ANDWF  xF0,F
61BA:  MOVLW  01
61BC:  SUBWF  x74,W
61BE:  MOVWF  00
61C0:  MOVLW  00
61C2:  SUBWFB x75,W
61C4:  MOVWF  03
61C6:  MOVF   00,W
61C8:  ADDWF  xF0,F
61CA:  MOVF   03,W
61CC:  ADDWFC xF1,F
61CE:  MOVFF  5F1,5F3
61D2:  MOVFF  5F0,5F2
61D6:  MOVFF  575,5F5
61DA:  MOVFF  574,5F4
61DE:  MOVLB  0
61E0:  BRA    5FC8
61E2:  MOVLB  5
61E4:  CLRF   x83
61E6:  CLRF   x82
61E8:  MOVFF  02,581
61EC:  MOVFF  01,580
....................    TmpVal1 = DskSize - (BPB_RsvdSecCnt + RootDirSectors);  
61F0:  MOVF   xE5,W
61F2:  ADDWF  x80,W
61F4:  MOVWF  00
61F6:  MOVF   xE6,W
61F8:  ADDWFC x81,W
61FA:  MOVWF  01
61FC:  MOVLW  00
61FE:  ADDWFC x82,W
6200:  MOVWF  02
6202:  MOVLW  00
6204:  ADDWFC x83,W
6206:  MOVWF  03
6208:  MOVF   00,W
620A:  SUBWF  x6B,W
620C:  MOVWF  x84
620E:  MOVF   01,W
6210:  SUBWFB x6C,W
6212:  MOVWF  x85
6214:  MOVF   02,W
6216:  SUBWFB x6D,W
6218:  MOVWF  x86
621A:  MOVF   03,W
621C:  SUBWFB x6E,W
621E:  MOVWF  x87
....................    TmpVal2 = (256 * BPB_SecPerClus) + BPB_NumFATs;  
6220:  CLRF   xF0
6222:  MOVF   x70,W
6224:  ADDWF  xF0,W
6226:  MOVWF  x88
6228:  MOVLW  00
622A:  ADDWFC x72,W
622C:  MOVWF  x89
622E:  CLRF   x8A
6230:  CLRF   x8B
.................... #ifdef FAT32 
....................    TmpVal2 = TmpVal2 / 2; 
.................... #endif // #ifdef FAT32  
....................    BPB_FATSz = (TmpVal1 + (TmpVal2 - 1)) / TmpVal2; 
6232:  MOVLW  01
6234:  SUBWF  x88,W
6236:  MOVWF  00
6238:  MOVLW  00
623A:  SUBWFB x89,W
623C:  MOVWF  01
623E:  MOVLW  00
6240:  SUBWFB x8A,W
6242:  MOVWF  02
6244:  MOVLW  00
6246:  SUBWFB x8B,W
6248:  MOVWF  03
624A:  MOVF   00,W
624C:  ADDWF  x84,W
624E:  MOVWF  xF0
6250:  MOVF   01,W
6252:  ADDWFC x85,W
6254:  MOVWF  xF1
6256:  MOVF   02,W
6258:  ADDWFC x86,W
625A:  MOVWF  xF2
625C:  MOVF   03,W
625E:  ADDWFC x87,W
6260:  MOVWF  xF3
6262:  MOVFF  FE8,6A5
6266:  MOVFF  5F2,6A4
626A:  MOVFF  5F1,6A3
626E:  MOVFF  5F0,6A2
6272:  MOVFF  58B,6A9
6276:  MOVFF  58A,6A8
627A:  MOVFF  589,6A7
627E:  MOVFF  588,6A6
6282:  MOVLB  0
6284:  CALL   0EE4
6288:  MOVFF  01,5E2
628C:  MOVFF  00,5E1
....................  
....................    // zero data 
....................    for(i = 0; i < sizeof(data); i += 1) 
6290:  MOVLB  5
6292:  CLRF   x77
6294:  CLRF   x76
6296:  MOVF   x77,F
6298:  BNZ   62B8
629A:  MOVF   x76,W
629C:  SUBLW  3D
629E:  BNC   62B8
....................       data[i] = 0; 
62A0:  MOVLW  A3
62A2:  ADDWF  x76,W
62A4:  MOVWF  FE9
62A6:  MOVLW  05
62A8:  ADDWFC x77,W
62AA:  MOVWF  FEA
62AC:  CLRF   FEF
62AE:  MOVLW  01
62B0:  ADDWF  x76,F
62B2:  MOVLW  00
62B4:  ADDWFC x77,F
62B6:  BRA    6296
....................  
....................    // start filling up data 
....................    data[0] = 0xEB; 
62B8:  MOVLW  EB
62BA:  MOVWF  xA3
....................    data[1] = BS_jmpBoot; 
62BC:  MOVFF  5A2,5A4
....................    data[2] = 0x90;    
62C0:  MOVLW  90
62C2:  MOVWF  xA5
....................    sprintf(data + 3, "%s", BS_OEMName); 
62C4:  MOVLW  05
62C6:  MOVLB  2
62C8:  MOVWF  x29
62CA:  MOVLW  A6
62CC:  MOVWF  x28
62CE:  MOVLW  05
62D0:  MOVWF  FEA
62D2:  MOVLW  8C
62D4:  MOVWF  FE9
62D6:  MOVLB  0
62D8:  RCALL  6010
....................    data[11] = make8(BPB_BytsPerSec, 0); 
62DA:  MOVLB  5
62DC:  MOVFF  574,5AE
....................    data[12] = make8(BPB_BytsPerSec, 1); 
62E0:  MOVFF  575,5AF
....................    data[13] = BPB_SecPerClus; 
62E4:  MOVFF  572,5B0
....................    data[14] = BPB_RsvdSecCnt; 
62E8:  MOVFF  5E5,5B1
....................    data[16] = BPB_NumFATs; 
62EC:  MOVFF  570,5B3
....................    data[21] = BPB_Media; 
62F0:  MOVFF  56F,5B8
....................    data[24] = BPB_SecPerTrk;  
62F4:  MOVFF  573,5BB
....................    data[26] = BPB_NumHeads; 
62F8:  MOVFF  571,5BD
.................... #ifdef FAT32 
....................    data[32] = make8(BPB_TotSec, 0); 
....................    data[33] = make8(BPB_TotSec, 1); 
....................    data[34] = make8(BPB_TotSec, 2); 
....................    data[35] = make8(BPB_TotSec, 3); 
....................    data[36] = make8(BPB_FATSz, 0); 
....................    data[37] = make8(BPB_FATSz, 1); 
....................    data[38] = make8(BPB_FATSz, 2); 
....................    data[39] = make8(BPB_FATSz, 3); 
....................    data[44] = BPB_RootClus; 
....................    data[48] = BPB_FSInfo; 
....................    data[50] = BPB_BkBootSec; 
....................    data[66] = BS_BootSig; 
....................    data[67] = make8(BS_VolID, 0); 
....................    data[68] = make8(BS_VolID, 1); 
....................    data[69] = make8(BS_VolID, 2); 
....................    data[70] = make8(BS_VolID, 3); 
....................    sprintf(data + 71, "%s", BS_VolLab); 
....................    sprintf(data + 82, "%s", BS_FilSysType); 
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
....................       return EOF; 
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
....................       data[i] = 0; 
....................  
....................    // get rid of everything in the root directory 
....................    clear_cluster(2); 
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................  
....................    // insert the first 12 entries into the FAT(s) 
....................    data[0] = 0xF8; 
....................    data[1] = 0xFF; 
....................    data[2] = 0xFF; 
....................    data[3] = 0x0F; 
....................    data[4] = 0xFF; 
....................    data[5] = 0xFF; 
....................    data[6] = 0xFF; 
....................    data[7] = 0x0F; 
....................    data[8] = 0xFF; 
....................    data[9] = 0xFF; 
....................    data[10] = 0xFF; 
....................    data[11] = 0x0F; 
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
....................       return EOF; 
....................        
....................    // reset the last cluster 
....................    i = 2; 
....................    if(mmcsd_write_data(0x3EC, 4, &i) != GOODEC) 
....................       return EOF; 
.................... #else 
....................    data[17] = make8(BPB_RootEntCnt, 0); 
62FC:  MOVFF  5E3,5B4
....................    data[18] = make8(BPB_RootEntCnt, 1); 
6300:  MOVFF  5E4,5B5
....................    data[19] = make8(BPB_TotSec, 0); 
6304:  MOVFF  578,5B6
....................    data[20] = make8(BPB_TotSec, 1); 
6308:  MOVFF  579,5B7
....................    data[22] = make8(BPB_FATSz, 0); 
630C:  MOVFF  5E1,5B9
....................    data[23] = make8(BPB_FATSz, 1); 
6310:  MOVFF  5E2,5BA
....................    data[38] = BS_BootSig; 
6314:  MOVFF  5A1,5C9
....................    data[39] = make8(BS_VolID, 0); 
6318:  MOVFF  57C,5CA
....................    data[40] = make8(BS_VolID, 1); 
631C:  MOVFF  57D,5CB
....................    data[41] = make8(BS_VolID, 2); 
6320:  MOVFF  57E,5CC
....................    data[42] = make8(BS_VolID, 3); 
6324:  MOVFF  57F,5CD
....................    sprintf(data + 43, "%s", BS_VolLab); 
6328:  MOVLW  05
632A:  MOVLB  2
632C:  MOVWF  x29
632E:  MOVLW  CE
6330:  MOVWF  x28
6332:  MOVLW  05
6334:  MOVWF  FEA
6336:  MOVLW  95
6338:  MOVWF  FE9
633A:  MOVLB  0
633C:  RCALL  6010
....................    sprintf(data + 54, "%s", BS_FilSysType); 
633E:  MOVLW  05
6340:  MOVLB  2
6342:  MOVWF  x29
6344:  MOVLW  D9
6346:  MOVWF  x28
6348:  MOVLW  05
634A:  MOVWF  FEA
634C:  MOVLW  E7
634E:  MOVWF  FE9
6350:  MOVLB  0
6352:  RCALL  6010
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
6354:  MOVLB  6
6356:  CLRF   xC8
6358:  CLRF   xC7
635A:  CLRF   xC6
635C:  CLRF   xC5
635E:  CLRF   xCA
6360:  MOVLW  3E
6362:  MOVWF  xC9
6364:  MOVLW  05
6366:  MOVWF  xCC
6368:  MOVLW  A3
636A:  MOVWF  xCB
636C:  MOVLB  0
636E:  CALL   1EE8
6372:  MOVF   01,F
6374:  BZ    6380
....................       return EOF; 
6376:  MOVLW  FF
6378:  MOVWF  01
637A:  MOVLB  5
637C:  BRA    656C
637E:  MOVLB  0
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
6380:  MOVFF  575,606
6384:  MOVFF  574,605
6388:  MOVFF  5E6,608
638C:  MOVFF  5E5,607
6390:  CALL   0E66
6394:  MOVLB  5
6396:  CLRF   x87
6398:  CLRF   x86
639A:  MOVFF  02,585
639E:  MOVFF  01,584
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
63A2:  MOVLB  6
63A4:  CLRF   x06
63A6:  MOVFF  570,605
63AA:  MOVFF  5E2,608
63AE:  MOVFF  5E1,607
63B2:  MOVLB  0
63B4:  CALL   0E66
63B8:  MOVF   01,W
63BA:  MOVLB  5
63BC:  ADDWF  x84,W
63BE:  MOVWF  x88
63C0:  MOVF   02,W
63C2:  ADDWFC x85,W
63C4:  MOVWF  x89
63C6:  MOVLW  00
63C8:  ADDWFC x86,W
63CA:  MOVWF  x8A
63CC:  MOVLW  00
63CE:  ADDWFC x87,W
63D0:  MOVWF  x8B
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
63D2:  CLRF   x77
63D4:  CLRF   x76
63D6:  MOVF   x77,F
63D8:  BNZ   63F8
63DA:  MOVF   x76,W
63DC:  SUBLW  1F
63DE:  BNC   63F8
....................       data[i] = 0; 
63E0:  MOVLW  A3
63E2:  ADDWF  x76,W
63E4:  MOVWF  FE9
63E6:  MOVLW  05
63E8:  ADDWFC x77,W
63EA:  MOVWF  FEA
63EC:  CLRF   FEF
63EE:  MOVLW  01
63F0:  ADDWF  x76,F
63F2:  MOVLW  00
63F4:  ADDWFC x77,F
63F6:  BRA    63D6
....................  
....................    // get rid of everything in the root directory 
....................    for(i = 0; i < (0x20 * BPB_RootEntCnt); i += 0x20) 
63F8:  CLRF   x77
63FA:  CLRF   x76
63FC:  RLCF   xE3,W
63FE:  MOVWF  02
6400:  RLCF   xE4,W
6402:  MOVWF  03
6404:  RLCF   02,F
6406:  RLCF   03,F
6408:  RLCF   02,F
640A:  RLCF   03,F
640C:  RLCF   02,F
640E:  RLCF   03,F
6410:  RLCF   02,F
6412:  RLCF   03,F
6414:  MOVLW  E0
6416:  ANDWF  02,F
6418:  MOVFF  02,01
641C:  MOVF   x77,W
641E:  SUBWF  03,W
6420:  BNC   6482
6422:  BNZ   642A
6424:  MOVF   01,W
6426:  SUBWF  x76,W
6428:  BC    6482
....................       if(mmcsd_write_data(TmpVal2 + i, 0x20, data) != GOODEC) 
642A:  MOVF   x76,W
642C:  ADDWF  x88,W
642E:  MOVWF  xF0
6430:  MOVF   x77,W
6432:  ADDWFC x89,W
6434:  MOVWF  xF1
6436:  MOVLW  00
6438:  ADDWFC x8A,W
643A:  MOVWF  xF2
643C:  MOVLW  00
643E:  ADDWFC x8B,W
6440:  MOVWF  xF3
6442:  MOVFF  FE8,6C8
6446:  MOVFF  5F2,6C7
644A:  MOVFF  5F1,6C6
644E:  MOVFF  5F0,6C5
6452:  MOVLB  6
6454:  CLRF   xCA
6456:  MOVLW  20
6458:  MOVWF  xC9
645A:  MOVLW  05
645C:  MOVWF  xCC
645E:  MOVLW  A3
6460:  MOVWF  xCB
6462:  MOVLB  0
6464:  CALL   1EE8
6468:  MOVF   01,F
646A:  BZ    6476
....................          return EOF; 
646C:  MOVLW  FF
646E:  MOVWF  01
6470:  MOVLB  5
6472:  BRA    656C
6474:  MOVLB  0
6476:  MOVLW  20
6478:  MOVLB  5
647A:  ADDWF  x76,F
647C:  MOVLW  00
647E:  ADDWFC x77,F
6480:  BRA    63FC
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
6482:  CLRF   x77
6484:  CLRF   x76
6486:  MOVF   x77,W
6488:  SUBWF  xE2,W
648A:  BNC   64EC
648C:  BNZ   6494
648E:  MOVF   xE1,W
6490:  SUBWF  x76,W
6492:  BC    64EC
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
6494:  MOVF   x76,W
6496:  ADDWF  x84,W
6498:  MOVWF  xF0
649A:  MOVF   x77,W
649C:  ADDWFC x85,W
649E:  MOVWF  xF1
64A0:  MOVLW  00
64A2:  ADDWFC x86,W
64A4:  MOVWF  xF2
64A6:  MOVLW  00
64A8:  ADDWFC x87,W
64AA:  MOVWF  xF3
64AC:  MOVFF  FE8,6C8
64B0:  MOVFF  5F2,6C7
64B4:  MOVFF  5F1,6C6
64B8:  MOVFF  5F0,6C5
64BC:  MOVLB  6
64BE:  CLRF   xCA
64C0:  MOVLW  20
64C2:  MOVWF  xC9
64C4:  MOVLW  05
64C6:  MOVWF  xCC
64C8:  MOVLW  A3
64CA:  MOVWF  xCB
64CC:  MOVLB  0
64CE:  CALL   1EE8
64D2:  MOVF   01,F
64D4:  BZ    64E0
....................          return EOF; 
64D6:  MOVLW  FF
64D8:  MOVWF  01
64DA:  MOVLB  5
64DC:  BRA    656C
64DE:  MOVLB  0
64E0:  MOVLW  20
64E2:  MOVLB  5
64E4:  ADDWF  x76,F
64E6:  MOVLW  00
64E8:  ADDWFC x77,F
64EA:  BRA    6486
....................  
....................    // insert the first 3 entries into the FAT(s) 
....................    data[0] = 0xF8; 
64EC:  MOVLW  F8
64EE:  MOVWF  xA3
....................    data[1] = 0xFF; 
64F0:  MOVLW  FF
64F2:  MOVWF  xA4
....................    data[2] = 0xFF; 
64F4:  MOVWF  xA5
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
64F6:  MOVFF  587,6C8
64FA:  MOVFF  586,6C7
64FE:  MOVFF  585,6C6
6502:  MOVFF  584,6C5
6506:  MOVLB  6
6508:  CLRF   xCA
650A:  MOVLW  20
650C:  MOVWF  xC9
650E:  MOVLW  05
6510:  MOVWF  xCC
6512:  MOVLW  A3
6514:  MOVWF  xCB
6516:  MOVLB  0
6518:  CALL   1EE8
651C:  MOVF   01,F
651E:  BZ    6528
....................       return EOF; 
6520:  MOVLW  FF
6522:  MOVWF  01
6524:  MOVLB  5
6526:  BRA    656C
....................        
.................... #endif // #ifdef FAT32 
....................  
....................    i = 0xAA55; 
6528:  MOVLW  AA
652A:  MOVLB  5
652C:  MOVWF  x77
652E:  MOVLW  55
6530:  MOVWF  x76
....................  
....................    if(mmcsd_write_data(0x1FE, 2, &i) != GOODEC) 
6532:  MOVLB  6
6534:  CLRF   xC8
6536:  CLRF   xC7
6538:  MOVLW  01
653A:  MOVWF  xC6
653C:  MOVLW  FE
653E:  MOVWF  xC5
6540:  CLRF   xCA
6542:  MOVLW  02
6544:  MOVWF  xC9
6546:  MOVLW  05
6548:  MOVWF  xCC
654A:  MOVLW  76
654C:  MOVWF  xCB
654E:  MOVLB  0
6550:  CALL   1EE8
6554:  MOVF   01,F
6556:  BZ    6562
....................       return EOF;    
6558:  MOVLW  FF
655A:  MOVWF  01
655C:  MOVLB  5
655E:  BRA    656C
6560:  MOVLB  0
....................  
....................    // we're going to have to re-initialize the FAT, a bunch of parameters probably just changed 
....................    fat_init(); 
6562:  CALL   0F64
....................  
....................    return GOODEC; 
6566:  MOVLW  00
6568:  MOVWF  01
656A:  MOVLB  5
.................... } 
656C:  MOVLB  0
656E:  GOTO   65E2 (RETURN)
....................  
.................... /// Debugging Utility Functions /// 
....................  
.................... /* 
.................... signed int disp_folder_contents(char foldername[]) 
.................... Summary: Displays the contents of a folder. 
.................... Param: The folder to display the contents of. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int disp_folder_contents(char foldername[]) 
.................... { 
....................    char filename[MAX_FILE_NAME_LENGTH]; // a place to hold a file name 
....................     
....................    FILE stream; // the stream that we're going to be working with 
....................     
....................    char mode[] = "r"; 
*
517A:  MOVLW  72
517C:  MOVLB  5
517E:  MOVWF  xC3
5180:  CLRF   xC4
....................     
....................    if(fatopen(foldername, mode, &stream) != GOODEC) 
5182:  MOVFF  568,5EF
5186:  MOVFF  567,5EE
518A:  MOVLW  05
518C:  MOVWF  xF1
518E:  MOVLW  C3
5190:  MOVWF  xF0
5192:  MOVLW  05
5194:  MOVWF  xF3
5196:  MOVLW  89
5198:  MOVWF  xF2
519A:  MOVLB  0
519C:  CALL   3474
51A0:  MOVF   01,F
51A2:  BZ    51AA
....................       return EOF; 
51A4:  MOVLW  FF
51A6:  MOVWF  01
51A8:  BRA    526A
....................  
....................    // printf off a header 
....................    printf("\r\n--%s--", foldername); 
51AA:  MOVLW  04
51AC:  MOVWF  FF6
51AE:  MOVLW  00
51B0:  MOVWF  FF7
51B2:  MOVLW  04
51B4:  MOVLB  5
51B6:  MOVWF  xC5
51B8:  MOVLB  0
51BA:  CALL   1790
51BE:  MOVFF  568,FEA
51C2:  MOVFF  567,FE9
51C6:  CALL   1294
51CA:  MOVLW  2D
51CC:  BTFSS  F9E.4
51CE:  BRA    51CC
51D0:  MOVWF  FAD
51D2:  MOVLW  2D
51D4:  BTFSS  F9E.4
51D6:  BRA    51D4
51D8:  MOVWF  FAD
....................  
....................    // start off at the root directory 
....................    stream.Entry_Addr = stream.Start_Addr; 
51DA:  MOVFF  5A0,594
51DE:  MOVFF  59F,593
51E2:  MOVFF  59E,592
51E6:  MOVFF  59D,591
....................  
....................    while(get_next_file(&stream) != EOF) 
....................    { 
51EA:  MOVLW  05
51EC:  MOVLB  5
51EE:  MOVWF  xC6
51F0:  MOVLW  89
51F2:  MOVWF  xC5
51F4:  MOVLB  0
51F6:  RCALL  4EDE
51F8:  MOVF   01,W
51FA:  SUBLW  FF
51FC:  BZ    5256
....................       // get the name of the file that we are at 
....................       if(get_file_name(stream.Entry_Addr, filename) != GOODEC) 
51FE:  MOVFF  594,680
5202:  MOVFF  593,67F
5206:  MOVFF  592,67E
520A:  MOVFF  591,67D
520E:  MOVLW  05
5210:  MOVLB  6
5212:  MOVWF  x82
5214:  MOVLW  69
5216:  MOVWF  x81
5218:  MOVLB  0
521A:  CALL   1C4A
521E:  MOVF   01,F
5220:  BZ    5228
....................          return EOF; 
5222:  MOVLW  FF
5224:  MOVWF  01
5226:  BRA    526A
....................       
....................       // make cool little "tree" branches 
....................       printf("\r\n%s", filename); 
5228:  MOVLW  0D
522A:  BTFSS  F9E.4
522C:  BRA    522A
522E:  MOVWF  FAD
5230:  MOVLW  0A
5232:  BTFSS  F9E.4
5234:  BRA    5232
5236:  MOVWF  FAD
5238:  MOVLW  05
523A:  MOVWF  FEA
523C:  MOVLW  69
523E:  MOVWF  FE9
5240:  CALL   1294
....................       if (stream.File_Type == Directory) 
5244:  MOVLB  5
5246:  DECFSZ xA1,W
5248:  BRA    5252
....................          putc('/'); 
524A:  MOVLW  2F
524C:  MOVLB  0
524E:  CALL   1308
....................    } 
5252:  MOVLB  0
5254:  BRA    51EA
....................  
....................    fatclose(&stream); 
5256:  MOVLW  05
5258:  MOVLB  5
525A:  MOVWF  xEC
525C:  MOVLW  89
525E:  MOVWF  xEB
5260:  MOVLB  0
5262:  CALL   38CA
....................  
....................    return GOODEC; 
5266:  MOVLW  00
5268:  MOVWF  01
.................... } 
526A:  GOTO   5278 (RETURN)
....................  
.................... /* 
.................... signed int dump_addr(int32 from, int32 to) 
.................... Summary: Display a series of addresses in a hex editor type fashion. 
.................... Param from: The beginning address to display. 
.................... Param to: The end address to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_addr(int32 from, int32 to) 
.................... { 
....................    int 
....................       j,          // counter for loops 
....................       val[0x10];  // buffer to hold values 
....................  
....................    int32 i;       // pointer to memory 
....................  
....................    // print off header 
....................    printf("\r\n\r\n         "); 
....................    for(i = 0; i < 0x10; i += 1) 
....................       printf("%2X ", i); 
....................  
....................    // note that the to and from values are being rounded up and down 
....................    //  this makes a nice "block" map in case someone inputs a number that 
....................    //  isn't evenly divisible by 0x10 
....................    for(i = (from - (from % 0x10)); i <= (to + (to % 0x10)); i += 0x10) 
....................    { 
....................       // printf memory block 
....................       printf("\r\n%lX ", i); 
....................  
....................       // fill up buffer 
....................       if(mmcsd_read_data(i, 0x10, val) != GOODEC)   
....................          return EOF; 
....................  
....................       // printf RAM in hex 
....................       for(j = 0; j < 0X10; j += 1) 
....................          printf("%X ", val[j]); 
....................  
....................       // printf spacer 
....................       printf("; "); 
....................  
....................       // printf RAM in char 
....................       for(j = 0; j < 0X10; j += 1) 
....................       { 
....................          // check for characters that will mess up the nice-looking map 
....................          if(val[j] < ' ') 
....................             val[j] = '.'; 
....................  
....................          printf("%c", val[j]); 
....................       } 
....................    } 
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... Summary: Display a series of clusters in a memory map. 
.................... Param from: The beginning clusters to display. 
.................... Param to: The end clusters to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... { 
....................    // convert the clusters to addresses and dump 
....................    if(dump_addr(cluster_to_addr(from), cluster_to_addr(to)) != GOODEC) 
....................       return EOF; 
.................... } 
....................  
.................... /* 
.................... void disp_fat_stats() 
.................... Summary: Display essential statistics about the FAT to the console. 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_fat_stats() 
.................... { 
....................    printf("\r\n\r\n--FAT Stats--\r\n"); 
....................    printf("First FAT starts at: 0x%lX\r\n", FAT_Start); 
....................    printf("Data Starts At: 0x%lX\r\n", Data_Start); 
....................    printf("Root Directory Is At: 0x%lX\r\n", Root_Dir); 
....................    printf("Bytes Per Cluster: 0x%lX\r\n", Bytes_Per_Cluster); 
.................... } 
....................  
.................... /* 
.................... signed int fatprintfinfo(FILE* stream) 
.................... Summary: Display essential statistics about the file that a stream is pointing to. 
.................... Param: The stream to print off information about. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatprintfinfo(FILE* stream) 
.................... { 
....................    int ec = 0; 
....................  
....................    int32 val = 0; // buffer to hold values 
....................  
....................    char name[MAX_FILE_NAME_LENGTH]; 
....................  
....................    // get name 
....................    if(get_file_name(stream->Entry_Addr, name) != GOODEC) 
....................       return EOF; 
....................  
....................    // printf header 
....................    printf("\r\n\r\n--"); 
....................    printf(name); 
....................    printf(" Info--"); 
....................  
....................    // printf attributes 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0B, 1, &val); 
....................    printf("\r\nAttributes: 0x%X", val); 
....................  
....................    // printf creation date 
....................    printf("\r\nCreated: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x10, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf creation time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0E, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf modification date 
....................    printf("\r\nModified: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x18, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf modification time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x16, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf starting cluster 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&val + 1); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &val); 
....................  
....................    printf("\r\nStarting cluster: %lX", val); 
....................  
....................    // printf starting address 
....................    printf("\r\nStarting address: %lX", cluster_to_addr(val)); 
....................  
....................    // printf size 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1C, 4, &val); 
....................    printf("\r\nSize: %lu Bytes\r\n", val); 
....................  
....................    if(ec != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... #endif // #ifndef FAT_PIC_C 
....................  
....................  
....................  
.................... ////////////////////// 
.................... ///                /// 
.................... /// Useful Defines /// 
.................... ///                /// 
.................... ////////////////////// 
....................  
.................... #define COMMAND_SIZE 10 
.................... #define NUM_COMMANDS 11 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... char g_CWD[200] = "/"; //current working directory 
....................  
.................... char commands[NUM_COMMANDS][COMMAND_SIZE]= 
.................... { 
....................    "del",      //option1=filename.  delete file. 
....................    "make",     //option1=filename.  create an empty file, give error if file already exists 
....................    "append",   //option1=filename, option2=string.  append string to end of file 
....................    "cd",    //option1=new cwd.  change working directory.  / is root. 
....................    "dir",    //show files in directory 
....................    "cat",    //option1=filename.  display full contents in ascii 
....................    "tail",  //option1=filename.  display the last 20 lines of file. 
....................    "mkdir", //option1=dir.  create directory.  see 'cd' for rules on dir 
....................    "rmdir",  //option1=dir.  remove directory.  see 'cd' for rules on dir. 
....................    "format",   // option1=media size in bytes. formats the media. 
....................    "help"   // help! 
.................... }; 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /* 
.................... Summary: Finds a command from the global list of commands. 
.................... Param: A pointer to the command string. 
.................... Returns: The command number if the command is found in the command list. 
....................          0xFF if the command isn't found 
.................... */ 
.................... int FindCommand(char *cmd) 
.................... { 
....................    char buf[COMMAND_SIZE]; 
....................    int i; 
....................     
....................    for (i=0; i<NUM_COMMANDS; i++) 
*
172A:  MOVLB  5
172C:  CLRF   x71
172E:  MOVF   x71,W
1730:  SUBLW  0A
1732:  BNC   1786
....................    { 
....................       strcpy(buf, &commands[i][0]); 
1734:  MOVF   x71,W
1736:  MULLW  0A
1738:  MOVF   FF3,W
173A:  CLRF   x73
173C:  MOVWF  x72
173E:  MOVLW  F2
1740:  ADDWF  x72,F
1742:  MOVLW  02
1744:  ADDWFC x73,F
1746:  MOVLW  05
1748:  MOVWF  FEA
174A:  MOVLW  67
174C:  MOVWF  FE9
174E:  MOVFF  573,FE2
1752:  MOVFF  572,FE1
1756:  MOVF   FE7,F
1758:  MOVFF  FE6,FEE
175C:  BNZ   1756
....................       if (stricmp(buf, cmd)==0) 
175E:  MOVLW  05
1760:  MOVWF  x73
1762:  MOVLW  67
1764:  MOVWF  x72
1766:  MOVFF  566,575
176A:  MOVFF  565,574
176E:  MOVLB  0
1770:  BRA    1620
1772:  MOVF   01,F
1774:  BNZ   1780
....................          return(i); 
1776:  MOVLB  5
1778:  MOVFF  571,01
177C:  BRA    178A
177E:  MOVLB  0
....................    } 
1780:  MOVLB  5
1782:  INCF   x71,F
1784:  BRA    172E
....................     
....................    return(0xFF); 
1786:  MOVLW  FF
1788:  MOVWF  01
.................... } 
178A:  MOVLB  0
178C:  GOTO   69D8 (RETURN)
....................  
.................... /* 
.................... Summary: Displays the current working directory. 
.................... Param: None. 
.................... Returns: None. 
.................... */ 
.................... void DisplayPrompt(void) 
.................... { 
....................    printf("\r\n\n%s> ", g_CWD); 
*
12BA:  MOVLW  0D
12BC:  BTFSS  F9E.4
12BE:  BRA    12BC
12C0:  MOVWF  FAD
12C2:  MOVLW  0A
12C4:  BTFSS  F9E.4
12C6:  BRA    12C4
12C8:  MOVWF  FAD
12CA:  MOVLW  0A
12CC:  BTFSS  F9E.4
12CE:  BRA    12CC
12D0:  MOVWF  FAD
12D2:  MOVLW  02
12D4:  MOVWF  FEA
12D6:  MOVLW  2A
12D8:  MOVWF  FE9
12DA:  RCALL  1294
12DC:  MOVLW  3E
12DE:  BTFSS  F9E.4
12E0:  BRA    12DE
12E2:  MOVWF  FAD
12E4:  MOVLW  20
12E6:  BTFSS  F9E.4
12E8:  BRA    12E6
12EA:  MOVWF  FAD
.................... } 
12EC:  GOTO   6830 (RETURN)
....................  
.................... /* 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: None. 
.................... */ 
.................... void DeleteFile(char *fileName) 
.................... { 
....................    printf("\r\nDeleting '%s': ", fileName); 
*
3DFC:  MOVLW  22
3DFE:  MOVWF  FF6
3E00:  MOVLW  01
3E02:  MOVWF  FF7
3E04:  MOVLW  0C
3E06:  MOVLB  5
3E08:  MOVWF  xC5
3E0A:  MOVLB  0
3E0C:  CALL   1790
3E10:  MOVFF  566,FEA
3E14:  MOVFF  565,FE9
3E18:  CALL   1294
3E1C:  MOVLW  27
3E1E:  BTFSS  F9E.4
3E20:  BRA    3E1E
3E22:  MOVWF  FAD
3E24:  MOVLW  3A
3E26:  BTFSS  F9E.4
3E28:  BRA    3E26
3E2A:  MOVWF  FAD
3E2C:  MOVLW  20
3E2E:  BTFSS  F9E.4
3E30:  BRA    3E2E
3E32:  MOVWF  FAD
....................    if(rm_file(fileName) != GOODEC) 
3E34:  MOVFF  566,5A8
3E38:  MOVFF  565,5A7
3E3C:  RCALL  3BFA
3E3E:  MOVF   01,F
3E40:  BZ    3E50
....................    { 
....................       printf("Error deleting file"); 
3E42:  MOVLW  34
3E44:  MOVWF  FF6
3E46:  MOVLW  01
3E48:  MOVWF  FF7
3E4A:  CALL   1272
....................       return; 
3E4E:  BRA    3E60
....................    } 
....................    printf("OK"); 
3E50:  MOVLW  4F
3E52:  BTFSS  F9E.4
3E54:  BRA    3E52
3E56:  MOVWF  FAD
3E58:  MOVLW  4B
3E5A:  BTFSS  F9E.4
3E5C:  BRA    3E5A
3E5E:  MOVWF  FAD
.................... } 
3E60:  GOTO   6AF0 (RETURN)
....................  
.................... /* 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: None. 
.................... Example Usage: \> make "Log.txt" 
.................... */ 
.................... void MakeFile(char *fileName) 
.................... { 
....................    printf("\r\nMaking file '%s': ", fileName); 
*
4B42:  MOVLW  48
4B44:  MOVWF  FF6
4B46:  MOVLW  01
4B48:  MOVWF  FF7
4B4A:  MOVLW  0F
4B4C:  MOVLB  5
4B4E:  MOVWF  xC5
4B50:  MOVLB  0
4B52:  CALL   1790
4B56:  MOVFF  566,FEA
4B5A:  MOVFF  565,FE9
4B5E:  CALL   1294
4B62:  MOVLW  27
4B64:  BTFSS  F9E.4
4B66:  BRA    4B64
4B68:  MOVWF  FAD
4B6A:  MOVLW  3A
4B6C:  BTFSS  F9E.4
4B6E:  BRA    4B6C
4B70:  MOVWF  FAD
4B72:  MOVLW  20
4B74:  BTFSS  F9E.4
4B76:  BRA    4B74
4B78:  MOVWF  FAD
....................    if(mk_file(fileName) != GOODEC) 
4B7A:  MOVFF  566,568
4B7E:  MOVFF  565,567
4B82:  BRA    49BC
4B84:  MOVF   01,F
4B86:  BZ    4B96
....................    { 
....................       printf("Error creating file"); 
4B88:  MOVLW  5E
4B8A:  MOVWF  FF6
4B8C:  MOVLW  01
4B8E:  MOVWF  FF7
4B90:  CALL   1272
....................       return; 
4B94:  BRA    4BA6
....................    } 
....................    printf("OK"); 
4B96:  MOVLW  4F
4B98:  BTFSS  F9E.4
4B9A:  BRA    4B98
4B9C:  MOVWF  FAD
4B9E:  MOVLW  4B
4BA0:  BTFSS  F9E.4
4BA2:  BRA    4BA0
4BA4:  MOVWF  FAD
.................... } 
4BA6:  GOTO   6AF0 (RETURN)
....................  
.................... /* 
.................... Summary: Append a string to a file. 
.................... Param: The full path of the file to append to. 
.................... Param: A pointer to a string to append to the file. 
.................... Returns: None. 
.................... Example Usage: \> append "Log.txt" "This will be appended to the end of Log.txt" 
.................... Note: A "\r\n" will be appended after the appendString. 
.................... */ 
.................... void AppendFile(char *fileName, char *appendString) 
.................... { 
....................    FILE stream; 
....................    printf("\r\nAppending '%s' to '%s': ", appendString, fileName); 
*
4C00:  MOVLW  72
4C02:  MOVWF  FF6
4C04:  MOVLW  01
4C06:  MOVWF  FF7
4C08:  MOVLW  0D
4C0A:  MOVLB  5
4C0C:  MOVWF  xC5
4C0E:  MOVLB  0
4C10:  CALL   1790
4C14:  MOVFF  568,FEA
4C18:  MOVFF  567,FE9
4C1C:  CALL   1294
4C20:  MOVLW  81
4C22:  MOVWF  FF6
4C24:  MOVLW  01
4C26:  MOVWF  FF7
4C28:  MOVLW  06
4C2A:  MOVLB  5
4C2C:  MOVWF  xC5
4C2E:  MOVLB  0
4C30:  CALL   1790
4C34:  MOVFF  566,FEA
4C38:  MOVFF  565,FE9
4C3C:  CALL   1294
4C40:  MOVLW  27
4C42:  BTFSS  F9E.4
4C44:  BRA    4C42
4C46:  MOVWF  FAD
4C48:  MOVLW  3A
4C4A:  BTFSS  F9E.4
4C4C:  BRA    4C4A
4C4E:  MOVWF  FAD
4C50:  MOVLW  20
4C52:  BTFSS  F9E.4
4C54:  BRA    4C52
4C56:  MOVWF  FAD
....................    if(fatopen(fileName, "a", &stream) != GOODEC) 
4C58:  MOVLW  61
4C5A:  MOVLB  5
4C5C:  MOVWF  xA3
4C5E:  CLRF   xA4
4C60:  MOVFF  566,5EF
4C64:  MOVFF  565,5EE
4C68:  MOVLW  05
4C6A:  MOVWF  xF1
4C6C:  MOVLW  A3
4C6E:  MOVWF  xF0
4C70:  MOVLW  05
4C72:  MOVWF  xF3
4C74:  MOVLW  69
4C76:  MOVWF  xF2
4C78:  MOVLB  0
4C7A:  CALL   3474
4C7E:  MOVF   01,F
4C80:  BZ    4C90
....................    { 
....................       printf("Error opening file"); 
4C82:  MOVLW  8E
4C84:  MOVWF  FF6
4C86:  MOVLW  01
4C88:  MOVWF  FF7
4C8A:  CALL   1272
....................       return; 
4C8E:  BRA    4CF8
....................    } 
....................     
....................    fatputs(appendString, &stream); 
4C90:  MOVFF  568,5A9
4C94:  MOVFF  567,5A8
4C98:  MOVLW  05
4C9A:  MOVLB  5
4C9C:  MOVWF  xAB
4C9E:  MOVLW  69
4CA0:  MOVWF  xAA
4CA2:  MOVLB  0
4CA4:  RCALL  4BAA
....................    fatputs("\r\n", &stream); 
4CA6:  MOVLW  0D
4CA8:  MOVLB  5
4CAA:  MOVWF  xA3
4CAC:  MOVLW  0A
4CAE:  MOVWF  xA4
4CB0:  CLRF   xA5
4CB2:  MOVLW  05
4CB4:  MOVWF  xA9
4CB6:  MOVLW  A3
4CB8:  MOVWF  xA8
4CBA:  MOVLW  05
4CBC:  MOVWF  xAB
4CBE:  MOVLW  69
4CC0:  MOVWF  xAA
4CC2:  MOVLB  0
4CC4:  RCALL  4BAA
....................  
....................    if(fatclose(&stream) != GOODEC) 
4CC6:  MOVLW  05
4CC8:  MOVLB  5
4CCA:  MOVWF  xEC
4CCC:  MOVLW  69
4CCE:  MOVWF  xEB
4CD0:  MOVLB  0
4CD2:  CALL   38CA
4CD6:  MOVF   01,F
4CD8:  BZ    4CE8
....................    { 
....................       printf("Error closing file"); 
4CDA:  MOVLW  A2
4CDC:  MOVWF  FF6
4CDE:  MOVLW  01
4CE0:  MOVWF  FF7
4CE2:  CALL   1272
....................       return; 
4CE6:  BRA    4CF8
....................    } 
....................    printf("OK"); 
4CE8:  MOVLW  4F
4CEA:  BTFSS  F9E.4
4CEC:  BRA    4CEA
4CEE:  MOVWF  FAD
4CF0:  MOVLW  4B
4CF2:  BTFSS  F9E.4
4CF4:  BRA    4CF2
4CF6:  MOVWF  FAD
.................... } 
4CF8:  GOTO   6AF0 (RETURN)
....................  
.................... /* 
.................... Summary: Change the working directory. 
.................... Param: The new working directory to switch to. 
.................... Returns: None. 
.................... Example Usage: \> cd ftp/     -> /ftp/ 
....................                \ftp\> cd files/  -> /ftp/files/ 
....................                \ftp\files> cd..  -> /ftp/ 
....................                \ftp\> cd ..      -> / 
....................                \> cd /ftp/files/ -> /ftp/files/ 
....................                 
.................... Note: Changing the directory to .. will go up a directory. 
.................... */ 
.................... void ChangeDirectory(char *newCWD) 
.................... { 
....................    FILE stream; 
....................     
....................    //append a / to the end of the filename if it doesn't exist 
....................    //making an assumption here that newCWD can hold 1 more character 
....................    if (newCWD[strlen(newCWD)-1] != '/') 
*
4D8C:  MOVFF  566,65E
4D90:  MOVFF  565,65D
4D94:  CALL   14F4
4D98:  MOVLW  01
4D9A:  SUBWF  01,W
4D9C:  CLRF   03
4D9E:  MOVLB  5
4DA0:  ADDWF  x65,W
4DA2:  MOVWF  FE9
4DA4:  MOVF   x66,W
4DA6:  ADDWFC 03,W
4DA8:  MOVWF  FEA
4DAA:  MOVF   FEF,W
4DAC:  SUBLW  2F
4DAE:  BZ    4DCE
....................      strcat(newCWD, "/"); 
4DB0:  MOVLW  2F
4DB2:  MOVWF  xA1
4DB4:  CLRF   xA2
4DB6:  MOVFF  566,5A8
4DBA:  MOVFF  565,5A7
4DBE:  MOVLW  05
4DC0:  MOVWF  xAA
4DC2:  MOVLW  A1
4DC4:  MOVWF  xA9
4DC6:  MOVLB  0
4DC8:  CALL   15AE
4DCC:  MOVLB  5
....................  
....................    if((strstr(newCWD, "../") != 0) && (strcmp(g_CWD, "/") != 0)) 
4DCE:  MOVLW  2E
4DD0:  MOVWF  xA1
4DD2:  MOVWF  xA2
4DD4:  MOVLW  2F
4DD6:  MOVWF  xA3
4DD8:  CLRF   xA4
4DDA:  MOVFF  566,5A8
4DDE:  MOVFF  565,5A7
4DE2:  MOVLW  05
4DE4:  MOVWF  xAA
4DE6:  MOVLW  A1
4DE8:  MOVWF  xA9
4DEA:  MOVLB  0
4DEC:  BRA    4CFC
4DEE:  MOVFF  02,5A8
4DF2:  MOVFF  01,5A7
4DF6:  MOVLB  5
4DF8:  MOVF   xA7,F
4DFA:  BNZ   4E00
4DFC:  MOVF   xA8,F
4DFE:  BZ    4E88
4E00:  MOVLW  2F
4E02:  MOVWF  xA1
4E04:  CLRF   xA2
4E06:  MOVLW  02
4E08:  MOVLB  6
4E0A:  MOVWF  x7E
4E0C:  MOVLW  2A
4E0E:  MOVWF  x7D
4E10:  MOVLW  05
4E12:  MOVWF  x80
4E14:  MOVLW  A1
4E16:  MOVWF  x7F
4E18:  MOVLB  0
4E1A:  CALL   1DC4
4E1E:  MOVF   01,F
4E20:  BTFSS  FD8.2
4E22:  BRA    4E28
4E24:  MOVLB  5
4E26:  BRA    4E88
....................    { 
....................       g_CWD[strlen(g_CWD) - 1] = '\0'; 
4E28:  MOVLW  02
4E2A:  MOVLB  6
4E2C:  MOVWF  x5E
4E2E:  MOVLW  2A
4E30:  MOVWF  x5D
4E32:  MOVLB  0
4E34:  CALL   14F4
4E38:  MOVLW  01
4E3A:  SUBWF  01,W
4E3C:  CLRF   03
4E3E:  ADDLW  2A
4E40:  MOVWF  FE9
4E42:  MOVLW  02
4E44:  ADDWFC 03,W
4E46:  MOVWF  FEA
4E48:  CLRF   FEF
....................              
....................       g_CWD[strrchr(g_CWD, '/') - g_CWD + 1] = '\0';       
4E4A:  MOVLW  02
4E4C:  MOVLB  5
4E4E:  MOVWF  xEF
4E50:  MOVLW  2A
4E52:  MOVWF  xEE
4E54:  MOVLW  2F
4E56:  MOVWF  xF0
4E58:  MOVLB  0
4E5A:  CALL   3E64
4E5E:  MOVFF  02,5A6
4E62:  MOVFF  01,5A5
4E66:  MOVLW  2A
4E68:  MOVLB  5
4E6A:  SUBWF  xA5,F
4E6C:  MOVLW  02
4E6E:  SUBWFB xA6,F
4E70:  MOVLW  01
4E72:  ADDWF  xA5,F
4E74:  MOVLW  00
4E76:  ADDWFC xA6,F
4E78:  MOVLW  2A
4E7A:  ADDWF  xA5,W
4E7C:  MOVWF  FE9
4E7E:  MOVLW  02
4E80:  ADDWFC xA6,W
4E82:  MOVWF  FEA
4E84:  CLRF   FEF
....................    } 
....................    else 
4E86:  BRA    4ED8
....................    { 
....................       if(fatopen(newCWD, "r", &stream) != GOODEC) 
4E88:  MOVLW  72
4E8A:  MOVWF  xA1
4E8C:  CLRF   xA2
4E8E:  MOVFF  566,5EF
4E92:  MOVFF  565,5EE
4E96:  MOVLW  05
4E98:  MOVWF  xF1
4E9A:  MOVLW  A1
4E9C:  MOVWF  xF0
4E9E:  MOVLW  05
4EA0:  MOVWF  xF3
4EA2:  MOVLW  67
4EA4:  MOVWF  xF2
4EA6:  MOVLB  0
4EA8:  CALL   3474
4EAC:  MOVF   01,F
4EAE:  BZ    4EBE
....................       { 
....................          printf("\r\nError changing directory"); 
4EB0:  MOVLW  B6
4EB2:  MOVWF  FF6
4EB4:  MOVLW  01
4EB6:  MOVWF  FF7
4EB8:  CALL   1272
....................          return; 
4EBC:  BRA    4ED6
....................       } 
....................       strcpy(g_CWD, newCWD); 
4EBE:  MOVLW  02
4EC0:  MOVWF  FEA
4EC2:  MOVLW  2A
4EC4:  MOVWF  FE9
4EC6:  MOVFF  566,FE2
4ECA:  MOVFF  565,FE1
4ECE:  MOVF   FE7,F
4ED0:  MOVFF  FE6,FEE
4ED4:  BNZ   4ECE
4ED6:  MOVLB  5
....................    } 
.................... } 
4ED8:  MOVLB  0
4EDA:  GOTO   6AF0 (RETURN)
....................  
.................... /* 
.................... Summary: Display the contents of the working directory. 
.................... Param: The full path of the directory contents to display. 
.................... Returns: None. 
.................... Example Usage: /> dir  
.................... */ 
.................... void DisplayDirectory(char *dir) 
.................... { 
....................    disp_folder_contents(dir); 
*
526E:  MOVFF  566,568
5272:  MOVFF  565,567
5276:  BRA    517A
.................... } 
5278:  GOTO   6AF0 (RETURN)
....................  
.................... /* 
.................... Summary: Create a directory. 
.................... Param: The full path of the directory to create. 
.................... Returns: None. 
.................... Example Usage: /> mkdir "Backlog" 
.................... */ 
.................... void MakeDirectory(char *dir) 
.................... { 
....................    //append a / to the end of the filename if it doesn't exist 
....................    //making an assumption here that newCWD can hold 1 more character 
....................    if (dir[strlen(dir)-1] != '/') 
*
5A86:  MOVFF  566,65E
5A8A:  MOVFF  565,65D
5A8E:  CALL   14F4
5A92:  MOVLW  01
5A94:  SUBWF  01,W
5A96:  CLRF   03
5A98:  MOVLB  5
5A9A:  ADDWF  x65,W
5A9C:  MOVWF  FE9
5A9E:  MOVF   x66,W
5AA0:  ADDWFC 03,W
5AA2:  MOVWF  FEA
5AA4:  MOVF   FEF,W
5AA6:  SUBLW  2F
5AA8:  BZ    5AC8
....................      strcat(dir, "/"); 
5AAA:  MOVLW  2F
5AAC:  MOVWF  x67
5AAE:  CLRF   x68
5AB0:  MOVFF  566,5A8
5AB4:  MOVFF  565,5A7
5AB8:  MOVLW  05
5ABA:  MOVWF  xAA
5ABC:  MOVLW  67
5ABE:  MOVWF  xA9
5AC0:  MOVLB  0
5AC2:  CALL   15AE
5AC6:  MOVLB  5
....................  
....................    printf("\r\nMaking directory '%s': ", dir); 
5AC8:  MOVLW  D2
5ACA:  MOVWF  FF6
5ACC:  MOVLW  01
5ACE:  MOVWF  FF7
5AD0:  MOVLW  14
5AD2:  MOVWF  xC5
5AD4:  MOVLB  0
5AD6:  CALL   1790
5ADA:  MOVFF  566,FEA
5ADE:  MOVFF  565,FE9
5AE2:  CALL   1294
5AE6:  MOVLW  27
5AE8:  BTFSS  F9E.4
5AEA:  BRA    5AE8
5AEC:  MOVWF  FAD
5AEE:  MOVLW  3A
5AF0:  BTFSS  F9E.4
5AF2:  BRA    5AF0
5AF4:  MOVWF  FAD
5AF6:  MOVLW  20
5AF8:  BTFSS  F9E.4
5AFA:  BRA    5AF8
5AFC:  MOVWF  FAD
....................  
....................    if(mk_dir(dir) != GOODEC) 
5AFE:  MOVFF  566,56A
5B02:  MOVFF  565,569
5B06:  BRA    567C
5B08:  MOVF   01,F
5B0A:  BZ    5B1A
....................    { 
....................       printf("Error creating directory"); 
5B0C:  MOVLW  EC
5B0E:  MOVWF  FF6
5B10:  MOVLW  01
5B12:  MOVWF  FF7
5B14:  CALL   1272
....................       return; 
5B18:  BRA    5B2A
....................    } 
....................    printf("OK"); 
5B1A:  MOVLW  4F
5B1C:  BTFSS  F9E.4
5B1E:  BRA    5B1C
5B20:  MOVWF  FAD
5B22:  MOVLW  4B
5B24:  BTFSS  F9E.4
5B26:  BRA    5B24
5B28:  MOVWF  FAD
.................... } 
5B2A:  GOTO   6AF0 (RETURN)
....................  
.................... /* 
.................... Summary: Remove a directory. 
.................... Param: The full path of the directory to remove. 
.................... Returns: None. 
.................... Example Usage: /> rmdir "Backlog" 
.................... Note: The directory needs to be empty in order for this command to work. 
.................... */ 
.................... void RemoveDirectory(char *dir) 
.................... { 
....................    printf("\r\nRemoving directory '%s': ", dir); 
*
5BB4:  MOVLW  06
5BB6:  MOVWF  FF6
5BB8:  MOVLW  02
5BBA:  MOVWF  FF7
5BBC:  MOVLW  16
5BBE:  MOVLB  5
5BC0:  MOVWF  xC5
5BC2:  MOVLB  0
5BC4:  CALL   1790
5BC8:  MOVFF  566,FEA
5BCC:  MOVFF  565,FE9
5BD0:  CALL   1294
5BD4:  MOVLW  27
5BD6:  BTFSS  F9E.4
5BD8:  BRA    5BD6
5BDA:  MOVWF  FAD
5BDC:  MOVLW  3A
5BDE:  BTFSS  F9E.4
5BE0:  BRA    5BDE
5BE2:  MOVWF  FAD
5BE4:  MOVLW  20
5BE6:  BTFSS  F9E.4
5BE8:  BRA    5BE6
5BEA:  MOVWF  FAD
....................  
....................    //append a / to the end of the filename if it doesn't exist 
....................    //making an assumption here that newCWD can hold 1 more character 
....................    if (dir[strlen(dir)-1] != '/') 
5BEC:  MOVFF  566,65E
5BF0:  MOVFF  565,65D
5BF4:  CALL   14F4
5BF8:  MOVLW  01
5BFA:  SUBWF  01,W
5BFC:  CLRF   03
5BFE:  MOVLB  5
5C00:  ADDWF  x65,W
5C02:  MOVWF  FE9
5C04:  MOVF   x66,W
5C06:  ADDWFC 03,W
5C08:  MOVWF  FEA
5C0A:  MOVF   FEF,W
5C0C:  SUBLW  2F
5C0E:  BZ    5C2C
....................      strcat(dir, "/"); 
5C10:  MOVLW  2F
5C12:  MOVWF  x67
5C14:  CLRF   x68
5C16:  MOVFF  566,5A8
5C1A:  MOVFF  565,5A7
5C1E:  MOVLW  05
5C20:  MOVWF  xAA
5C22:  MOVLW  67
5C24:  MOVWF  xA9
5C26:  MOVLB  0
5C28:  CALL   15AE
....................  
....................    if(rm_dir(dir) != GOODEC) 
5C2C:  MOVFF  566,56A
5C30:  MOVFF  565,569
5C34:  MOVLB  0
5C36:  BRA    5B2E
5C38:  MOVF   01,F
5C3A:  BZ    5C4A
....................    { 
....................       printf("Error removing directory"); 
5C3C:  MOVLW  22
5C3E:  MOVWF  FF6
5C40:  MOVLW  02
5C42:  MOVWF  FF7
5C44:  CALL   1272
....................       return; 
5C48:  BRA    5C5A
....................    } 
....................    printf("OK"); 
5C4A:  MOVLW  4F
5C4C:  BTFSS  F9E.4
5C4E:  BRA    5C4C
5C50:  MOVWF  FAD
5C52:  MOVLW  4B
5C54:  BTFSS  F9E.4
5C56:  BRA    5C54
5C58:  MOVWF  FAD
.................... } 
5C5A:  GOTO   6AF0 (RETURN)
....................  
.................... #define CAT_FROM_START  FALSE 
.................... #define CAT_FROM_END    TRUE 
.................... /* 
.................... Summary: Prints either all of or the last 80 characters in a file. 
.................... Param: The full path of the file to print off. 
.................... Param: If true, this function will print off the last 80 characters in the file. 
....................        If false, this funciton will print off the entire file. 
.................... Returns: None. 
.................... Example Usage: /> cat "Logs.txt" (this will display the entire file) 
.................... Example Usage: /> tail "Logs.txt" (this will display the last 80 characters in the file) 
.................... */ 
.................... void PrintFile(char *fileName, int1 startFromEnd) 
.................... { 
....................    FILE stream; 
....................  
....................    if(fatopen(fileName, "r", &stream) != GOODEC) 
*
55F4:  MOVLW  72
55F6:  MOVLB  5
55F8:  MOVWF  xA2
55FA:  CLRF   xA3
55FC:  MOVFF  566,5EF
5600:  MOVFF  565,5EE
5604:  MOVLW  05
5606:  MOVWF  xF1
5608:  MOVLW  A2
560A:  MOVWF  xF0
560C:  MOVLW  05
560E:  MOVWF  xF3
5610:  MOVLW  68
5612:  MOVWF  xF2
5614:  MOVLB  0
5616:  CALL   3474
561A:  MOVF   01,F
561C:  BZ    562C
....................    { 
....................       printf("\r\nError opening file"); 
561E:  MOVLW  3C
5620:  MOVWF  FF6
5622:  MOVLW  02
5624:  MOVWF  FF7
5626:  CALL   1272
....................       return; 
562A:  BRA    567A
....................    } 
....................  
....................    printf("\r\n"); 
562C:  MOVLW  0D
562E:  BTFSS  F9E.4
5630:  BRA    562E
5632:  MOVWF  FAD
5634:  MOVLW  0A
5636:  BTFSS  F9E.4
5638:  BRA    5636
563A:  MOVWF  FAD
....................  
....................    if(startFromEnd) 
563C:  MOVLB  5
563E:  MOVF   x67,F
5640:  BZ    565E
....................       fatseek(&stream, 80, SEEK_END); 
5642:  MOVLW  05
5644:  MOVWF  xA5
5646:  MOVLW  68
5648:  MOVWF  xA4
564A:  CLRF   xA9
564C:  CLRF   xA8
564E:  CLRF   xA7
5650:  MOVLW  50
5652:  MOVWF  xA6
5654:  MOVLW  01
5656:  MOVWF  xAA
5658:  MOVLB  0
565A:  BRA    527C
565C:  MOVLB  5
....................  
....................    fatprintf(&stream); 
565E:  MOVLW  05
5660:  MOVWF  xA5
5662:  MOVLW  68
5664:  MOVWF  xA4
5666:  MOVLB  0
5668:  BRA    55C6
....................    fatclose(&stream); 
566A:  MOVLW  05
566C:  MOVLB  5
566E:  MOVWF  xEC
5670:  MOVLW  68
5672:  MOVWF  xEB
5674:  MOVLB  0
5676:  CALL   38CA
.................... } 
567A:  RETLW  00
....................  
.................... /* 
.................... Summary: Formats the media to a specified size. 
.................... Param: The size of the media, in kB, in string form. 
.................... Returns: None. 
.................... Example Usage: /> format 524288 (format a 512MB card) 
.................... */ 
.................... void FormatMedia(char *mediaSize) 
.................... { 
....................    int32 size; 
....................     
....................    size = atoi32(mediaSize); 
*
6572:  MOVFF  566,56C
6576:  MOVFF  565,56B
657A:  GOTO   5C5E
657E:  MOVFF  03,56A
6582:  MOVFF  02,569
6586:  MOVFF  01,568
658A:  MOVFF  00,567
....................     
....................    printf("\r\nFormatting media (size=%LU): ", size); 
658E:  MOVLW  52
6590:  MOVWF  FF6
6592:  MOVLW  02
6594:  MOVWF  FF7
6596:  MOVLW  19
6598:  MOVLB  5
659A:  MOVWF  xC5
659C:  MOVLB  0
659E:  CALL   1790
65A2:  MOVLW  41
65A4:  MOVWF  FE9
65A6:  MOVFF  56A,56E
65AA:  MOVFF  569,56D
65AE:  MOVFF  568,56C
65B2:  MOVFF  567,56B
65B6:  BRA    5F00
65B8:  MOVLW  29
65BA:  BTFSS  F9E.4
65BC:  BRA    65BA
65BE:  MOVWF  FAD
65C0:  MOVLW  3A
65C2:  BTFSS  F9E.4
65C4:  BRA    65C2
65C6:  MOVWF  FAD
65C8:  MOVLW  20
65CA:  BTFSS  F9E.4
65CC:  BRA    65CA
65CE:  MOVWF  FAD
....................    
....................    if(format(size) != GOODEC) 
65D0:  MOVFF  56A,56E
65D4:  MOVFF  569,56D
65D8:  MOVFF  568,56C
65DC:  MOVFF  567,56B
65E0:  BRA    6036
65E2:  MOVF   01,F
65E4:  BZ    65F4
....................    { 
....................       printf("Error formatting media"); 
65E6:  MOVLW  72
65E8:  MOVWF  FF6
65EA:  MOVLW  02
65EC:  MOVWF  FF7
65EE:  CALL   1272
....................       return; 
65F2:  BRA    6604
....................    } 
....................    printf("OK"); 
65F4:  MOVLW  4F
65F6:  BTFSS  F9E.4
65F8:  BRA    65F6
65FA:  MOVWF  FAD
65FC:  MOVLW  4B
65FE:  BTFSS  F9E.4
6600:  BRA    65FE
6602:  MOVWF  FAD
.................... } 
6604:  GOTO   6AF0 (RETURN)
....................  
.................... /* 
.................... Summary: Shows a help prompt. 
.................... Param: None. 
.................... Returns: None. 
.................... Example Usage: /> help  
.................... */ 
.................... void ShowHelp() 
.................... { 
....................    printf("\r\nFAT Shell Help"); 
6608:  MOVLW  8A
660A:  MOVWF  FF6
660C:  MOVLW  02
660E:  MOVWF  FF7
6610:  CALL   1272
....................    printf("\r\n del filename --- Deletes the file"); 
6614:  MOVLW  9C
6616:  MOVWF  FF6
6618:  MOVLW  02
661A:  MOVWF  FF7
661C:  CALL   1272
....................    printf("\r\n make filename --- Creates an empty file"); 
6620:  MOVLW  C2
6622:  MOVWF  FF6
6624:  MOVLW  02
6626:  MOVWF  FF7
6628:  CALL   1272
....................    printf("\r\n append filename string --- Appends string to the end of the file"); 
662C:  MOVLW  EE
662E:  MOVWF  FF6
6630:  MOVLW  02
6632:  MOVWF  FF7
6634:  CALL   1272
....................    printf("\r\n cd dir --- Change the working directory"); 
6638:  MOVLW  32
663A:  MOVWF  FF6
663C:  MOVLW  03
663E:  MOVWF  FF7
6640:  CALL   1272
....................    printf("\r\n dir --- Shows the contents of the directory"); 
6644:  MOVLW  5E
6646:  MOVWF  FF6
6648:  MOVLW  03
664A:  MOVWF  FF7
664C:  CALL   1272
....................    printf("\r\n cat filename --- Displays content of file"); 
6650:  MOVLW  8E
6652:  MOVWF  FF6
6654:  MOVLW  03
6656:  MOVWF  FF7
6658:  CALL   1272
....................    printf("\r\n tail filename --- Displays the last 80 characters of file"); 
665C:  MOVLW  BC
665E:  MOVWF  FF6
6660:  MOVLW  03
6662:  MOVWF  FF7
6664:  CALL   1272
....................    printf("\r\n mkdir dir --- Create a directory"); 
6668:  MOVLW  FA
666A:  MOVWF  FF6
666C:  MOVLW  03
666E:  MOVWF  FF7
6670:  CALL   1272
....................    printf("\r\n rmdir dir --- Deletes the directory"); 
6674:  MOVLW  1E
6676:  MOVWF  FF6
6678:  MOVLW  04
667A:  MOVWF  FF7
667C:  CALL   1272
....................    printf("\r\n format size --- Format card.  (Example: 'format 5524288' formats a 512MB card)"); 
6680:  MOVLW  46
6682:  MOVWF  FF6
6684:  MOVLW  04
6686:  MOVWF  FF7
6688:  CALL   1272
....................    printf("\r\n help\tYou are here"); 
668C:  MOVLW  98
668E:  MOVWF  FF6
6690:  MOVLW  04
6692:  MOVWF  FF7
6694:  CALL   1272
....................    printf("\r\n\n Put a parameter in quotes if it has spaces"); 
6698:  MOVLW  AE
669A:  MOVWF  FF6
669C:  MOVLW  04
669E:  MOVWF  FF7
66A0:  CALL   1272
.................... } 
66A4:  GOTO   6AF0 (RETURN)
....................  
.................... char * GetCMD(char *in) 
.................... { 
....................    char tokens[]=" \r\n"; 
*
14CA:  MOVLW  20
14CC:  MOVLB  5
14CE:  MOVWF  x67
14D0:  MOVLW  0D
14D2:  MOVWF  x68
14D4:  MOVLW  0A
14D6:  MOVWF  x69
14D8:  CLRF   x6A
....................    return(strtok(in,tokens)); 
14DA:  MOVFF  566,572
14DE:  MOVFF  565,571
14E2:  MOVLW  05
14E4:  MOVWF  x74
14E6:  MOVLW  67
14E8:  MOVWF  x73
14EA:  MOVLB  0
14EC:  RCALL  141A
14EE:  MOVF   02,W
.................... } 
14F0:  GOTO   68E4 (RETURN)
....................  
.................... char * GetOption(char *in) 
.................... { 
....................    char tokensSpace[]=" \r\n"; 
*
152E:  MOVLW  20
1530:  MOVLB  5
1532:  MOVWF  x69
1534:  MOVLW  0D
1536:  MOVWF  x6A
1538:  MOVLW  0A
153A:  MOVWF  x6B
153C:  CLRF   x6C
....................    char tokensQuote[]="\"\r\n"; 
153E:  MOVLW  22
1540:  MOVWF  x6D
1542:  MOVLW  0D
1544:  MOVWF  x6E
1546:  MOVLW  0A
1548:  MOVWF  x6F
154A:  CLRF   x70
....................     
....................    //trim leading spaces 
....................    while (*in==' ') 
....................       in++; 
154C:  MOVFF  568,03
1550:  MOVFF  567,FE9
1554:  MOVFF  568,FEA
1558:  MOVF   FEF,W
155A:  SUBLW  20
155C:  BNZ   1566
155E:  INCF   x67,F
1560:  BTFSC  FD8.2
1562:  INCF   x68,F
1564:  BRA    154C
....................     
....................    //if first char is a quote, then end token on a quote.  ELSE end token on a space 
....................    if (*in == '\"') 
1566:  MOVFF  568,03
156A:  MOVFF  567,FE9
156E:  MOVFF  568,FEA
1572:  MOVF   FEF,W
1574:  SUBLW  22
1576:  BNZ   1594
....................       return(strtok(in,tokensQuote)); 
1578:  MOVFF  568,572
157C:  MOVFF  567,571
1580:  MOVLW  05
1582:  MOVWF  x74
1584:  MOVLW  6D
1586:  MOVWF  x73
1588:  MOVLB  0
158A:  RCALL  141A
158C:  MOVF   02,W
158E:  BRA    15AC
....................    else 
1590:  BRA    15AC
1592:  MOVLB  5
....................       return(strtok(in,tokensSpace)); 
1594:  MOVFF  568,572
1598:  MOVFF  567,571
159C:  MOVLW  05
159E:  MOVWF  x74
15A0:  MOVLW  69
15A2:  MOVWF  x73
15A4:  MOVLB  0
15A6:  RCALL  141A
15A8:  MOVF   02,W
15AA:  BRA    15AC
.................... } 
15AC:  RETLW  00
....................  
.................... void main(void) 
.................... { 
*
66A8:  CLRF   FF8
66AA:  BCF    FD0.7
66AC:  CLRF   FEA
66AE:  CLRF   FE9
66B0:  BSF    FB8.3
66B2:  MOVLW  08
66B4:  MOVWF  FAF
66B6:  MOVLW  02
66B8:  MOVWF  FB0
66BA:  MOVLW  A6
66BC:  MOVWF  FAC
66BE:  MOVLW  90
66C0:  MOVWF  FAB
66C2:  BCF    F8C.0
66C4:  MOVF   FC1,W
66C6:  ANDLW  C0
66C8:  IORLW  0F
66CA:  MOVWF  FC1
66CC:  MOVLW  07
66CE:  MOVWF  FB4
66D0:  CLRF   04
66D2:  CLRF   05
66D4:  CLRF   06
66D6:  MOVLB  2
66D8:  CLRF   x28
66DA:  CLRF   x29
66DC:  MOVLW  2F
66DE:  MOVWF  x2A
66E0:  CLRF   x2B
66E2:  MOVLW  64
66E4:  MOVWF  xF2
66E6:  MOVLW  65
66E8:  MOVWF  xF3
66EA:  MOVLW  6C
66EC:  MOVWF  xF4
66EE:  CLRF   xF5
66F0:  CLRF   xF6
66F2:  CLRF   xF7
66F4:  CLRF   xF8
66F6:  CLRF   xF9
66F8:  CLRF   xFA
66FA:  CLRF   xFB
66FC:  MOVLW  6D
66FE:  MOVWF  xFC
6700:  MOVLW  61
6702:  MOVWF  xFD
6704:  MOVLW  6B
6706:  MOVWF  xFE
6708:  MOVLW  65
670A:  MOVWF  xFF
670C:  MOVLB  3
670E:  CLRF   x00
6710:  CLRF   x01
6712:  CLRF   x02
6714:  CLRF   x03
6716:  CLRF   x04
6718:  CLRF   x05
671A:  MOVLW  61
671C:  MOVWF  x06
671E:  MOVLW  70
6720:  MOVWF  x07
6722:  MOVWF  x08
6724:  MOVLW  65
6726:  MOVWF  x09
6728:  MOVLW  6E
672A:  MOVWF  x0A
672C:  MOVLW  64
672E:  MOVWF  x0B
6730:  CLRF   x0C
6732:  CLRF   x0D
6734:  CLRF   x0E
6736:  CLRF   x0F
6738:  MOVLW  63
673A:  MOVWF  x10
673C:  MOVLW  64
673E:  MOVWF  x11
6740:  CLRF   x12
6742:  CLRF   x13
6744:  CLRF   x14
6746:  CLRF   x15
6748:  CLRF   x16
674A:  CLRF   x17
674C:  CLRF   x18
674E:  CLRF   x19
6750:  MOVWF  x1A
6752:  MOVLW  69
6754:  MOVWF  x1B
6756:  MOVLW  72
6758:  MOVWF  x1C
675A:  CLRF   x1D
675C:  CLRF   x1E
675E:  CLRF   x1F
6760:  CLRF   x20
6762:  CLRF   x21
6764:  CLRF   x22
6766:  CLRF   x23
6768:  MOVLW  63
676A:  MOVWF  x24
676C:  MOVLW  61
676E:  MOVWF  x25
6770:  MOVLW  74
6772:  MOVWF  x26
6774:  CLRF   x27
6776:  CLRF   x28
6778:  CLRF   x29
677A:  CLRF   x2A
677C:  CLRF   x2B
677E:  CLRF   x2C
6780:  CLRF   x2D
6782:  MOVWF  x2E
6784:  MOVLW  61
6786:  MOVWF  x2F
6788:  MOVLW  69
678A:  MOVWF  x30
678C:  MOVLW  6C
678E:  MOVWF  x31
6790:  CLRF   x32
6792:  CLRF   x33
6794:  CLRF   x34
6796:  CLRF   x35
6798:  CLRF   x36
679A:  CLRF   x37
679C:  MOVLW  6D
679E:  MOVWF  x38
67A0:  MOVLW  6B
67A2:  MOVWF  x39
67A4:  MOVLW  64
67A6:  MOVWF  x3A
67A8:  MOVLW  69
67AA:  MOVWF  x3B
67AC:  MOVLW  72
67AE:  MOVWF  x3C
67B0:  CLRF   x3D
67B2:  CLRF   x3E
67B4:  CLRF   x3F
67B6:  CLRF   x40
67B8:  CLRF   x41
67BA:  MOVWF  x42
67BC:  MOVLW  6D
67BE:  MOVWF  x43
67C0:  MOVLW  64
67C2:  MOVWF  x44
67C4:  MOVLW  69
67C6:  MOVWF  x45
67C8:  MOVLW  72
67CA:  MOVWF  x46
67CC:  CLRF   x47
67CE:  CLRF   x48
67D0:  CLRF   x49
67D2:  CLRF   x4A
67D4:  CLRF   x4B
67D6:  MOVLW  66
67D8:  MOVWF  x4C
67DA:  MOVLW  6F
67DC:  MOVWF  x4D
67DE:  MOVLW  72
67E0:  MOVWF  x4E
67E2:  MOVLW  6D
67E4:  MOVWF  x4F
67E6:  MOVLW  61
67E8:  MOVWF  x50
67EA:  MOVLW  74
67EC:  MOVWF  x51
67EE:  CLRF   x52
67F0:  CLRF   x53
67F2:  CLRF   x54
67F4:  CLRF   x55
67F6:  MOVLW  68
67F8:  MOVWF  x56
67FA:  MOVLW  65
67FC:  MOVWF  x57
67FE:  MOVLW  6C
6800:  MOVWF  x58
6802:  MOVLW  70
6804:  MOVWF  x59
6806:  CLRF   x5A
....................    char buffer[255]; 
....................    char opt_buffer[255]; 
....................    char *cmd, *option1, *option2; 
....................     
....................    int i;   // pointer to the buffer 
....................  
....................    // initialize the FAT 
....................    //  keep in mind that this will automagically initialize the media 
....................    i = fat_init(); 
6808:  MOVLB  0
680A:  CALL   0F64
680E:  MOVFF  01,564
....................    if (i) 
6812:  MOVLB  5
6814:  MOVF   x64,F
6816:  BZ    6828
....................       printf("\r\n\nERROR INITIALIZING FAT\r\n\n"); 
6818:  MOVLW  DE
681A:  MOVWF  FF6
681C:  MOVLW  04
681E:  MOVWF  FF7
6820:  MOVLB  0
6822:  CALL   1272
6826:  MOVLB  5
....................      
....................    // main loop 
....................    while(TRUE) 
....................    { 
....................       i = 0; 
6828:  CLRF   x64
....................        
....................       DisplayPrompt(); 
682A:  MOVLB  0
682C:  GOTO   12BA
....................        
....................       do 
....................       { 
....................          buffer[i] = getch(); 
6830:  CLRF   03
6832:  MOVLB  5
6834:  MOVF   x64,W
6836:  ADDLW  60
6838:  MOVWF  FE9
683A:  MOVLW  03
683C:  ADDWFC 03,W
683E:  MOVWF  FEA
6840:  MOVFF  FEA,568
6844:  MOVFF  FE9,567
6848:  MOVLB  0
684A:  GOTO   12F0
684E:  MOVFF  568,FEA
6852:  MOVFF  567,FE9
6856:  MOVFF  01,FEF
....................           
....................          // check for a backspace 
....................          if(buffer[i] != 8) 
685A:  CLRF   03
685C:  MOVLB  5
685E:  MOVF   x64,W
6860:  ADDLW  60
6862:  MOVWF  FE9
6864:  MOVLW  03
6866:  ADDWFC 03,W
6868:  MOVWF  FEA
686A:  MOVF   FEF,W
686C:  SUBLW  08
686E:  BZ    688E
....................          { 
....................             printf("%c", buffer[i]); 
6870:  CLRF   03
6872:  MOVF   x64,W
6874:  ADDLW  60
6876:  MOVWF  FE9
6878:  MOVLW  03
687A:  ADDWFC 03,W
687C:  MOVWF  FEA
687E:  MOVFF  FEF,565
6882:  MOVF   x65,W
6884:  BTFSS  F9E.4
6886:  BRA    6884
6888:  MOVWF  FAD
....................             i++; 
688A:  INCF   x64,F
....................          } 
....................          else if(i > 0) 
688C:  BRA    68AA
688E:  MOVF   x64,F
6890:  BZ    68AA
....................          { 
....................             // delete the last character 
....................             i--; 
6892:  DECF   x64,F
....................             putc(8); 
6894:  MOVLW  08
6896:  MOVLB  0
6898:  CALL   1308
....................             putc(' '); 
689C:  MOVLW  20
689E:  CALL   1308
....................             putc(8); 
68A2:  MOVLW  08
68A4:  CALL   1308
68A8:  MOVLB  5
....................          } 
....................          buffer[i] = '\0'; 
68AA:  CLRF   03
68AC:  MOVF   x64,W
68AE:  ADDLW  60
68B0:  MOVWF  FE9
68B2:  MOVLW  03
68B4:  ADDWFC 03,W
68B6:  MOVWF  FEA
68B8:  CLRF   FEF
....................       } while(buffer[i - 1] != '\r'); 
68BA:  MOVLW  01
68BC:  SUBWF  x64,W
68BE:  CLRF   03
68C0:  ADDLW  60
68C2:  MOVWF  FE9
68C4:  MOVLW  03
68C6:  ADDWFC 03,W
68C8:  MOVWF  FEA
68CA:  MOVF   FEF,W
68CC:  SUBLW  0D
68CE:  BTFSC  FD8.2
68D0:  BRA    68D6
68D2:  MOVLB  0
68D4:  BRA    6830
....................        
....................       // parse the command and options 
....................       cmd = GetCMD(buffer); 
68D6:  MOVLW  03
68D8:  MOVWF  x66
68DA:  MOVLW  60
68DC:  MOVWF  x65
68DE:  MOVLB  0
68E0:  GOTO   14CA
68E4:  MOVFF  02,55F
68E8:  MOVFF  01,55E
....................       option1 = GetOption(cmd + strlen(cmd) + 1); 
68EC:  MOVFF  55F,65E
68F0:  MOVFF  55E,65D
68F4:  CALL   14F4
68F8:  MOVF   01,W
68FA:  MOVLB  5
68FC:  ADDWF  x5E,W
68FE:  MOVWF  x65
6900:  MOVLW  00
6902:  ADDWFC x5F,W
6904:  MOVWF  x66
6906:  MOVLW  01
6908:  ADDWF  x65,F
690A:  MOVLW  00
690C:  ADDWFC x66,F
690E:  MOVFF  566,568
6912:  MOVFF  565,567
6916:  MOVLB  0
6918:  CALL   152E
691C:  MOVFF  02,561
6920:  MOVFF  01,560
....................       option2 = GetOption(option1 + strlen(option1) + 1); 
6924:  MOVFF  561,65E
6928:  MOVFF  560,65D
692C:  CALL   14F4
6930:  MOVF   01,W
6932:  MOVLB  5
6934:  ADDWF  x60,W
6936:  MOVWF  x65
6938:  MOVLW  00
693A:  ADDWFC x61,W
693C:  MOVWF  x66
693E:  MOVLW  01
6940:  ADDWF  x65,F
6942:  MOVLW  00
6944:  ADDWFC x66,F
6946:  MOVFF  566,568
694A:  MOVFF  565,567
694E:  MOVLB  0
6950:  CALL   152E
6954:  MOVFF  02,563
6958:  MOVFF  01,562
....................  
....................       //if option1 starts with a '/', that means the file in the option includes 
....................       //the full path to the file.  if the file doesn't start with a '/', the  
....................       //current working directory must be added. 
....................       if (option1 && (option1[0]=='/')) 
695C:  MOVLB  5
695E:  MOVF   x60,W
6960:  IORWF  x61,W
6962:  BZ    698C
6964:  MOVFF  560,FE9
6968:  MOVFF  561,FEA
696C:  MOVF   FEF,W
696E:  SUBLW  2F
6970:  BNZ   698C
....................       { 
....................          //option1 is a full path 
....................          strcpy(opt_buffer, option1); 
6972:  MOVLW  04
6974:  MOVWF  FEA
6976:  MOVLW  5F
6978:  MOVWF  FE9
697A:  MOVFF  561,FE2
697E:  MOVFF  560,FE1
6982:  MOVF   FE7,F
6984:  MOVFF  FE6,FEE
6988:  BNZ   6982
....................       } 
....................       else if (option1) 
698A:  BRA    69C2
698C:  MOVF   x60,W
698E:  IORWF  x61,W
6990:  BZ    69C2
....................       { 
....................          // tack on the current working directory to option1 
....................          strcpy(opt_buffer, g_CWD); 
6992:  MOVLW  04
6994:  MOVWF  FEA
6996:  MOVLW  5F
6998:  MOVWF  FE9
699A:  MOVLW  02
699C:  MOVWF  FE2
699E:  MOVLW  2A
69A0:  MOVWF  FE1
69A2:  MOVF   FE7,F
69A4:  MOVFF  FE6,FEE
69A8:  BNZ   69A2
....................          strcat(opt_buffer, option1); 
69AA:  MOVLW  04
69AC:  MOVWF  xA8
69AE:  MOVLW  5F
69B0:  MOVWF  xA7
69B2:  MOVFF  561,5AA
69B6:  MOVFF  560,5A9
69BA:  MOVLB  0
69BC:  CALL   15AE
69C0:  MOVLB  5
....................       }          
....................        
....................       if (cmd) 
69C2:  MOVF   x5E,W
69C4:  IORWF  x5F,W
69C6:  BTFSC  FD8.2
69C8:  BRA    6AF2
....................       { 
....................          switch(FindCommand(cmd)) 
....................          { 
69CA:  MOVFF  55F,566
69CE:  MOVFF  55E,565
69D2:  MOVLB  0
69D4:  GOTO   172A
69D8:  MOVF   01,W
69DA:  BZ    6A06
69DC:  XORLW  01
69DE:  BZ    6A18
69E0:  XORLW  03
69E2:  BZ    6A2A
69E4:  XORLW  01
69E6:  BZ    6A44
69E8:  XORLW  07
69EA:  BZ    6A56
69EC:  XORLW  01
69EE:  BZ    6A68
69F0:  XORLW  03
69F2:  BZ    6A7C
69F4:  XORLW  01
69F6:  BZ    6A92
69F8:  XORLW  0F
69FA:  BZ    6AA4
69FC:  XORLW  01
69FE:  BZ    6AB6
6A00:  XORLW  03
6A02:  BZ    6AC2
6A04:  BRA    6AC6
....................             case 0:  //del 
....................                DeleteFile(opt_buffer); 
6A06:  MOVLW  04
6A08:  MOVLB  5
6A0A:  MOVWF  x66
6A0C:  MOVLW  5F
6A0E:  MOVWF  x65
6A10:  MOVLB  0
6A12:  GOTO   3DFC
....................                break; 
6A16:  BRA    6AF0
....................              
....................             case 1:  //make 
....................                MakeFile(opt_buffer); 
6A18:  MOVLW  04
6A1A:  MOVLB  5
6A1C:  MOVWF  x66
6A1E:  MOVLW  5F
6A20:  MOVWF  x65
6A22:  MOVLB  0
6A24:  GOTO   4B42
....................                break; 
6A28:  BRA    6AF0
....................              
....................             case 2:  //append 
....................                AppendFile(opt_buffer, option2); 
6A2A:  MOVLW  04
6A2C:  MOVLB  5
6A2E:  MOVWF  x66
6A30:  MOVLW  5F
6A32:  MOVWF  x65
6A34:  MOVFF  563,568
6A38:  MOVFF  562,567
6A3C:  MOVLB  0
6A3E:  GOTO   4C00
....................                break; 
6A42:  BRA    6AF0
....................              
....................             case 3:  //change directory 
....................                ChangeDirectory(opt_buffer); 
6A44:  MOVLW  04
6A46:  MOVLB  5
6A48:  MOVWF  x66
6A4A:  MOVLW  5F
6A4C:  MOVWF  x65
6A4E:  MOVLB  0
6A50:  GOTO   4D8C
....................                break; 
6A54:  BRA    6AF0
....................              
....................             case 4:  //show directory contents 
....................                DisplayDirectory(g_CWD); 
6A56:  MOVLW  02
6A58:  MOVLB  5
6A5A:  MOVWF  x66
6A5C:  MOVLW  2A
6A5E:  MOVWF  x65
6A60:  MOVLB  0
6A62:  GOTO   526E
....................                break; 
6A66:  BRA    6AF0
....................                 
....................             case 5:  //cat, display file 
....................                PrintFile(opt_buffer, CAT_FROM_START); 
6A68:  MOVLW  04
6A6A:  MOVLB  5
6A6C:  MOVWF  x66
6A6E:  MOVLW  5F
6A70:  MOVWF  x65
6A72:  CLRF   x67
6A74:  MOVLB  0
6A76:  CALL   55F4
....................                break; 
6A7A:  BRA    6AF0
....................              
....................             case 6:  //tail, display last 80 charachters 
....................                PrintFile(opt_buffer, CAT_FROM_END); 
6A7C:  MOVLW  04
6A7E:  MOVLB  5
6A80:  MOVWF  x66
6A82:  MOVLW  5F
6A84:  MOVWF  x65
6A86:  MOVLW  01
6A88:  MOVWF  x67
6A8A:  MOVLB  0
6A8C:  CALL   55F4
....................                break; 
6A90:  BRA    6AF0
....................              
....................             case 7: //mkdir, make a directory 
....................                MakeDirectory(opt_buffer); 
6A92:  MOVLW  04
6A94:  MOVLB  5
6A96:  MOVWF  x66
6A98:  MOVLW  5F
6A9A:  MOVWF  x65
6A9C:  MOVLB  0
6A9E:  GOTO   5A86
....................                break; 
6AA2:  BRA    6AF0
....................  
....................             case 8: //rmdir, make a directory 
....................                RemoveDirectory(opt_buffer); 
6AA4:  MOVLW  04
6AA6:  MOVLB  5
6AA8:  MOVWF  x66
6AAA:  MOVLW  5F
6AAC:  MOVWF  x65
6AAE:  MOVLB  0
6AB0:  GOTO   5BB4
....................                break; 
6AB4:  BRA    6AF0
....................  
....................             case 9: //format, format the card 
....................                FormatMedia(option1); 
6AB6:  MOVFF  561,566
6ABA:  MOVFF  560,565
6ABE:  BRA    6572
....................                break; 
6AC0:  BRA    6AF0
....................  
....................             case 10: //help, display help 
....................                ShowHelp(); 
6AC2:  BRA    6608
....................                break; 
6AC4:  BRA    6AF0
....................  
....................             default: 
....................                printf("\r\nUnkown Command '%s'", cmd); 
6AC6:  MOVLW  FC
6AC8:  MOVWF  FF6
6ACA:  MOVLW  04
6ACC:  MOVWF  FF7
6ACE:  MOVLW  12
6AD0:  MOVLB  5
6AD2:  MOVWF  xC5
6AD4:  MOVLB  0
6AD6:  CALL   1790
6ADA:  MOVFF  55F,FEA
6ADE:  MOVFF  55E,FE9
6AE2:  CALL   1294
6AE6:  MOVLW  27
6AE8:  BTFSS  F9E.4
6AEA:  BRA    6AE8
6AEC:  MOVWF  FAD
....................                break; 
6AEE:  BRA    6AF0
6AF0:  MOVLB  5
....................          } 
....................       } 
....................    } 
6AF2:  BRA    6828
.................... } 
....................  
6AF4:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   IESO FCMEN HS PLL12 CPUDIV4 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
