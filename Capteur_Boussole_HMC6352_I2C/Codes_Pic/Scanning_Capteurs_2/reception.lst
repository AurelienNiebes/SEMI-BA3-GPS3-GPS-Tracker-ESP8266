CCS PCM C Compiler, Version 4.038, 11770               10-oct.-11 15:56

               Filename: reception.lst

               ROM used: 2605 words (32%)
                         Largest free fragment is 2048
               RAM used: 66 (18%) at main() level
                         122 (33%) worst case
               Stack:    6 worst case (5 in main + 1 for interrupts)

*
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   5E8
0004:  NOP
0005:  MOVWF  7F
0006:  SWAPF  03,W
0007:  CLRF   03
0008:  MOVWF  21
0009:  MOVF   0A,W
000A:  MOVWF  20
000B:  CLRF   0A
000C:  MOVF   04,W
000D:  MOVWF  22
000E:  MOVF   77,W
000F:  MOVWF  23
0010:  MOVF   78,W
0011:  MOVWF  24
0012:  MOVF   79,W
0013:  MOVWF  25
0014:  MOVF   7A,W
0015:  MOVWF  26
0016:  MOVF   7B,W
0017:  MOVWF  27
0018:  BCF    03.7
0019:  BCF    03.5
001A:  MOVLW  8C
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  0C.5
001F:  GOTO   033
0020:  MOVF   22,W
0021:  MOVWF  04
0022:  MOVF   23,W
0023:  MOVWF  77
0024:  MOVF   24,W
0025:  MOVWF  78
0026:  MOVF   25,W
0027:  MOVWF  79
0028:  MOVF   26,W
0029:  MOVWF  7A
002A:  MOVF   27,W
002B:  MOVWF  7B
002C:  MOVF   20,W
002D:  MOVWF  0A
002E:  SWAPF  21,W
002F:  MOVWF  03
0030:  SWAPF  7F,F
0031:  SWAPF  7F,W
0032:  RETFIE
0033:  BCF    0A.3
0034:  BCF    0A.4
0035:  GOTO   156
.................... //----------------------------------------------------- 
.................... //------------ Programme Receip data capt ------------- 
.................... //----------------------------------------------------- 
.................... //-- Projet: 
.................... //-- Date:   10-10-2011 
.................... //-- Progr:  Capture data in serie 
.................... //-- Auteur: Binon Daniel (UMONS) 
.................... //----------------------------------------------------- 
.................... //-- Réception des données envoyées par l'émmetteur.  
.................... //-- Ces données sont codées selon un format définit  
.................... //-- plus haut (voir fichier "887_sv3_rser.h") 
.................... //-- on récupère celles-ci et on les affichent sur LCD 
.................... //--  
.................... //--  
.................... //--  
.................... //--  
.................... //-----------------------------------------------------  
....................  
.................... #include "887_sv3_rser.h" 
.................... #include <16F887.h> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
060D:  BCF    03.5
060E:  BCF    03.6
060F:  CLRF   28
0610:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT, HS, NOPUT, NOPROTECT, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NODEBUG 
.................... #use delay(clock=20M) 
*
01A3:  MOVLW  76
01A4:  MOVWF  04
01A5:  BCF    03.7
01A6:  MOVF   00,W
01A7:  BTFSC  03.2
01A8:  GOTO   1B6
01A9:  MOVLW  06
01AA:  MOVWF  78
01AB:  CLRF   77
01AC:  DECFSZ 77,F
01AD:  GOTO   1AC
01AE:  DECFSZ 78,F
01AF:  GOTO   1AB
01B0:  MOVLW  7B
01B1:  MOVWF  77
01B2:  DECFSZ 77,F
01B3:  GOTO   1B2
01B4:  DECFSZ 00,F
01B5:  GOTO   1A9
01B6:  RETLW  00
.................... #use rs232(baud=57600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=RS232) 
....................  
.................... #build(reset=0x1, interrupt=0x5)          // Necessary for Bootloader 
.................... //#ORG 0x1F00,0x1FFF {}   
....................  
.................... #include "db_lcd.c" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... ////                 Driver for common LCD modules                      //// 
.................... ////                                                                    //// 
.................... ////  lcd_init()   Must be called before any other function.            //// 
.................... ////                                                                    //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.      //// 
.................... ////                     The following have special meaning:            //// 
.................... ////                      \f  Clear display                             //// 
.................... ////                      \n  Go to start of second line                //// 
.................... ////                      \b  Move back one position                    //// 
.................... ////                                                                    //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)     //// 
.................... ////                                                                    //// 
.................... ////                                                                    //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  not use 
.................... //     D1  not use 
.................... //     D2  rs 
.................... //     D3  enable 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... struct lcd_pin_map { 
.................... 		boolean unused1;							// Bit 7 not use for LCD 
.................... 		boolean unused2;							// Bit 6 not use for LCD 
.................... 		boolean rs;									// Bit 5 use for RS (LCD) 
.................... 		boolean en;									// Bit 7 use for Enable LCD 
.................... 		int data : 4;								// Bit 0 to 3 --> four bits LCD Bus 
.................... } lcd;  
....................  
....................  
.................... #byte lcd = 6 
.................... 								// The bus LCD is Port B 
.................... #define set_tris_lcd(x) set_tris_b(x) 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; 
....................  
....................  
.................... byte CONST LCD_INIT_STRING[4] = {0x20,0x28,0x06,0x0d};  // Table for init LCD 
....................  
....................  
.................... void lcd_send_nibble(byte n); 
.................... void lcd_send_byte(byte cmd, byte n); 
.................... void lcd_char(char c); 
.................... void lcd_init(); 
.................... void lcd_gotoxy(byte colonne, byte ligne); 
.................... void lcd_cursor(boolean x); 
.................... void lcd_blink(boolean x); 
.................... void lcd_printf(char* message); 
....................  
.................... //---------------------Send Half Byte------------------ 
.................... void lcd_send_nibble(byte n) { 
.................... 		lcd.data = n;								// Place byte on bus 
*
0172:  BSF    03.5
0173:  SWAPF  23,W
0174:  ANDLW  F0
0175:  MOVWF  77
0176:  MOVLW  0F
0177:  BCF    03.5
0178:  ANDWF  06,W
0179:  IORWF  77,W
017A:  MOVWF  06
.................... 		delay_cycles(1);							// Wait 1 cycle µP 
017B:  NOP
.................... 		lcd.en = 1;									// Enable LCD is Hight 
017C:  BSF    06.3
.................... 		delay_cycles(1);							// Wait 1 cycle µP 
017D:  NOP
.................... 		lcd.en = 0;									// Enable LCD is Low 
017E:  BCF    06.3
.................... } 
017F:  RETLW  00
....................  
.................... //--------------Send byte to LCD------------------------- 
.................... //  If cmd = 0 --> Command 
.................... //  If cmd = 1 --> Char 
.................... // 
.................... void lcd_send_byte(byte cmd, byte n) { 
.................... 		lcd.rs = cmd;								// Rs is 0 to command & 1 to  
0180:  BSF    03.5
0181:  BTFSC  20.0
0182:  GOTO   186
0183:  BCF    03.5
0184:  BCF    06.2
0185:  BSF    03.5
0186:  BTFSS  20.0
0187:  GOTO   18B
0188:  BCF    03.5
0189:  BSF    06.2
018A:  BSF    03.5
.................... 		lcd.en = 0;									// enable is low 
018B:  BCF    03.5
018C:  BCF    06.3
.................... 		lcd_send_nibble(n >> 4);					// Rotate right 4 time & send 
018D:  BSF    03.5
018E:  SWAPF  21,W
018F:  MOVWF  22
0190:  MOVLW  0F
0191:  ANDWF  22,F
0192:  MOVF   22,W
0193:  MOVWF  23
0194:  BCF    03.5
0195:  CALL   172
.................... 		lcd_send_nibble(n & 0xf);					// mask the half byte 
0196:  BSF    03.5
0197:  MOVF   21,W
0198:  ANDLW  0F
0199:  MOVWF  22
019A:  MOVWF  23
019B:  BCF    03.5
019C:  CALL   172
.................... 		delay_us(39); 
019D:  MOVLW  40
019E:  MOVWF  77
019F:  DECFSZ 77,F
01A0:  GOTO   19F
01A1:  GOTO   1A2
.................... } 
01A2:  RETLW  00
....................  
.................... //------------------------LCD CHAR------------------------ 
.................... // Send the char to the Display LCD 
.................... // Send too the special command to the LCD 
.................... void lcd_char(char c) { 
.................... 	switch (c) { 
*
01B7:  MOVF   75,W
01B8:  XORLW  0C
01B9:  BTFSC  03.2
01BA:  GOTO   1C5
01BB:  XORLW  06
01BC:  BTFSC  03.2
01BD:  GOTO   1D3
01BE:  XORLW  07
01BF:  BTFSC  03.2
01C0:  GOTO   20E
01C1:  XORLW  05
01C2:  BTFSC  03.2
01C3:  GOTO   215
01C4:  GOTO   21C
.................... 		case '\f' : lcd_send_byte(0,1);				// Clear Display + Home Cursor 
01C5:  BSF    03.5
01C6:  CLRF   20
01C7:  MOVLW  01
01C8:  MOVWF  21
01C9:  BCF    03.5
01CA:  CALL   180
.................... 					delay_ms(2);	break; 
01CB:  MOVLW  02
01CC:  MOVWF  76
01CD:  CALL   1A3
01CE:  GOTO   224
.................... //		case '\h' : lcd_send_byte(0,3);				// Juste Home Cursor 
.................... 					delay_ms(2);	break; 
01CF:  MOVLW  02
01D0:  MOVWF  76
01D1:  CALL   1A3
01D2:  GOTO   224
.................... 		case '\n'   : lcd_gotoxy(1,2); break;		// Display on X & Y position 
01D3:  MOVLW  01
01D4:  MOVWF  76
01D5:  MOVLW  02
01D6:  MOVWF  7C
*
020D:  GOTO   224
.................... 		case '\r' : lcd_send_byte(0,0x1c); break;	// Display Shift right 
020E:  BSF    03.5
020F:  CLRF   20
0210:  MOVLW  1C
0211:  MOVWF  21
0212:  BCF    03.5
0213:  CALL   180
0214:  GOTO   224
.................... //		case '\l' : lcd_send_byte(0,0x18); break;	// Display Shift left 
.................... 		case '\b' : lcd_send_byte(0,0x10); break;	// Cursor Shift left 
0215:  BSF    03.5
0216:  CLRF   20
0217:  MOVLW  10
0218:  MOVWF  21
0219:  BCF    03.5
021A:  CALL   180
021B:  GOTO   224
.................... 		default	  : lcd_send_byte(1,c); break;		// Send char to the display 
021C:  MOVLW  01
021D:  BSF    03.5
021E:  MOVWF  20
021F:  MOVF   75,W
0220:  MOVWF  21
0221:  BCF    03.5
0222:  CALL   180
0223:  GOTO   224
.................... 	} 
.................... } 
0224:  RETLW  00
....................  
.................... //------------------------LCD INIT------------------------ 
.................... void lcd_init() { 
.................... 	byte i; 
.................... 	set_tris_lcd(LCD_WRITE);						// Place PortB to Output (LCD Bus) 
*
022A:  MOVLW  00
022B:  BSF    03.5
022C:  MOVWF  06
.................... 	for(i=0;i<=3;++i) { 
022D:  BCF    03.5
022E:  CLRF   5B
022F:  MOVF   5B,W
0230:  SUBLW  03
0231:  BTFSS  03.0
0232:  GOTO   243
.................... 		lcd_send_byte(0,LCD_INIT_STRING[i]);		// Send the Values to Init LCD 
0233:  MOVF   5B,W
0234:  CALL   036
0235:  MOVWF  5C
0236:  BSF    03.5
0237:  CLRF   20
0238:  BCF    03.5
0239:  MOVF   5C,W
023A:  BSF    03.5
023B:  MOVWF  21
023C:  BCF    03.5
023D:  CALL   180
.................... 		delay_ms(2); 
023E:  MOVLW  02
023F:  MOVWF  76
0240:  CALL   1A3
.................... 	} 
0241:  INCF   5B,F
0242:  GOTO   22F
.................... } 
....................  
.................... //------------------------LCD position XY------------------ 
.................... // X = Colonne 
.................... // Y = Line 
.................... void lcd_gotoxy(byte colonne, byte ligne) { 
....................   if (ligne == 1) lcd_send_byte(0,0x80+0x00+colonne-1); //0x80 = instruction Set DDRAM Adresse) + 0x00(=DDRAM Adress de ligne 1) + (colonne- 1) (adresse de la colonne) 
*
01D7:  DECFSZ 7C,W
01D8:  GOTO   1E3
01D9:  MOVLW  80
01DA:  ADDWF  76,W
01DB:  ADDLW  FF
01DC:  MOVWF  7E
01DD:  BSF    03.5
01DE:  CLRF   20
01DF:  MOVF   7E,W
01E0:  MOVWF  21
01E1:  BCF    03.5
01E2:  CALL   180
....................   if (ligne == 2) lcd_send_byte(0,0x80+0x40+colonne-1); //adresse ligne 2 = 0x40 
01E3:  MOVF   7C,W
01E4:  SUBLW  02
01E5:  BTFSS  03.2
01E6:  GOTO   1F1
01E7:  MOVLW  C0
01E8:  ADDWF  76,W
01E9:  ADDLW  FF
01EA:  MOVWF  7E
01EB:  BSF    03.5
01EC:  CLRF   20
01ED:  MOVF   7E,W
01EE:  MOVWF  21
01EF:  BCF    03.5
01F0:  CALL   180
....................   if (ligne == 3) lcd_send_byte(0,0x80+0x14+colonne-1); //adresse ligne 3 = 0x14 
01F1:  MOVF   7C,W
01F2:  SUBLW  03
01F3:  BTFSS  03.2
01F4:  GOTO   1FF
01F5:  MOVLW  94
01F6:  ADDWF  76,W
01F7:  ADDLW  FF
01F8:  MOVWF  7E
01F9:  BSF    03.5
01FA:  CLRF   20
01FB:  MOVF   7E,W
01FC:  MOVWF  21
01FD:  BCF    03.5
01FE:  CALL   180
....................   if (ligne == 4) lcd_send_byte(0,0x80+0x54+colonne-1); //adresse ligne 4 = 0x54 
01FF:  MOVF   7C,W
0200:  SUBLW  04
0201:  BTFSS  03.2
0202:  GOTO   20D
0203:  MOVLW  D4
0204:  ADDWF  76,W
0205:  ADDLW  FF
0206:  MOVWF  7E
0207:  BSF    03.5
0208:  CLRF   20
0209:  MOVF   7E,W
020A:  MOVWF  21
020B:  BCF    03.5
020C:  CALL   180
.................... } 
....................  
.................... //------------------LCD CURSOR  ON/OFF---------------------- 
.................... // x = true --> cursor ON 
.................... // x = false --> cursor OFF 
.................... void lcd_cursor(boolean x) { 
.................... 	if (x == true)   
*
028C:  DECFSZ 5B,W
028D:  GOTO   295
.................... 		lcd_send_byte(0,0x0e); 						// Curseur ON 
028E:  BSF    03.5
028F:  CLRF   20
0290:  MOVLW  0E
0291:  MOVWF  21
0292:  BCF    03.5
0293:  CALL   180
.................... 	else lcd_send_byte(0,0x0c);     				// Curseur OFF 
0294:  GOTO   29B
0295:  BSF    03.5
0296:  CLRF   20
0297:  MOVLW  0C
0298:  MOVWF  21
0299:  BCF    03.5
029A:  CALL   180
.................... } 
.................... //------------------------LCD CURSOR----------------------- 
.................... // x = true --> cursor ON 
.................... // x = false --> cursor OFF 
....................  
.................... void lcd_blink(boolean x) { 
.................... 	if (x == true)  
.................... 		lcd_send_byte(0,0x0f); 						// Curseur ON 
.................... 	else lcd_send_byte(0,0x0e);     				// Curseur OFF 
....................  
.................... } 
....................  
.................... void lcd_printf(char *message)				// Write message to LCD (C string type) 
.................... { 
.................... 	while (*message)								//	Look for end of string 
.................... 		lcd_send_byte(1,*message++);						//	Show and bump 
.................... } 
....................  
....................  
.................... //-------------------------E/S------------------------ 
....................  
.................... #define led PIN_A4 
.................... #define bluethoot PIN_A4 
....................  
.................... //-- Formatage données envoyes sur la sortie serie -- 
.................... //-- format de la trame envoyee: 
.................... //-- +--------------+--------------------+-------------+----------+----------+ 
.................... //-- |-    8bits   -|-       8bits      -|-   8bits   -|-  8bits -|-  8bits -| 
.................... //-- |-ENTETE(0xFF)-|-ADR DEVICE (1byte)-|-Type DEVICE-|-data Lsb-|-data Msb-| 
.................... //-- +--------------+--------------------+-------------+----------+----------+ 
.................... //-- 
....................  
....................  
.................... #define entete 0xFF 
.................... #define adr_inout 0x00 
.................... #define adr_ADC 0x00 
.................... #define adr_acc 0x3A 
.................... #define adr_boussole 0x42 
.................... #define adr_temp 0x90 
.................... #define adr_light 0x46 
.................... #define adr_srf02 0xe0 
....................  
.................... #define typ_inout 0x00				// 1 byte 
.................... #define typ_acc_x 0x01				// 4 bytes 
.................... #define typ_acc_y 0x02				// 4 bytes 
.................... #define typ_acc_z 0x03				// 4 bytes 
.................... #define typ_temp 0x04				// 3 bytes 
.................... #define typ_light 0x05				// 4 bytes 
.................... #define typ_srf02 0x06				// 4 bytes 
.................... #define typ_adc01 0x07				// 2 bytes 
.................... #define typ_boussole 0x0c			// 2 bytes 
....................  
.................... #define BUFFER_SIZE 16								// Buffer maxi de lecture RS232 
.................... #define bkbhit (next_in!=next_out)	 
....................  
....................  
.................... //-------------------------xxx------------------------ 
....................  
.................... BYTE buffer[BUFFER_SIZE]; 
.................... BYTE next_in = 0; 
*
0611:  CLRF   3E
.................... BYTE next_out = 0; 
0612:  CLRF   3F
.................... char varbin[9]; 
.................... byte data[16]; 
.................... boolean flagp; 
....................  
.................... //-------------------------xxx------------------------ 
.................... #int_rda											// interruption serie 
.................... void serial_isr() { 
....................    int t; 
....................  
....................    buffer[next_in]=getc();							// remplissage du buffer 
*
0156:  MOVLW  2E
0157:  ADDWF  3E,W
0158:  MOVWF  04
0159:  BCF    03.7
015A:  BTFSS  0C.5
015B:  GOTO   15A
015C:  MOVF   1A,W
015D:  MOVWF  00
....................    t=next_in; 
015E:  MOVF   3E,W
015F:  BSF    03.5
0160:  MOVWF  37
....................    next_in=(next_in+1) % BUFFER_SIZE; 
0161:  MOVLW  01
0162:  BCF    03.5
0163:  ADDWF  3E,W
0164:  ANDLW  0F
0165:  MOVWF  3E
....................    if(next_in==next_out) 
0166:  MOVF   3F,W
0167:  SUBWF  3E,W
0168:  BTFSS  03.2
0169:  GOTO   16E
....................      next_in=t;           							// Buffer full !! 
016A:  BSF    03.5
016B:  MOVF   37,W
016C:  BCF    03.5
016D:  MOVWF  3E
.................... } 
....................  
.................... //-------------------------fonction buzzer------------------------ 
.................... //permet d'emettre un son dont on peut paramétrer la fréquence et la durée 
016E:  BCF    0C.5
016F:  BCF    0A.3
0170:  BCF    0A.4
0171:  GOTO   020
.................... void beep(int freq, int duree) 
.................... {  
....................    setup_ccp1(CCP_PWM);                   
*
025B:  BCF    5A.2
025C:  MOVF   5A,W
025D:  BSF    03.5
025E:  MOVWF  07
025F:  BCF    03.5
0260:  BCF    07.2
0261:  MOVLW  0C
0262:  MOVWF  17
0263:  BSF    03.5
0264:  CLRF   1B
*
0613:  MOVLW  FF
0614:  MOVWF  5A
....................    set_pwm1_duty(freq/2); 
*
0265:  BCF    03.0
0266:  BCF    03.5
0267:  RRF    5B,W
0268:  MOVWF  5D
0269:  MOVWF  15
....................    setup_timer_2(T2_DIV_BY_16,freq,5);    
026A:  MOVLW  20
026B:  MOVWF  78
026C:  IORLW  06
026D:  MOVWF  12
026E:  MOVF   5B,W
026F:  BSF    03.5
0270:  MOVWF  12
....................    while (duree--) delay_ms(10); 
0271:  BCF    03.5
0272:  MOVF   5C,W
0273:  DECF   5C,F
0274:  XORLW  00
0275:  BTFSC  03.2
0276:  GOTO   27B
0277:  MOVLW  0A
0278:  MOVWF  76
0279:  CALL   1A3
027A:  GOTO   272
....................    setup_ccp1(CCP_OFF); 
027B:  BSF    5A.2
027C:  MOVF   5A,W
027D:  BSF    03.5
027E:  MOVWF  07
027F:  BCF    03.5
0280:  CLRF   17
0281:  BSF    03.5
0282:  CLRF   1B
.................... } 
....................  
.................... //-------------------------xxx------------------------ 
.................... void dec2bin(byte val) {							// decimal to binaire (string) 
.................... 	byte i,x; 
....................  
.................... 	x=0; 
*
0852:  CLRF   6A
.................... 	for (i=7;i>0;i--)  
0853:  MOVLW  07
0854:  MOVWF  69
0855:  MOVF   69,F
0856:  BTFSC  03.2
0857:  GOTO   076
.................... 	{ 
.................... 		if ((val>>i)%2==0) varbin[x]='0'; 
0858:  MOVF   68,W
0859:  MOVWF  77
085A:  MOVF   69,W
085B:  MOVWF  78
085C:  BTFSC  03.2
085D:  GOTO   062
085E:  BCF    03.0
085F:  RRF    77,F
0860:  DECFSZ 78,F
0861:  GOTO   05E
0862:  MOVF   77,W
0863:  ANDLW  01
0864:  BTFSS  03.2
0865:  GOTO   06D
0866:  MOVLW  40
0867:  ADDWF  6A,W
0868:  MOVWF  04
0869:  BCF    03.7
086A:  MOVLW  30
086B:  MOVWF  00
.................... 		else varbin[x]='1'; 
086C:  GOTO   073
086D:  MOVLW  40
086E:  ADDWF  6A,W
086F:  MOVWF  04
0870:  BCF    03.7
0871:  MOVLW  31
0872:  MOVWF  00
.................... 		x++; 
0873:  INCF   6A,F
.................... 	}	 
0874:  DECF   69,F
0875:  GOTO   055
.................... 	if ((val)%2==0) varbin[x]='0'; 
0876:  MOVF   68,W
0877:  ANDLW  01
0878:  BTFSS  03.2
0879:  GOTO   081
087A:  MOVLW  40
087B:  ADDWF  6A,W
087C:  MOVWF  04
087D:  BCF    03.7
087E:  MOVLW  30
087F:  MOVWF  00
.................... 	else varbin[x]='1'; 
0880:  GOTO   087
0881:  MOVLW  40
0882:  ADDWF  6A,W
0883:  MOVWF  04
0884:  BCF    03.7
0885:  MOVLW  31
0886:  MOVWF  00
.................... 	varbin[x+1]='\0'; 
0887:  MOVLW  01
0888:  ADDWF  6A,W
0889:  ADDLW  40
088A:  MOVWF  04
088B:  BCF    03.7
088C:  CLRF   00
.................... } 
....................  
.................... //-------------------------xxx------------------------ 
.................... BYTE bgetc() {										// lecture du buffer serie 
....................    BYTE c; 
....................  
....................    while(!bkbhit) ;									// tant que le buffer n'est pas vide 
*
029E:  MOVF   3F,W
029F:  SUBWF  3E,W
02A0:  BTFSC  03.2
02A1:  GOTO   29E
....................    c=buffer[next_out];								// lecture du buffer 
02A2:  MOVLW  2E
02A3:  ADDWF  3F,W
02A4:  MOVWF  04
02A5:  BCF    03.7
02A6:  MOVF   00,W
02A7:  MOVWF  6A
....................    next_out=(next_out+1) % BUFFER_SIZE;				// mise a jour du pointeur 
02A8:  MOVLW  01
02A9:  ADDWF  3F,W
02AA:  ANDLW  0F
02AB:  MOVWF  3F
....................    return(c); 
02AC:  MOVF   6A,W
02AD:  MOVWF  78
.................... } 
02AE:  RETLW  00
....................  
.................... //-------------------------xxx------------------------ 
.................... void initialisation() { 
....................  
....................    		enable_interrupts(int_rda);					// interrupt for serial ON 
*
0225:  BSF    03.5
0226:  BSF    0C.5
.................... 		enable_interrupts(global);					// enable interrupt 
0227:  MOVLW  C0
0228:  BCF    03.5
0229:  IORWF  0B,F
.................... 		lcd_init(); 
.................... 	   	lcd_char("\fRecepteur Capt \n"); 
*
0243:  CLRF   5B
0244:  MOVF   5B,W
0245:  CALL   03E
0246:  IORLW  00
0247:  BTFSC  03.2
0248:  GOTO   24D
0249:  INCF   5B,F
024A:  MOVWF  75
024B:  CALL   1B7
024C:  GOTO   244
.................... 		lcd_char("(C)UMONS - 2011"); 
024D:  CLRF   5B
024E:  MOVF   5B,W
024F:  CALL   054
0250:  IORLW  00
0251:  BTFSC  03.2
0252:  GOTO   257
0253:  INCF   5B,F
0254:  MOVWF  75
0255:  CALL   1B7
0256:  GOTO   24E
.................... 		beep(200,30); 
0257:  MOVLW  C8
0258:  MOVWF  5B
0259:  MOVLW  1E
025A:  MOVWF  5C
.................... 		delay_ms(1000);	 
*
0283:  MOVLW  04
0284:  BCF    03.5
0285:  MOVWF  5B
0286:  MOVLW  FA
0287:  MOVWF  76
0288:  CALL   1A3
0289:  DECFSZ 5B,F
028A:  GOTO   286
.................... 		lcd_cursor(0); 
028B:  CLRF   5B
.................... } 
*
029B:  BCF    0A.3
029C:  BCF    0A.4
029D:  GOTO   616 (RETURN)
.................... //-------------------------xxx------------------------ 
.................... void lect_capteurs(){ 
.................... 	byte i; 
.................... 	unsigned int16 val; 
.................... 	signed int16 val1,val2,val3; 
.................... 	float celc; 
....................  
.................... 	while (bkbhit) { 
*
0800:  MOVF   3F,W
0801:  SUBWF  3E,W
0802:  BTFSC  03.2
0803:  GOTO   3E9
....................  
.................... 		data[0]=bgetc(); 
0804:  BCF    0A.3
0805:  CALL   29E
0806:  BSF    0A.3
0807:  MOVF   78,W
0808:  MOVWF  49
.................... 		if (data[0] == entete) {					// lecture du debut de la trame (0xFF) 
0809:  INCFSZ 49,W
080A:  GOTO   3E8
.................... 			data[1]=bgetc();						// lecture adresse du capteur 
080B:  BCF    0A.3
080C:  CALL   29E
080D:  BSF    0A.3
080E:  MOVF   78,W
080F:  MOVWF  4A
.................... 			data[2]=bgetc();						// lecture Type de capteur 
0810:  BCF    0A.3
0811:  CALL   29E
0812:  BSF    0A.3
0813:  MOVF   78,W
0814:  MOVWF  4B
.................... 			data[3]=bgetc();						// lecture data Lsd 
0815:  BCF    0A.3
0816:  CALL   29E
0817:  BSF    0A.3
0818:  MOVF   78,W
0819:  MOVWF  4C
.................... 			data[4]=bgetc();						// lecture data Msb 
081A:  BCF    0A.3
081B:  CALL   29E
081C:  BSF    0A.3
081D:  MOVF   78,W
081E:  MOVWF  4D
.................... 			switch (data[2]) { 
081F:  MOVF   4B,W
0820:  BTFSC  03.2
0821:  GOTO   035
0822:  XORLW  01
0823:  BTFSC  03.2
0824:  GOTO   0C7
0825:  XORLW  05
0826:  BTFSC  03.2
0827:  GOTO   15A
0828:  XORLW  01
0829:  BTFSC  03.2
082A:  GOTO   2B0
082B:  XORLW  03
082C:  BTFSC  03.2
082D:  GOTO   2FB
082E:  XORLW  01
082F:  BTFSC  03.2
0830:  GOTO   346
0831:  XORLW  0B
0832:  BTFSC  03.2
0833:  GOTO   394
0834:  GOTO   3DF
....................  
.................... 				case typ_inout:											// lecture data entrees digitales 
.................... 					printf(lcd_char,"\fIN Dig. Adr: %X\n",data[1]); 
0835:  CLRF   68
0836:  MOVF   68,W
0837:  BCF    0A.3
0838:  CALL   068
0839:  BSF    0A.3
083A:  INCF   68,F
083B:  MOVWF  77
083C:  MOVWF  75
083D:  BCF    0A.3
083E:  CALL   1B7
083F:  BSF    0A.3
0840:  MOVLW  0E
0841:  SUBWF  68,W
0842:  BTFSS  03.2
0843:  GOTO   036
0844:  MOVF   4A,W
0845:  MOVWF  6A
0846:  MOVLW  37
0847:  MOVWF  6B
0848:  BCF    0A.3
0849:  CALL   2AF
084A:  BSF    0A.3
084B:  MOVLW  0A
084C:  MOVWF  75
084D:  BCF    0A.3
084E:  CALL   1B7
084F:  BSF    0A.3
.................... 					dec2bin(data[3]); 
0850:  MOVF   4C,W
0851:  MOVWF  68
.................... 					printf(lcd_char,"-> %s %2Xh",varbin,data[3]);	 
*
088D:  MOVLW  2D
088E:  MOVWF  75
088F:  BCF    0A.3
0890:  CALL   1B7
0891:  BSF    0A.3
0892:  MOVLW  3E
0893:  MOVWF  75
0894:  BCF    0A.3
0895:  CALL   1B7
0896:  BSF    0A.3
0897:  MOVLW  20
0898:  MOVWF  75
0899:  BCF    0A.3
089A:  CALL   1B7
089B:  BSF    0A.3
089C:  MOVLW  40
089D:  MOVWF  04
089E:  BCF    03.7
089F:  MOVLW  00
08A0:  IORWF  00,W
08A1:  BTFSC  03.2
08A2:  GOTO   0B5
08A3:  CLRF   69
08A4:  MOVF   04,W
08A5:  MOVWF  68
08A6:  BCF    69.0
08A7:  BTFSC  03.7
08A8:  BSF    69.0
08A9:  MOVF   00,W
08AA:  MOVWF  75
08AB:  BCF    0A.3
08AC:  CALL   1B7
08AD:  BSF    0A.3
08AE:  MOVF   68,W
08AF:  MOVWF  04
08B0:  BCF    03.7
08B1:  BTFSC  69.0
08B2:  BSF    03.7
08B3:  INCF   04,F
08B4:  GOTO   09F
08B5:  MOVLW  20
08B6:  MOVWF  75
08B7:  BCF    0A.3
08B8:  CALL   1B7
08B9:  BSF    0A.3
08BA:  MOVF   4C,W
08BB:  MOVWF  6A
08BC:  MOVLW  37
08BD:  MOVWF  6B
08BE:  BCF    0A.3
08BF:  CALL   2AF
08C0:  BSF    0A.3
08C1:  MOVLW  68
08C2:  MOVWF  75
08C3:  BCF    0A.3
08C4:  CALL   1B7
08C5:  BSF    0A.3
.................... 					break; 
08C6:  GOTO   3E8
....................  
.................... 				case typ_acc_x:											// lecture data accelerometre 
.................... 					for (i=5;i<=14;++i) data[i]=bgetc();				// lecture autres parametres Accelerom. 
08C7:  MOVLW  05
08C8:  MOVWF  5B
08C9:  MOVF   5B,W
08CA:  SUBLW  0E
08CB:  BTFSS  03.0
08CC:  GOTO   0DF
08CD:  MOVLW  49
08CE:  ADDWF  5B,W
08CF:  MOVWF  68
08D0:  CLRF   69
08D1:  BTFSC  03.0
08D2:  INCF   69,F
08D3:  BCF    0A.3
08D4:  CALL   29E
08D5:  BSF    0A.3
08D6:  MOVF   68,W
08D7:  MOVWF  04
08D8:  BCF    03.7
08D9:  BTFSC  69.0
08DA:  BSF    03.7
08DB:  MOVF   78,W
08DC:  MOVWF  00
08DD:  INCF   5B,F
08DE:  GOTO   0C9
.................... 					val1=data[3]+(data[4]*256); 
08DF:  MOVLW  00
08E0:  ADDWF  4C,W
08E1:  MOVWF  5E
08E2:  MOVF   4D,W
08E3:  MOVWF  5F
08E4:  BTFSC  03.0
08E5:  INCF   5F,F
.................... 					if ((data[5]==entete)&&(data[7]==typ_acc_y)) val2=data[8]+(data[9]*256); 
08E6:  INCFSZ 4E,W
08E7:  GOTO   0F3
08E8:  MOVF   50,W
08E9:  SUBLW  02
08EA:  BTFSS  03.2
08EB:  GOTO   0F3
08EC:  MOVLW  00
08ED:  ADDWF  51,W
08EE:  MOVWF  60
08EF:  MOVF   52,W
08F0:  MOVWF  61
08F1:  BTFSC  03.0
08F2:  INCF   61,F
.................... 					if ((data[10]==entete)&&(data[12]==typ_acc_z)) val3=data[13]+(data[14]*256); 
08F3:  INCFSZ 53,W
08F4:  GOTO   100
08F5:  MOVF   55,W
08F6:  SUBLW  03
08F7:  BTFSS  03.2
08F8:  GOTO   100
08F9:  MOVLW  00
08FA:  ADDWF  56,W
08FB:  MOVWF  62
08FC:  MOVF   57,W
08FD:  MOVWF  63
08FE:  BTFSC  03.0
08FF:  INCF   63,F
.................... 					printf(lcd_char,"\fAcceler. Adr:%X\n",data[1]); 
0900:  CLRF   68
0901:  MOVF   68,W
0902:  BCF    0A.3
0903:  CALL   07E
0904:  BSF    0A.3
0905:  INCF   68,F
0906:  MOVWF  77
0907:  MOVWF  75
0908:  BCF    0A.3
0909:  CALL   1B7
090A:  BSF    0A.3
090B:  MOVLW  0E
090C:  SUBWF  68,W
090D:  BTFSS  03.2
090E:  GOTO   101
090F:  MOVF   4A,W
0910:  MOVWF  6A
0911:  MOVLW  37
0912:  MOVWF  6B
0913:  BCF    0A.3
0914:  CALL   2AF
0915:  BSF    0A.3
0916:  MOVLW  0A
0917:  MOVWF  75
0918:  BCF    0A.3
0919:  CALL   1B7
091A:  BSF    0A.3
.................... 					printf(lcd_char,"X%ld Y%ld Z%ld  ",val1,val2,val3);	 
091B:  MOVLW  58
091C:  MOVWF  75
091D:  BCF    0A.3
091E:  CALL   1B7
091F:  BSF    0A.3
0920:  MOVLW  10
0921:  MOVWF  04
0922:  MOVF   5F,W
0923:  MOVWF  69
0924:  MOVF   5E,W
0925:  MOVWF  68
0926:  BCF    0A.3
0927:  CALL   2D0
0928:  BSF    0A.3
0929:  MOVLW  20
092A:  MOVWF  75
092B:  BCF    0A.3
092C:  CALL   1B7
092D:  BSF    0A.3
092E:  MOVLW  59
092F:  MOVWF  75
0930:  BCF    0A.3
0931:  CALL   1B7
0932:  BSF    0A.3
0933:  MOVLW  10
0934:  MOVWF  04
0935:  MOVF   61,W
0936:  MOVWF  69
0937:  MOVF   60,W
0938:  MOVWF  68
0939:  BCF    0A.3
093A:  CALL   2D0
093B:  BSF    0A.3
093C:  MOVLW  20
093D:  MOVWF  75
093E:  BCF    0A.3
093F:  CALL   1B7
0940:  BSF    0A.3
0941:  MOVLW  5A
0942:  MOVWF  75
0943:  BCF    0A.3
0944:  CALL   1B7
0945:  BSF    0A.3
0946:  MOVLW  10
0947:  MOVWF  04
0948:  MOVF   63,W
0949:  MOVWF  69
094A:  MOVF   62,W
094B:  MOVWF  68
094C:  BCF    0A.3
094D:  CALL   2D0
094E:  BSF    0A.3
094F:  MOVLW  20
0950:  MOVWF  75
0951:  BCF    0A.3
0952:  CALL   1B7
0953:  BSF    0A.3
0954:  MOVLW  20
0955:  MOVWF  75
0956:  BCF    0A.3
0957:  CALL   1B7
0958:  BSF    0A.3
.................... 					break; 
0959:  GOTO   3E8
....................  
.................... 				case typ_temp:											// lecture data temperature 
.................... 					celc=data[3]+(data[4]*256); 
095A:  MOVF   4D,W
095B:  MOVWF  7A
095C:  MOVLW  00
095D:  ADDWF  4C,W
095E:  MOVWF  78
095F:  BTFSC  03.0
0960:  INCF   7A,F
0961:  MOVF   78,W
0962:  MOVWF  68
0963:  MOVF   7A,W
0964:  MOVWF  69
*
0981:  MOVF   7A,W
0982:  MOVWF  67
0983:  MOVF   79,W
0984:  MOVWF  66
0985:  MOVF   78,W
0986:  MOVWF  65
0987:  MOVF   77,W
0988:  MOVWF  64
.................... 					celc=(celc/256); 
0989:  MOVF   67,W
098A:  MOVWF  6B
098B:  MOVF   66,W
098C:  MOVWF  6A
098D:  MOVF   65,W
098E:  MOVWF  69
098F:  MOVF   64,W
0990:  MOVWF  68
0991:  CLRF   6F
0992:  CLRF   6E
0993:  CLRF   6D
0994:  MOVLW  87
0995:  MOVWF  6C
*
0A5F:  MOVF   7A,W
0A60:  MOVWF  67
0A61:  MOVF   79,W
0A62:  MOVWF  66
0A63:  MOVF   78,W
0A64:  MOVWF  65
0A65:  MOVF   77,W
0A66:  MOVWF  64
.................... 					printf(lcd_char,"\fCap. Temp Adr:%X\n",data[1]); 
0A67:  CLRF   68
0A68:  MOVF   68,W
0A69:  BCF    0A.3
0A6A:  CALL   094
0A6B:  BSF    0A.3
0A6C:  INCF   68,F
0A6D:  MOVWF  77
0A6E:  MOVWF  75
0A6F:  BCF    0A.3
0A70:  CALL   1B7
0A71:  BSF    0A.3
0A72:  MOVLW  0F
0A73:  SUBWF  68,W
0A74:  BTFSS  03.2
0A75:  GOTO   268
0A76:  MOVF   4A,W
0A77:  MOVWF  6A
0A78:  MOVLW  37
0A79:  MOVWF  6B
0A7A:  BCF    0A.3
0A7B:  CALL   2AF
0A7C:  BSF    0A.3
0A7D:  MOVLW  0A
0A7E:  MOVWF  75
0A7F:  BCF    0A.3
0A80:  CALL   1B7
0A81:  BSF    0A.3
.................... 					printf(lcd_char,"-> %3.3f C ",celc);	 
0A82:  MOVLW  2D
0A83:  MOVWF  75
0A84:  BCF    0A.3
0A85:  CALL   1B7
0A86:  BSF    0A.3
0A87:  MOVLW  3E
0A88:  MOVWF  75
0A89:  BCF    0A.3
0A8A:  CALL   1B7
0A8B:  BSF    0A.3
0A8C:  MOVLW  20
0A8D:  MOVWF  75
0A8E:  BCF    0A.3
0A8F:  CALL   1B7
0A90:  BSF    0A.3
0A91:  MOVLW  89
0A92:  MOVWF  04
0A93:  MOVF   67,W
0A94:  MOVWF  6B
0A95:  MOVF   66,W
0A96:  MOVWF  6A
0A97:  MOVF   65,W
0A98:  MOVWF  69
0A99:  MOVF   64,W
0A9A:  MOVWF  68
0A9B:  MOVLW  03
0A9C:  MOVWF  6C
0A9D:  BCF    0A.3
0A9E:  GOTO   394
0A9F:  BSF    0A.3
0AA0:  MOVLW  20
0AA1:  MOVWF  75
0AA2:  BCF    0A.3
0AA3:  CALL   1B7
0AA4:  BSF    0A.3
0AA5:  MOVLW  43
0AA6:  MOVWF  75
0AA7:  BCF    0A.3
0AA8:  CALL   1B7
0AA9:  BSF    0A.3
0AAA:  MOVLW  20
0AAB:  MOVWF  75
0AAC:  BCF    0A.3
0AAD:  CALL   1B7
0AAE:  BSF    0A.3
.................... 					break; 
0AAF:  GOTO   3E8
....................  
.................... 				case typ_light:											// lecture data lumière 
.................... 					val=data[3]+(data[4]*256); 
0AB0:  MOVLW  00
0AB1:  ADDWF  4C,W
0AB2:  MOVWF  5C
0AB3:  MOVF   4D,W
0AB4:  MOVWF  5D
0AB5:  BTFSC  03.0
0AB6:  INCF   5D,F
.................... 					printf(lcd_char,"\fLight Adr:%X\n",data[1]); 
0AB7:  CLRF   68
0AB8:  MOVF   68,W
0AB9:  BCF    0A.3
0ABA:  CALL   0AB
0ABB:  BSF    0A.3
0ABC:  INCF   68,F
0ABD:  MOVWF  77
0ABE:  MOVWF  75
0ABF:  BCF    0A.3
0AC0:  CALL   1B7
0AC1:  BSF    0A.3
0AC2:  MOVLW  0B
0AC3:  SUBWF  68,W
0AC4:  BTFSS  03.2
0AC5:  GOTO   2B8
0AC6:  MOVF   4A,W
0AC7:  MOVWF  6A
0AC8:  MOVLW  37
0AC9:  MOVWF  6B
0ACA:  BCF    0A.3
0ACB:  CALL   2AF
0ACC:  BSF    0A.3
0ACD:  MOVLW  0A
0ACE:  MOVWF  75
0ACF:  BCF    0A.3
0AD0:  CALL   1B7
0AD1:  BSF    0A.3
.................... 					printf(lcd_char,"-> %lu Lux ",val);	 
0AD2:  MOVLW  2D
0AD3:  MOVWF  75
0AD4:  BCF    0A.3
0AD5:  CALL   1B7
0AD6:  BSF    0A.3
0AD7:  MOVLW  3E
0AD8:  MOVWF  75
0AD9:  BCF    0A.3
0ADA:  CALL   1B7
0ADB:  BSF    0A.3
0ADC:  MOVLW  20
0ADD:  MOVWF  75
0ADE:  BCF    0A.3
0ADF:  CALL   1B7
0AE0:  BSF    0A.3
0AE1:  MOVLW  10
0AE2:  MOVWF  04
0AE3:  MOVF   5D,W
0AE4:  MOVWF  69
0AE5:  MOVF   5C,W
0AE6:  MOVWF  68
0AE7:  BCF    0A.3
0AE8:  CALL   50A
0AE9:  BSF    0A.3
0AEA:  MOVLW  06
0AEB:  MOVWF  68
0AEC:  MOVF   68,W
0AED:  BCF    0A.3
0AEE:  CALL   0BE
0AEF:  BSF    0A.3
0AF0:  INCF   68,F
0AF1:  MOVWF  77
0AF2:  MOVWF  75
0AF3:  BCF    0A.3
0AF4:  CALL   1B7
0AF5:  BSF    0A.3
0AF6:  MOVLW  0B
0AF7:  SUBWF  68,W
0AF8:  BTFSS  03.2
0AF9:  GOTO   2EC
.................... 					break; 
0AFA:  GOTO   3E8
....................  
.................... 				case typ_srf02:											// lecture data distance 
.................... 					val=data[3]+(data[4]*256); 
0AFB:  MOVLW  00
0AFC:  ADDWF  4C,W
0AFD:  MOVWF  5C
0AFE:  MOVF   4D,W
0AFF:  MOVWF  5D
0B00:  BTFSC  03.0
0B01:  INCF   5D,F
.................... 					printf(lcd_char,"\fDist. Adr:%X\n",data[1]); 
0B02:  CLRF   68
0B03:  MOVF   68,W
0B04:  BCF    0A.3
0B05:  CALL   0CE
0B06:  BSF    0A.3
0B07:  INCF   68,F
0B08:  MOVWF  77
0B09:  MOVWF  75
0B0A:  BCF    0A.3
0B0B:  CALL   1B7
0B0C:  BSF    0A.3
0B0D:  MOVLW  0B
0B0E:  SUBWF  68,W
0B0F:  BTFSS  03.2
0B10:  GOTO   303
0B11:  MOVF   4A,W
0B12:  MOVWF  6A
0B13:  MOVLW  37
0B14:  MOVWF  6B
0B15:  BCF    0A.3
0B16:  CALL   2AF
0B17:  BSF    0A.3
0B18:  MOVLW  0A
0B19:  MOVWF  75
0B1A:  BCF    0A.3
0B1B:  CALL   1B7
0B1C:  BSF    0A.3
.................... 					printf(lcd_char,"-> %lu Cm ",val);	 
0B1D:  MOVLW  2D
0B1E:  MOVWF  75
0B1F:  BCF    0A.3
0B20:  CALL   1B7
0B21:  BSF    0A.3
0B22:  MOVLW  3E
0B23:  MOVWF  75
0B24:  BCF    0A.3
0B25:  CALL   1B7
0B26:  BSF    0A.3
0B27:  MOVLW  20
0B28:  MOVWF  75
0B29:  BCF    0A.3
0B2A:  CALL   1B7
0B2B:  BSF    0A.3
0B2C:  MOVLW  10
0B2D:  MOVWF  04
0B2E:  MOVF   5D,W
0B2F:  MOVWF  69
0B30:  MOVF   5C,W
0B31:  MOVWF  68
0B32:  BCF    0A.3
0B33:  CALL   50A
0B34:  BSF    0A.3
0B35:  MOVLW  06
0B36:  MOVWF  68
0B37:  MOVF   68,W
0B38:  BCF    0A.3
0B39:  CALL   0E1
0B3A:  BSF    0A.3
0B3B:  INCF   68,F
0B3C:  MOVWF  77
0B3D:  MOVWF  75
0B3E:  BCF    0A.3
0B3F:  CALL   1B7
0B40:  BSF    0A.3
0B41:  MOVLW  0A
0B42:  SUBWF  68,W
0B43:  BTFSS  03.2
0B44:  GOTO   337
.................... 					break; 
0B45:  GOTO   3E8
....................  
.................... 				case typ_adc01:											// lecture data entree ADC 
.................... 					val=data[3]+(data[4]*256); 
0B46:  MOVLW  00
0B47:  ADDWF  4C,W
0B48:  MOVWF  5C
0B49:  MOVF   4D,W
0B4A:  MOVWF  5D
0B4B:  BTFSC  03.0
0B4C:  INCF   5D,F
.................... 					printf(lcd_char,"\fIN ADC1 Adr:%X\n",data[1]); 
0B4D:  CLRF   68
0B4E:  MOVF   68,W
0B4F:  BCF    0A.3
0B50:  CALL   0F0
0B51:  BSF    0A.3
0B52:  INCF   68,F
0B53:  MOVWF  77
0B54:  MOVWF  75
0B55:  BCF    0A.3
0B56:  CALL   1B7
0B57:  BSF    0A.3
0B58:  MOVLW  0D
0B59:  SUBWF  68,W
0B5A:  BTFSS  03.2
0B5B:  GOTO   34E
0B5C:  MOVF   4A,W
0B5D:  MOVWF  6A
0B5E:  MOVLW  37
0B5F:  MOVWF  6B
0B60:  BCF    0A.3
0B61:  CALL   2AF
0B62:  BSF    0A.3
0B63:  MOVLW  0A
0B64:  MOVWF  75
0B65:  BCF    0A.3
0B66:  CALL   1B7
0B67:  BSF    0A.3
.................... 					printf(lcd_char,"-> %1.1w V ",val);	 
0B68:  MOVLW  2D
0B69:  MOVWF  75
0B6A:  BCF    0A.3
0B6B:  CALL   1B7
0B6C:  BSF    0A.3
0B6D:  MOVLW  3E
0B6E:  MOVWF  75
0B6F:  BCF    0A.3
0B70:  CALL   1B7
0B71:  BSF    0A.3
0B72:  MOVLW  20
0B73:  MOVWF  75
0B74:  BCF    0A.3
0B75:  CALL   1B7
0B76:  BSF    0A.3
0B77:  MOVLW  41
0B78:  MOVWF  04
0B79:  CLRF   6B
0B7A:  CLRF   6A
0B7B:  MOVF   5D,W
0B7C:  MOVWF  69
0B7D:  MOVF   5C,W
0B7E:  MOVWF  68
0B7F:  MOVLW  01
0B80:  MOVWF  6C
0B81:  BCF    0A.3
0B82:  GOTO   56D
0B83:  BSF    0A.3
0B84:  MOVLW  20
0B85:  MOVWF  75
0B86:  BCF    0A.3
0B87:  CALL   1B7
0B88:  BSF    0A.3
0B89:  MOVLW  56
0B8A:  MOVWF  75
0B8B:  BCF    0A.3
0B8C:  CALL   1B7
0B8D:  BSF    0A.3
0B8E:  MOVLW  20
0B8F:  MOVWF  75
0B90:  BCF    0A.3
0B91:  CALL   1B7
0B92:  BSF    0A.3
.................... 					break; 
0B93:  GOTO   3E8
....................  
.................... 				case typ_boussole:										// lecture data boussole 
.................... 					val=data[3]+(data[4]*256); 
0B94:  MOVLW  00
0B95:  ADDWF  4C,W
0B96:  MOVWF  5C
0B97:  MOVF   4D,W
0B98:  MOVWF  5D
0B99:  BTFSC  03.0
0B9A:  INCF   5D,F
.................... 					printf(lcd_char,"\fBoussole Adr:%X\n",data[1]); 
0B9B:  CLRF   68
0B9C:  MOVF   68,W
0B9D:  BCF    0A.3
0B9E:  CALL   108
0B9F:  BSF    0A.3
0BA0:  INCF   68,F
0BA1:  MOVWF  77
0BA2:  MOVWF  75
0BA3:  BCF    0A.3
0BA4:  CALL   1B7
0BA5:  BSF    0A.3
0BA6:  MOVLW  0E
0BA7:  SUBWF  68,W
0BA8:  BTFSS  03.2
0BA9:  GOTO   39C
0BAA:  MOVF   4A,W
0BAB:  MOVWF  6A
0BAC:  MOVLW  37
0BAD:  MOVWF  6B
0BAE:  BCF    0A.3
0BAF:  CALL   2AF
0BB0:  BSF    0A.3
0BB1:  MOVLW  0A
0BB2:  MOVWF  75
0BB3:  BCF    0A.3
0BB4:  CALL   1B7
0BB5:  BSF    0A.3
.................... 					printf(lcd_char,"-> %ld Deg. ",val);;	 
0BB6:  MOVLW  2D
0BB7:  MOVWF  75
0BB8:  BCF    0A.3
0BB9:  CALL   1B7
0BBA:  BSF    0A.3
0BBB:  MOVLW  3E
0BBC:  MOVWF  75
0BBD:  BCF    0A.3
0BBE:  CALL   1B7
0BBF:  BSF    0A.3
0BC0:  MOVLW  20
0BC1:  MOVWF  75
0BC2:  BCF    0A.3
0BC3:  CALL   1B7
0BC4:  BSF    0A.3
0BC5:  MOVLW  10
0BC6:  MOVWF  04
0BC7:  MOVF   5D,W
0BC8:  MOVWF  69
0BC9:  MOVF   5C,W
0BCA:  MOVWF  68
0BCB:  BCF    0A.3
0BCC:  CALL   2D0
0BCD:  BSF    0A.3
0BCE:  MOVLW  06
0BCF:  MOVWF  68
0BD0:  MOVF   68,W
0BD1:  BCF    0A.3
0BD2:  CALL   11E
0BD3:  BSF    0A.3
0BD4:  INCF   68,F
0BD5:  MOVWF  77
0BD6:  MOVWF  75
0BD7:  BCF    0A.3
0BD8:  CALL   1B7
0BD9:  BSF    0A.3
0BDA:  MOVLW  0C
0BDB:  SUBWF  68,W
0BDC:  BTFSS  03.2
0BDD:  GOTO   3D0
.................... 					break; 
0BDE:  GOTO   3E8
....................  
.................... 				default : 
.................... 					while (bkbhit) { 
0BDF:  MOVF   3F,W
0BE0:  SUBWF  3E,W
0BE1:  BTFSC  03.2
0BE2:  GOTO   3E7
.................... 						bgetc();										// vidage buffer si non OK 
0BE3:  BCF    0A.3
0BE4:  CALL   29E
0BE5:  BSF    0A.3
.................... 					} 
0BE6:  GOTO   3DF
.................... 					break; 
0BE7:  GOTO   3E8
.................... 			}	 
.................... 		}   
.................... 	} 
0BE8:  GOTO   000
.................... } 
0BE9:  BCF    0A.3
0BEA:  BCF    0A.4
0BEB:  GOTO   62A (RETURN)
....................  
.................... //-------------------------xxx------------------------ 
.................... void main() { 
*
05E8:  CLRF   04
05E9:  BCF    03.7
05EA:  MOVLW  1F
05EB:  ANDWF  03,F
05EC:  BSF    03.5
05ED:  BSF    03.6
05EE:  BSF    07.3
05EF:  MOVLW  56
05F0:  BCF    03.6
05F1:  MOVWF  19
05F2:  MOVLW  00
05F3:  MOVWF  1A
05F4:  MOVLW  A6
05F5:  MOVWF  18
05F6:  MOVLW  90
05F7:  BCF    03.5
05F8:  MOVWF  18
05F9:  BSF    03.5
05FA:  BSF    03.6
05FB:  MOVF   09,W
05FC:  ANDLW  C0
05FD:  MOVWF  09
05FE:  BCF    03.6
05FF:  BCF    1F.4
0600:  BCF    1F.5
0601:  MOVLW  00
0602:  BSF    03.6
0603:  MOVWF  08
0604:  BCF    03.5
0605:  CLRF   07
0606:  CLRF   08
0607:  CLRF   09
0608:  BSF    03.5
0609:  BCF    03.6
060A:  CLRF   17
060B:  BSF    03.6
060C:  CLRF   05
....................  
.................... 		initialisation(); 
*
0615:  GOTO   225
.................... 		flagp=false; 
0616:  BCF    59.0
.................... 		while(true) { 
.................... 			if (input(bluethoot)) {							// RF bluetooth actif ? 
0617:  BSF    03.5
0618:  BSF    05.4
0619:  BCF    03.5
061A:  BTFSS  05.4
061B:  GOTO   633
.................... 				lcd_char("\fBluetooth ON."); 
061C:  CLRF   5B
061D:  MOVF   5B,W
061E:  CALL   12F
061F:  IORLW  00
0620:  BTFSC  03.2
0621:  GOTO   626
0622:  INCF   5B,F
0623:  MOVWF  75
0624:  CALL   1B7
0625:  GOTO   61D
.................... 				flagp=false; 
0626:  BCF    59.0
.................... 				delay_ms(100); 
0627:  MOVLW  64
0628:  MOVWF  76
0629:  CALL   1A3
.................... 				while (input(bluethoot)) 					// tant que Bluetooth actif 
.................... 					lect_capteurs(); 
062A:  BSF    03.5
062B:  BSF    05.4
062C:  BCF    03.5
062D:  BTFSS  05.4
062E:  GOTO   632
062F:  BSF    0A.3
0630:  GOTO   000
0631:  BCF    0A.3
.................... 			} 
.................... 			 
.................... 			else if (!flagp) {  
0632:  GOTO   640
0633:  BTFSC  59.0
0634:  GOTO   640
.................... 				lcd_char("\fBluetooth OFF."); 
0635:  CLRF   5B
0636:  MOVF   5B,W
0637:  CALL   142
0638:  IORLW  00
0639:  BTFSC  03.2
063A:  GOTO   63F
063B:  INCF   5B,F
063C:  MOVWF  75
063D:  CALL   1B7
063E:  GOTO   636
.................... 				flagp=true; 
063F:  BSF    59.0
.................... 			} 
.................... 		} 
0640:  GOTO   617
.................... } 
0641:  SLEEP

Configuration Fuses:
   Word  1: 2CF2   HS NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   NOWRT BORV40
