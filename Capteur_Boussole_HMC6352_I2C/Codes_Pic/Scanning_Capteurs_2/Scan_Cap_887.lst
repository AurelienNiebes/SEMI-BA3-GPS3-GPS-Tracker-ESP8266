CCS PCM C Compiler, Version 4.038, 11770               19-oct.-11 12:15

               Filename: Scan_Cap_887.lst

               ROM used: 3582 words (44%)
                         Largest free fragment is 2048
               RAM used: 27 (7%) at main() level
                         67 (18%) worst case
               Stack:    6 locations

*
0001:  MOVLW  08
0002:  MOVWF  0A
0003:  GOTO   5A2
0004:  NOP
.................... //----------------------------------------------------- 
.................... //------------ Programme Sendp data capt -------------- 
.................... //----------------------------------------------------- 
.................... //-- Projet:                                         -- 
.................... //-- Date:   10-10-2011                              -- 
.................... //-- Progr:  Send data in serie 				     -- 
.................... //-- Auteur: Binon Daniel (UMONS)					 -- 
.................... //----------------------------------------------------- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //--   												 -- 
.................... //-----------------------------------------------------  
....................  
.................... #include "887_sv3_scan.h" 
.................... #include <16F887.h> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
.................... #list 
....................  
....................  
.................... #device ADC=10		// adc en mode résolution 10 bits 
.................... #fuses NOWDT, HS, NOPUT, NOPROTECT, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NODEBUG 
.................... #use delay(clock=20M) 
*
0185:  MOVLW  51
0186:  MOVWF  04
0187:  BCF    03.7
0188:  MOVF   00,W
0189:  BTFSC  03.2
018A:  GOTO   198
018B:  MOVLW  06
018C:  MOVWF  78
018D:  CLRF   77
018E:  DECFSZ 77,F
018F:  GOTO   18E
0190:  DECFSZ 78,F
0191:  GOTO   18D
0192:  MOVLW  7B
0193:  MOVWF  77
0194:  DECFSZ 77,F
0195:  GOTO   194
0196:  DECFSZ 00,F
0197:  GOTO   18B
0198:  RETLW  00
.................... #use rs232(baud=57600, xmit=PIN_C6, rcv=PIN_C7, stream=RS232) 
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3) 
*
02AD:  MOVLW  08
02AE:  MOVWF  78
02AF:  MOVLW  04
02B0:  MOVWF  77
02B1:  DECFSZ 77,F
02B2:  GOTO   2B1
02B3:  BCF    07.3
02B4:  BCF    20.3
02B5:  MOVF   20,W
02B6:  BSF    03.5
02B7:  MOVWF  07
02B8:  MOVLW  03
02B9:  MOVWF  77
02BA:  DECFSZ 77,F
02BB:  GOTO   2BA
02BC:  BCF    03.5
02BD:  RLF    48,F
02BE:  BCF    07.4
02BF:  BTFSS  03.0
02C0:  GOTO   2C7
02C1:  BSF    20.4
02C2:  MOVF   20,W
02C3:  BSF    03.5
02C4:  MOVWF  07
02C5:  GOTO   2CB
02C6:  BCF    03.5
02C7:  BCF    20.4
02C8:  MOVF   20,W
02C9:  BSF    03.5
02CA:  MOVWF  07
02CB:  NOP
02CC:  BCF    03.5
02CD:  BSF    20.3
02CE:  MOVF   20,W
02CF:  BSF    03.5
02D0:  MOVWF  07
02D1:  BCF    03.5
02D2:  BTFSS  07.3
02D3:  GOTO   2D2
02D4:  DECFSZ 78,F
02D5:  GOTO   2AF
02D6:  MOVLW  04
02D7:  MOVWF  77
02D8:  DECFSZ 77,F
02D9:  GOTO   2D8
02DA:  BCF    07.3
02DB:  BCF    20.3
02DC:  MOVF   20,W
02DD:  BSF    03.5
02DE:  MOVWF  07
02DF:  NOP
02E0:  BCF    03.5
02E1:  BSF    20.4
02E2:  MOVF   20,W
02E3:  BSF    03.5
02E4:  MOVWF  07
02E5:  MOVLW  03
02E6:  MOVWF  77
02E7:  DECFSZ 77,F
02E8:  GOTO   2E7
02E9:  MOVLW  03
02EA:  MOVWF  77
02EB:  DECFSZ 77,F
02EC:  GOTO   2EB
02ED:  BCF    03.5
02EE:  BSF    20.3
02EF:  MOVF   20,W
02F0:  BSF    03.5
02F1:  MOVWF  07
02F2:  BCF    03.5
02F3:  BTFSS  07.3
02F4:  GOTO   2F3
02F5:  CLRF   78
02F6:  MOVLW  03
02F7:  MOVWF  77
02F8:  DECFSZ 77,F
02F9:  GOTO   2F8
02FA:  BTFSC  07.4
02FB:  BSF    78.0
02FC:  BCF    07.3
02FD:  BCF    20.3
02FE:  MOVF   20,W
02FF:  BSF    03.5
0300:  MOVWF  07
0301:  BCF    03.5
0302:  BCF    07.4
0303:  BCF    20.4
0304:  MOVF   20,W
0305:  BSF    03.5
0306:  MOVWF  07
0307:  BCF    03.5
0308:  RETLW  00
*
0351:  MOVLW  08
0352:  MOVWF  48
0353:  MOVF   77,W
0354:  MOVWF  49
0355:  BSF    20.4
0356:  MOVF   20,W
0357:  BSF    03.5
0358:  MOVWF  07
0359:  MOVLW  03
035A:  MOVWF  77
035B:  DECFSZ 77,F
035C:  GOTO   35B
035D:  BCF    03.5
035E:  BSF    20.3
035F:  MOVF   20,W
0360:  BSF    03.5
0361:  MOVWF  07
0362:  BCF    03.5
0363:  BTFSS  07.3
0364:  GOTO   363
0365:  BTFSC  07.4
0366:  BSF    03.0
0367:  BTFSS  07.4
0368:  BCF    03.0
0369:  RLF    78,F
036A:  MOVLW  04
036B:  MOVWF  77
036C:  DECFSZ 77,F
036D:  GOTO   36C
036E:  BCF    20.3
036F:  MOVF   20,W
0370:  BSF    03.5
0371:  MOVWF  07
0372:  BCF    03.5
0373:  BCF    07.3
0374:  DECFSZ 48,F
0375:  GOTO   355
0376:  BSF    20.4
0377:  MOVF   20,W
0378:  BSF    03.5
0379:  MOVWF  07
037A:  MOVLW  03
037B:  MOVWF  77
037C:  DECFSZ 77,F
037D:  GOTO   37C
037E:  BCF    03.5
037F:  BCF    07.4
0380:  MOVF   49,W
0381:  BTFSC  03.2
0382:  GOTO   388
0383:  BCF    20.4
0384:  MOVF   20,W
0385:  BSF    03.5
0386:  MOVWF  07
0387:  BCF    03.5
0388:  NOP
0389:  BSF    20.3
038A:  MOVF   20,W
038B:  BSF    03.5
038C:  MOVWF  07
038D:  BCF    03.5
038E:  BTFSS  07.3
038F:  GOTO   38E
0390:  MOVLW  04
0391:  MOVWF  77
0392:  DECFSZ 77,F
0393:  GOTO   392
0394:  BCF    07.3
0395:  BCF    20.3
0396:  MOVF   20,W
0397:  BSF    03.5
0398:  MOVWF  07
0399:  MOVLW  03
039A:  MOVWF  77
039B:  DECFSZ 77,F
039C:  GOTO   39B
039D:  BCF    03.5
039E:  BCF    07.4
039F:  BCF    20.4
03A0:  MOVF   20,W
03A1:  BSF    03.5
03A2:  MOVWF  07
03A3:  BCF    03.5
03A4:  RETLW  00
*
0DC7:  MOVLW  FF
0DC8:  BCF    03.5
0DC9:  BCF    03.6
0DCA:  MOVWF  20
....................  
.................... #build(reset=0x1, interrupt=0x5)          // Necessary for Bootloader 
.................... #ORG 0x1F00,0x1FFF {}   
....................  
.................... #define Button PIN_E2 
.................... #define led PIN_A4 
.................... #define bluethoot PIN_A4 
.................... #define TIME1 500 
....................  
.................... //-- Formatage données envoyes sur la sortie serie -- 
.................... //-- format de la trame envoyee: 
.................... //-- +--------------+--------------------+-------------+----------+----------+ 
.................... //-- |-    8bits   -|-       8bits      -|-   8bits   -|-  8bits -|-  8bits -| 
.................... //-- |-ENTETE(0xFF)-|-ADR DEVICE (1byte)-|-Type DEVICE-|-data Lsb-|-data Msb-| 
.................... //-- +--------------+--------------------+-------------+----------+----------+ 
.................... //-- 
....................  
.................... #define entete 0xFF 
.................... #define adr_inout 0x00 
.................... #define adr_ADC 0x00 
.................... #define adr_acc 0x3A 
.................... #define adr_boussole 0x42 
.................... #define adr_temp 0x90 
.................... #define adr_light 0x46 
.................... #define adr_srf02 0xe0 
....................  
.................... #define typ_inout 0x00				// 1 byte 
.................... #define typ_acc_x 0x01				// 2 bytes 
.................... #define typ_acc_y 0x02				// 2 bytes 
.................... #define typ_acc_z 0x03				// 2 bytes 
.................... #define typ_temp 0x04				// 2 bytes 
.................... #define typ_light 0x05				// 2 bytes 
.................... #define typ_srf02 0x06				// 2 bytes 
.................... #define typ_adc01 0x07				// 2 bytes 
.................... #define typ_boussole 0x0c			// 2 bytes 
....................  
.................... //-------------------------E/S------------------------ 
.................... #include "LCD420_S3.c" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //// LCD420_S3.C //// 
.................... //// Driver for common 4x20 LCD modules //// 
.................... //// //// 
.................... //// lcd_init() Must be called before any other function. //// 
.................... //// //// 
.................... //// lcd_putc(c) Will display c on the next position of the LCD. //// 
.................... //// The following have special meaning: //// 
.................... //// \f Clear display //// 
.................... //// \n Go to start of second line //// 
.................... //// \b Move back one position //// 
.................... //// \c Cursor on //// 
.................... //// \d Blink character //// 
.................... //// \1 Custom character DegC //// 
.................... //// //// 
.................... //// lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) //// 
.................... //// //// 
.................... //// lcd_getc(x,y) Returns character at position x,y on LCD //// 
.................... //// //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //// (C) Copyright 1996,1997 Custom Computer Services //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler. This source code may only be distributed to other //// 
.................... //// licensed users of the CCS C compiler. No other use, reproduction //// 
.................... //// or distribution is permitted without written permission. //// 
.................... //// Derivative programs created using this software in object code //// 
.................... //// form are not restricted in any way. //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... // These pins are for the PIC development board: 
.................... // B1 enable 
.................... // B2 rs 
.................... // B3 rw 
.................... // B4 D4 
.................... // B5 D5 
.................... // E1 D6 
.................... // E0 D7 
....................  
.................... #if defined(__PCM__)  
.................... #define LCD_RS PIN_B2 
....................  
.................... #elif defined(__PCH__) 
.................... #define LCD_RS PIN_E0 
.................... #endif 
....................  
.................... #define LCD_E PIN_B3 
.................... //#define LCD_RS PIN_B2 
.................... //#define LCD_RW PIN_B1 
.................... #define LCD_DB4 PIN_B4 
.................... #define LCD_DB5 PIN_B5 
.................... #define LCD_DB6 PIN_B6 
.................... #define LCD_DB7 PIN_B7 
....................  
.................... // Clear and home 
.................... #define LCD_CLR_DISP 0x01 // Clear screen, home cursor, unshift display 
.................... #define LCD_RETURN_HOME 0x02 // Home cursor, unshift display 
....................  
.................... // Set entry mode: display shift on/off, dec/inc cursor move direction 
.................... #define LCD_ENTRY_DEC 0x04 // Display shift off, dec cursor move dir 
.................... #define LCD_ENTRY_DEC_SHIFT 0x05 // Display shift on, dec cursor move dir 
.................... #define LCD_ENTRY_INC 0x06 // Display shift off, inc cursor move dir 
.................... #define LCD_ENTRY_INC_SHIFT 0x07 // Display shift on, inc cursor move dir 
....................  
.................... // Display on/off, cursor on/off, blinking char at cursor position 
.................... #define LCD_DISP_OFF 0x08 // Display off 
.................... #define LCD_DISP_ON 0x0C // Display on, cursor off 
.................... #define LCD_DISP_ON_BLINK 0x0D // Display on, cursor off, blink char 
.................... #define LCD_DISP_ON_CURSOR 0x0E // Display on, cursor on 
.................... #define LCD_DISP_ON_CURSOR_BLINK 0x0F // Display on, cursor on, blink char 
....................  
.................... // Move cursor/shift display 
.................... #define LCD_MOVE_CURSOR_LEFT 0x10 // Move cursor left (decrement) 
.................... #define LCD_MOVE_CURSOR_RIGHT 0x14 // Move cursor right (increment) 
.................... #define LCD_MOVE_DISP_LEFT 0x18 // Shift display left 
.................... #define LCD_MOVE_DISP_RIGHT 0x1C // Shift display right 
....................  
.................... // Function set: set interface data length and number of display lines 
.................... #define LCD_FUNCTION_4BIT_1LINE 0x20 // 4-bit interface, single line, 5x7 dots 
.................... #define LCD_FUNCTION_4BIT_2LINES 0x28 // 4-bit interface, dual line, 5x7 dots 
.................... #define LCD_FUNCTION_8BIT_1LINE 0x30 // 8-bit interface, single line, 5x7 dots 
.................... #define LCD_FUNCTION_8BIT_2LINES 0x38 // 8-bit interface, dual line, 5x7 dots 
....................  
.................... #define LCD_CGRAM_BASE_ADDR 0x40 // Set the CGRAM address 
.................... #define LCD_DDRAM_BASE_ADDR 0x80 // Set the DDRAM address 
....................  
.................... // Address positions 
.................... #define LCD_LINE_1 0x80 // Position of start of line 1 
.................... #define LCD_LINE_2 0xC0 // Position of start of line 2 
.................... #define LCD_LINE_3 0x94 // Position of start of line 3 
.................... #define LCD_LINE_4 0xD4 // Position of start of line 4 
....................  
.................... #define LCD_DEGREE_CHAR 0x00 // Ascii 00 
....................  
.................... #define lcd_type 2 // 0=5x7, 1=5x10, 2=2 lines 
....................  
.................... BYTE const LCD_INIT_STRING[4] = { 
.................... LCD_FUNCTION_4BIT_2LINES | (lcd_type << 2), // Set mode: 4-bit, 2 lines, 5x7 dots 
.................... LCD_DISP_ON, 
.................... LCD_CLR_DISP, 
.................... LCD_ENTRY_INC }; 
....................  
.................... BYTE const LCD_CUSTOM_CHARS[] = { 
.................... 0x1C,0x14,0x1C,0x00,0x00,0x00,0x00,0x00, // DegC 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F, // Not used 
.................... 0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F }; // Not used 
....................  
.................... BYTE lcd_line; 
.................... /* 
.................... BYTE lcd_read_nibble() { 
.................... BYTE retval; 
....................  
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
.................... retval = 0; 
.................... output_high(LCD_E); 
.................... delay_cycles(1); 
.................... retval_0 = input(LCD_DB4); 
.................... retval_1 = input(LCD_DB5); 
.................... retval_2 = input(LCD_DB6); 
.................... retval_3 = input(LCD_DB7); 
.................... output_low(LCD_E); 
.................... return(retval); 
.................... } 
.................... /* 
.................... BYTE lcd_read_byte() { 
.................... BYTE low,high; 
....................  
.................... output_high(LCD_RW); 
.................... delay_cycles(1); 
.................... high = lcd_read_nibble(); 
.................... low = lcd_read_nibble(); 
.................... return((high << 4) | low); 
.................... } 
.................... */ 
.................... void lcd_send_nibble( BYTE n ) { 
.................... 	output_bit(LCD_DB4, !!(n & 1)); 
*
0136:  BTFSC  58.0
0137:  GOTO   13A
0138:  BCF    06.4
0139:  GOTO   13B
013A:  BSF    06.4
013B:  BSF    03.5
013C:  BCF    06.4
.................... 	output_bit(LCD_DB5, !!(n & 2)); 
013D:  BCF    03.5
013E:  BTFSC  58.1
013F:  GOTO   142
0140:  BCF    06.5
0141:  GOTO   143
0142:  BSF    06.5
0143:  BSF    03.5
0144:  BCF    06.5
.................... 	output_bit(LCD_DB6, !!(n & 4)); 
0145:  BCF    03.5
0146:  BTFSC  58.2
0147:  GOTO   14A
0148:  BCF    06.6
0149:  GOTO   14B
014A:  BSF    06.6
014B:  BSF    03.5
014C:  BCF    06.6
.................... 	output_bit(LCD_DB7, !!(n & 8)); 
014D:  BCF    03.5
014E:  BTFSC  58.3
014F:  GOTO   152
0150:  BCF    06.7
0151:  GOTO   153
0152:  BSF    06.7
0153:  BSF    03.5
0154:  BCF    06.7
.................... 	delay_cycles(1); 
0155:  NOP
.................... 	output_high(LCD_E); 
0156:  BCF    06.3
0157:  BCF    03.5
0158:  BSF    06.3
.................... 	delay_cycles(1); 
0159:  NOP
.................... 	output_low(LCD_E); 
015A:  BSF    03.5
015B:  BCF    06.3
015C:  BCF    03.5
015D:  BCF    06.3
.................... } 
015E:  RETLW  00
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
.................... 	output_low(LCD_RS); 
015F:  BSF    03.5
0160:  BCF    06.2
0161:  BCF    03.5
0162:  BCF    06.2
.................... //	while (bit_test(lcd_read_byte(),7)); // wait until busy flag is low 
.................... 	if (address) 
0163:  MOVF   55,F
0164:  BTFSC  03.2
0165:  GOTO   16B
.................... 		output_high(LCD_RS); 
0166:  BSF    03.5
0167:  BCF    06.2
0168:  BCF    03.5
0169:  BSF    06.2
.................... 	else 
016A:  GOTO   16F
.................... 		output_low(LCD_RS); 
016B:  BSF    03.5
016C:  BCF    06.2
016D:  BCF    03.5
016E:  BCF    06.2
.................... //	delay_cycles(1); 
.................... //	output_low(LCD_RW); 
.................... //	delay_cycles(1); 
.................... 	output_low(LCD_E); 
016F:  BSF    03.5
0170:  BCF    06.3
0171:  BCF    03.5
0172:  BCF    06.3
.................... 	lcd_send_nibble(n >> 4); 
0173:  SWAPF  56,W
0174:  MOVWF  57
0175:  MOVLW  0F
0176:  ANDWF  57,F
0177:  MOVF   57,W
0178:  MOVWF  58
0179:  CALL   136
.................... 	lcd_send_nibble(n & 0xf); 
017A:  MOVF   56,W
017B:  ANDLW  0F
017C:  MOVWF  57
017D:  MOVWF  58
017E:  CALL   136
.................... 	delay_us(39);	 
017F:  MOVLW  40
0180:  MOVWF  77
0181:  DECFSZ 77,F
0182:  GOTO   181
0183:  GOTO   184
.................... } 
0184:  RETLW  00
....................  
.................... void lcd_init() { 
.................... BYTE i; 
.................... 	for (i=1;i<=3;++i) { 
*
0229:  MOVLW  01
022A:  MOVWF  33
022B:  MOVF   33,W
022C:  SUBLW  03
022D:  BTFSS  03.0
022E:  GOTO   238
.................... 		lcd_send_byte(0,0x20); 
022F:  CLRF   55
0230:  MOVLW  20
0231:  MOVWF  56
0232:  CALL   15F
.................... 		delay_ms(2); 
0233:  MOVLW  02
0234:  MOVWF  51
0235:  CALL   185
.................... 	} 
0236:  INCF   33,F
0237:  GOTO   22B
.................... 	for (i=0;i<=sizeof(LCD_INIT_STRING);++i){ 
0238:  CLRF   33
0239:  MOVF   33,W
023A:  SUBLW  04
023B:  BTFSS  03.0
023C:  GOTO   249
.................... 		lcd_send_byte(0, LCD_INIT_STRING[i]); 
023D:  MOVF   33,W
023E:  CALL   005
023F:  MOVWF  34
0240:  CLRF   55
0241:  MOVF   34,W
0242:  MOVWF  56
0243:  CALL   15F
.................... 		delay_ms(2); 
0244:  MOVLW  02
0245:  MOVWF  51
0246:  CALL   185
.................... 		} 
0247:  INCF   33,F
0248:  GOTO   239
.................... } 
....................  
.................... void lcd_init_custom_chars() { 
.................... BYTE i; 
....................  
.................... 	lcd_send_byte(0,LCD_CGRAM_BASE_ADDR); 
.................... 	for (i=0;i<64;i++) { 
.................... 		lcd_send_byte(1,LCD_CUSTOM_CHARS[i]); 
.................... 		delay_ms(2); 
.................... 	} 
.................... } 
.................... void lcd_gotoxy( BYTE x, BYTE y ) { 
.................... BYTE address; 
....................  
.................... 	switch(y) { 
*
0199:  MOVLW  01
019A:  SUBWF  52,W
019B:  ADDLW  FC
019C:  BTFSC  03.0
019D:  GOTO   1AC
019E:  ADDLW  04
019F:  GOTO   1B9
.................... 		case 1 : address=LCD_LINE_1; break; 
01A0:  MOVLW  80
01A1:  MOVWF  53
01A2:  GOTO   1AC
.................... 		case 2 : address=LCD_LINE_2; break; 
01A3:  MOVLW  C0
01A4:  MOVWF  53
01A5:  GOTO   1AC
.................... 		case 3 : address=LCD_LINE_3; break; 
01A6:  MOVLW  94
01A7:  MOVWF  53
01A8:  GOTO   1AC
.................... 		case 4 : address=LCD_LINE_4; break; 
01A9:  MOVLW  D4
01AA:  MOVWF  53
01AB:  GOTO   1AC
.................... 		 
.................... 	} 
.................... 	address+=x-1; 
01AC:  MOVLW  01
01AD:  SUBWF  51,W
01AE:  ADDWF  53,F
.................... 	lcd_send_byte(0,0x80 | address); 
01AF:  MOVF   53,W
01B0:  IORLW  80
01B1:  MOVWF  54
01B2:  CLRF   55
01B3:  MOVF   54,W
01B4:  MOVWF  56
01B5:  CALL   15F
.................... } 
01B6:  BCF    0A.3
01B7:  BCF    0A.4
01B8:  GOTO   1EF (RETURN)
....................  
.................... void lcd_putc( char c ) { 
.................... 	switch(c) { 
*
01C1:  MOVF   50,W
01C2:  XORLW  0C
01C3:  BTFSC  03.2
01C4:  GOTO   1CF
01C5:  XORLW  06
01C6:  BTFSC  03.2
01C7:  GOTO   1D9
01C8:  XORLW  02
01C9:  BTFSC  03.2
01CA:  GOTO   1DF
01CB:  XORLW  09
01CC:  BTFSC  03.2
01CD:  GOTO   1E4
01CE:  GOTO   1E9
.................... 		case '\f' : lcd_send_byte(0,LCD_CLR_DISP); 
01CF:  CLRF   55
01D0:  MOVLW  01
01D1:  MOVWF  56
01D2:  CALL   15F
.................... 			lcd_line=1; 
01D3:  MOVLW  01
01D4:  MOVWF  21
.................... 			delay_ms(2); break; 
01D5:  MOVLW  02
01D6:  MOVWF  51
01D7:  CALL   185
01D8:  GOTO   1EF
.................... 		case '\n' : lcd_gotoxy(1,++lcd_line); break; 
01D9:  INCF   21,F
01DA:  MOVLW  01
01DB:  MOVWF  51
01DC:  MOVF   21,W
01DD:  MOVWF  52
01DE:  GOTO   199
.................... 		case '\b' : lcd_send_byte(0,LCD_MOVE_CURSOR_LEFT); break; 
01DF:  CLRF   55
01E0:  MOVLW  10
01E1:  MOVWF  56
01E2:  CALL   15F
01E3:  GOTO   1EF
.................... 		case '\1' : lcd_send_byte(1,LCD_DEGREE_CHAR); break;				// caractere degree 
01E4:  MOVLW  01
01E5:  MOVWF  55
01E6:  CLRF   56
01E7:  CALL   15F
01E8:  GOTO   1EF
.................... 		default : lcd_send_byte(1,c); break; 
01E9:  MOVLW  01
01EA:  MOVWF  55
01EB:  MOVF   50,W
01EC:  MOVWF  56
01ED:  CALL   15F
01EE:  GOTO   1EF
.................... 	} 
.................... } 
01EF:  RETLW  00
....................  
.................... void cursor( byte c ) { 
.................... 	switch(c) { 
01F0:  MOVF   33,W
01F1:  ADDLW  FC
01F2:  BTFSC  03.0
01F3:  GOTO   20A
01F4:  ADDLW  04
01F5:  GOTO   20D
.................... 		case 0 : lcd_send_byte(0,LCD_DISP_ON);break;						// curseur OFF 
01F6:  CLRF   55
01F7:  MOVLW  0C
01F8:  MOVWF  56
01F9:  CALL   15F
01FA:  GOTO   20A
.................... 		case 1 : lcd_send_byte(0,LCD_DISP_ON_CURSOR); break;				// curseur ON 
01FB:  CLRF   55
01FC:  MOVLW  0E
01FD:  MOVWF  56
01FE:  CALL   15F
01FF:  GOTO   20A
.................... 		case 2 : lcd_send_byte(0,LCD_DISP_ON_BLINK); break;					// cursour OFF blink 
0200:  CLRF   55
0201:  MOVLW  0D
0202:  MOVWF  56
0203:  CALL   15F
0204:  GOTO   20A
.................... 		case 3 : lcd_send_byte(0,LCD_DISP_ON_CURSOR_BLINK); break;			// cursour ON blink 
0205:  CLRF   55
0206:  MOVLW  0F
0207:  MOVWF  56
0208:  CALL   15F
0209:  GOTO   20A
.................... 	} 
.................... } 
020A:  BCF    0A.3
020B:  BCF    0A.4
020C:  GOTO   25F (RETURN)
....................  
.................... /* 
.................... char lcd_getc( BYTE x, BYTE y ) { 
.................... char value; 
....................  
.................... 	lcd_gotoxy(x,y); 
.................... 	while (bit_test(lcd_read_byte(),7)); // wait until busy flag is low 
.................... 	output_high(LCD_RS); 
.................... 	value = lcd_read_byte(); 
.................... 	output_low(LCD_RS); 
.................... 	return(value); 
.................... }*/ 
....................  
....................  
....................  
....................  
.................... #define temps 1000 
....................  
.................... Byte CONST temp = 0b10010000;  // Adresse  Température [TMP100] (0x90) 
.................... Byte CONST ACC = 0b00111010;  // Adresse Accéléromètre [LIS3LV02DL] (0x3A)  
.................... Byte CONST light = 0b01000110; // Address Light [bh1710fvc-e] (0x46)  
.................... Byte CONST SRF02 = 0xE0; // Adresse USFR [SRF02] (0xE0)  
.................... Byte CONST boussole = 0b01000010; // Adresse Boussole [HMC6352] (0x42)  
....................  
.................... //-------------------------xxx------------------------ 
....................  
.................... signed long byte axe_x, axe_y, axe_z = 0; 
*
0DCB:  CLRF   26
0DCC:  CLRF   27
.................... char varbin[9]; 
.................... byte x; 
.................... boolean flagp; 
....................  
.................... //-------------------------fonction buzzer------------------------ 
.................... //permet d'emettre un son dont on peut paramétrer la fréquence et la durée 
....................  
.................... void beep(int freq, int duree) 
.................... {  
....................    setup_ccp1(CCP_PWM);                   
*
0263:  BCF    20.2
0264:  MOVF   20,W
0265:  BSF    03.5
0266:  MOVWF  07
0267:  BCF    03.5
0268:  BCF    07.2
0269:  MOVLW  0C
026A:  MOVWF  17
026B:  BSF    03.5
026C:  CLRF   1B
....................    set_pwm1_duty(freq/2); 
026D:  BCF    03.0
026E:  BCF    03.5
026F:  RRF    33,W
0270:  MOVWF  35
0271:  MOVWF  15
....................    setup_timer_2(T2_DIV_BY_16,freq,5);    
0272:  MOVLW  20
0273:  MOVWF  78
0274:  IORLW  06
0275:  MOVWF  12
0276:  MOVF   33,W
0277:  BSF    03.5
0278:  MOVWF  12
....................    while (duree--) delay_ms(10); 
0279:  BCF    03.5
027A:  MOVF   34,W
027B:  DECF   34,F
027C:  XORLW  00
027D:  BTFSC  03.2
027E:  GOTO   283
027F:  MOVLW  0A
0280:  MOVWF  51
0281:  CALL   185
0282:  GOTO   27A
....................    setup_ccp1(CCP_OFF); 
0283:  BSF    20.2
0284:  MOVF   20,W
0285:  BSF    03.5
0286:  MOVWF  07
0287:  BCF    03.5
0288:  CLRF   17
0289:  BSF    03.5
028A:  CLRF   1B
.................... } 
....................  
.................... void initialisation()  
.................... { 
.................... 	setup_adc_ports(sAN0|sAN1|sAN2|sAN3); 
*
0215:  BSF    03.5
0216:  BSF    03.6
0217:  MOVF   09,W
0218:  ANDLW  C0
0219:  MOVWF  09
021A:  BCF    03.6
021B:  BCF    1F.4
021C:  BCF    1F.5
021D:  MOVLW  00
021E:  IORLW  0F
021F:  BSF    03.6
0220:  MOVWF  08
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 					// Config ADC 
0221:  BCF    03.5
0222:  BCF    03.6
0223:  BSF    1F.6
0224:  BSF    1F.7
0225:  BSF    03.5
0226:  BSF    1F.7
0227:  BCF    03.5
0228:  BSF    1F.0
.................... 	lcd_init(); 
....................    	lcd_putc("\fScan Capteurs \n"); 
*
0249:  CLRF   33
024A:  MOVF   33,W
024B:  CALL   00D
024C:  IORLW  00
024D:  BTFSC  03.2
024E:  GOTO   253
024F:  INCF   33,F
0250:  MOVWF  50
0251:  CALL   1C1
0252:  GOTO   24A
.................... 	lcd_putc("(C)UMONS - 2011"); 
0253:  CLRF   33
0254:  MOVF   33,W
0255:  CALL   022
0256:  IORLW  00
0257:  BTFSC  03.2
0258:  GOTO   25D
0259:  INCF   33,F
025A:  MOVWF  50
025B:  CALL   1C1
025C:  GOTO   254
.................... 	cursor(0);										// curseur OFF 
025D:  CLRF   33
025E:  GOTO   1F0
.................... 	beep(200,20); 
025F:  MOVLW  C8
0260:  MOVWF  33
0261:  MOVLW  14
0262:  MOVWF  34
.................... 	delay_ms(1000);	 
*
028B:  MOVLW  04
028C:  BCF    03.5
028D:  MOVWF  33
028E:  MOVLW  FA
028F:  MOVWF  51
0290:  CALL   185
0291:  DECFSZ 33,F
0292:  GOTO   28E
.................... } 
0293:  BSF    0A.3
0294:  BCF    0A.4
0295:  GOTO   5CF (RETURN)
.................... //-------------xxx------------------ 
.................... void dec2bin(byte val) { 
.................... 	byte i,x; 
....................  
.................... 	x=0; 
*
0CFE:  CLRF   37
.................... 	for (i=7;i>0;i--)  
0CFF:  MOVLW  07
0D00:  MOVWF  36
0D01:  MOVF   36,F
0D02:  BTFSC  03.2
0D03:  GOTO   522
.................... 	{ 
.................... 		if ((val>>i)%2==0) varbin[x]='0';	 
0D04:  MOVF   35,W
0D05:  MOVWF  77
0D06:  MOVF   36,W
0D07:  MOVWF  78
0D08:  BTFSC  03.2
0D09:  GOTO   50E
0D0A:  BCF    03.0
0D0B:  RRF    77,F
0D0C:  DECFSZ 78,F
0D0D:  GOTO   50A
0D0E:  MOVF   77,W
0D0F:  ANDLW  01
0D10:  BTFSS  03.2
0D11:  GOTO   519
0D12:  MOVLW  28
0D13:  ADDWF  37,W
0D14:  MOVWF  04
0D15:  BCF    03.7
0D16:  MOVLW  30
0D17:  MOVWF  00
.................... 		else varbin[x]='1'; 
0D18:  GOTO   51F
0D19:  MOVLW  28
0D1A:  ADDWF  37,W
0D1B:  MOVWF  04
0D1C:  BCF    03.7
0D1D:  MOVLW  31
0D1E:  MOVWF  00
.................... 		x++; 
0D1F:  INCF   37,F
.................... 	}	 
0D20:  DECF   36,F
0D21:  GOTO   501
.................... 	if ((val)%2==0) varbin[x]='0'; 
0D22:  MOVF   35,W
0D23:  ANDLW  01
0D24:  BTFSS  03.2
0D25:  GOTO   52D
0D26:  MOVLW  28
0D27:  ADDWF  37,W
0D28:  MOVWF  04
0D29:  BCF    03.7
0D2A:  MOVLW  30
0D2B:  MOVWF  00
.................... 	else varbin[x]='1'; 
0D2C:  GOTO   533
0D2D:  MOVLW  28
0D2E:  ADDWF  37,W
0D2F:  MOVWF  04
0D30:  BCF    03.7
0D31:  MOVLW  31
0D32:  MOVWF  00
.................... 	varbin[x+1]='\0'; 
0D33:  MOVLW  01
0D34:  ADDWF  37,W
0D35:  ADDLW  28
0D36:  MOVWF  04
0D37:  BCF    03.7
0D38:  CLRF   00
.................... } 
....................  
.................... //-------------Lecture  I2C------------------ 
.................... signed byte lec_i2c(byte device, byte address, byte del) { 
....................    signed BYTE data; 
....................  
....................    i2c_start(); 
*
0754:  BSF    20.4
0755:  MOVF   20,W
0756:  BSF    03.5
0757:  MOVWF  07
0758:  MOVLW  04
0759:  MOVWF  77
075A:  DECFSZ 77,F
075B:  GOTO   75A
075C:  BCF    03.5
075D:  BSF    20.3
075E:  MOVF   20,W
075F:  BSF    03.5
0760:  MOVWF  07
0761:  MOVLW  03
0762:  MOVWF  77
0763:  DECFSZ 77,F
0764:  GOTO   763
0765:  BCF    03.5
0766:  BCF    07.4
0767:  BCF    20.4
0768:  MOVF   20,W
0769:  BSF    03.5
076A:  MOVWF  07
076B:  MOVLW  04
076C:  MOVWF  77
076D:  DECFSZ 77,F
076E:  GOTO   76D
076F:  BCF    03.5
0770:  BCF    07.3
0771:  BCF    20.3
0772:  MOVF   20,W
0773:  BSF    03.5
0774:  MOVWF  07
....................    i2c_write(device); 
0775:  BCF    03.5
0776:  MOVF   3D,W
0777:  MOVWF  48
0778:  CALL   2AD
....................    i2c_write(address); 
0779:  MOVF   3E,W
077A:  MOVWF  48
077B:  CALL   2AD
....................    if (del!=0) delay_ms(del); 
077C:  MOVF   3F,F
077D:  BTFSC  03.2
077E:  GOTO   782
077F:  MOVF   3F,W
0780:  MOVWF  51
0781:  CALL   185
....................    i2c_start(); 
0782:  BSF    20.4
0783:  MOVF   20,W
0784:  BSF    03.5
0785:  MOVWF  07
0786:  MOVLW  04
0787:  MOVWF  77
0788:  DECFSZ 77,F
0789:  GOTO   788
078A:  BCF    03.5
078B:  BSF    20.3
078C:  MOVF   20,W
078D:  BSF    03.5
078E:  MOVWF  07
078F:  MOVLW  03
0790:  MOVWF  77
0791:  DECFSZ 77,F
0792:  GOTO   791
0793:  BCF    03.5
0794:  BTFSS  07.3
0795:  GOTO   794
0796:  BCF    07.4
0797:  BCF    20.4
0798:  MOVF   20,W
0799:  BSF    03.5
079A:  MOVWF  07
079B:  MOVLW  04
079C:  MOVWF  77
079D:  DECFSZ 77,F
079E:  GOTO   79D
079F:  BCF    03.5
07A0:  BCF    07.3
07A1:  BCF    20.3
07A2:  MOVF   20,W
07A3:  BSF    03.5
07A4:  MOVWF  07
....................    i2c_write(device | 1); 
07A5:  BCF    03.5
07A6:  MOVF   3D,W
07A7:  IORLW  01
07A8:  MOVWF  41
07A9:  MOVWF  48
07AA:  CALL   2AD
....................    data=i2c_read(0); 
07AB:  CLRF   77
07AC:  CALL   351
07AD:  MOVF   78,W
07AE:  MOVWF  40
....................    i2c_stop(); 
07AF:  BCF    20.4
07B0:  MOVF   20,W
07B1:  BSF    03.5
07B2:  MOVWF  07
07B3:  NOP
07B4:  BCF    03.5
07B5:  BSF    20.3
07B6:  MOVF   20,W
07B7:  BSF    03.5
07B8:  MOVWF  07
07B9:  BCF    03.5
07BA:  BTFSS  07.3
07BB:  GOTO   7BA
07BC:  MOVLW  04
07BD:  MOVWF  77
07BE:  DECFSZ 77,F
07BF:  GOTO   7BE
07C0:  GOTO   7C1
07C1:  NOP
07C2:  BSF    20.4
07C3:  MOVF   20,W
07C4:  BSF    03.5
07C5:  MOVWF  07
07C6:  MOVLW  04
07C7:  MOVWF  77
07C8:  DECFSZ 77,F
07C9:  GOTO   7C8
....................    return(data); 
07CA:  BCF    03.5
07CB:  MOVF   40,W
07CC:  MOVWF  78
.................... } 
07CD:  RETLW  00
....................  
.................... //-------------Lecture  I2C  2 bytes ----------------- 
.................... signed int16 lecdb_i2c(byte device, byte address, byte del) { 
....................    BYTE dataM,dataL; 
....................    int16 data; 
....................  
....................    i2c_start(); 
*
03A5:  BSF    20.4
03A6:  MOVF   20,W
03A7:  BSF    03.5
03A8:  MOVWF  07
03A9:  MOVLW  04
03AA:  MOVWF  77
03AB:  DECFSZ 77,F
03AC:  GOTO   3AB
03AD:  BCF    03.5
03AE:  BSF    20.3
03AF:  MOVF   20,W
03B0:  BSF    03.5
03B1:  MOVWF  07
03B2:  MOVLW  03
03B3:  MOVWF  77
03B4:  DECFSZ 77,F
03B5:  GOTO   3B4
03B6:  BCF    03.5
03B7:  BCF    07.4
03B8:  BCF    20.4
03B9:  MOVF   20,W
03BA:  BSF    03.5
03BB:  MOVWF  07
03BC:  MOVLW  04
03BD:  MOVWF  77
03BE:  DECFSZ 77,F
03BF:  GOTO   3BE
03C0:  BCF    03.5
03C1:  BCF    07.3
03C2:  BCF    20.3
03C3:  MOVF   20,W
03C4:  BSF    03.5
03C5:  MOVWF  07
....................    i2c_write(device); 
03C6:  BCF    03.5
03C7:  MOVF   40,W
03C8:  MOVWF  48
03C9:  CALL   2AD
....................    i2c_write(address); 
03CA:  MOVF   41,W
03CB:  MOVWF  48
03CC:  CALL   2AD
....................    if (del!=0) delay_ms(del); 
03CD:  MOVF   42,F
03CE:  BTFSC  03.2
03CF:  GOTO   3D3
03D0:  MOVF   42,W
03D1:  MOVWF  51
03D2:  CALL   185
....................    i2c_start(); 
03D3:  BSF    20.4
03D4:  MOVF   20,W
03D5:  BSF    03.5
03D6:  MOVWF  07
03D7:  MOVLW  04
03D8:  MOVWF  77
03D9:  DECFSZ 77,F
03DA:  GOTO   3D9
03DB:  BCF    03.5
03DC:  BSF    20.3
03DD:  MOVF   20,W
03DE:  BSF    03.5
03DF:  MOVWF  07
03E0:  MOVLW  03
03E1:  MOVWF  77
03E2:  DECFSZ 77,F
03E3:  GOTO   3E2
03E4:  BCF    03.5
03E5:  BTFSS  07.3
03E6:  GOTO   3E5
03E7:  BCF    07.4
03E8:  BCF    20.4
03E9:  MOVF   20,W
03EA:  BSF    03.5
03EB:  MOVWF  07
03EC:  MOVLW  04
03ED:  MOVWF  77
03EE:  DECFSZ 77,F
03EF:  GOTO   3EE
03F0:  BCF    03.5
03F1:  BCF    07.3
03F2:  BCF    20.3
03F3:  MOVF   20,W
03F4:  BSF    03.5
03F5:  MOVWF  07
....................    i2c_write(device | 1); 
03F6:  BCF    03.5
03F7:  MOVF   40,W
03F8:  IORLW  01
03F9:  MOVWF  47
03FA:  MOVWF  48
03FB:  CALL   2AD
....................    dataM = i2c_read(1);				// Read MSB 
03FC:  MOVLW  01
03FD:  MOVWF  77
03FE:  CALL   351
03FF:  MOVF   78,W
0400:  MOVWF  43
....................    dataL = i2c_read(0);				// Read LSB 
0401:  CLRF   77
0402:  CALL   351
0403:  MOVF   78,W
0404:  MOVWF  44
....................    i2c_stop(); 
0405:  BCF    20.4
0406:  MOVF   20,W
0407:  BSF    03.5
0408:  MOVWF  07
0409:  NOP
040A:  BCF    03.5
040B:  BSF    20.3
040C:  MOVF   20,W
040D:  BSF    03.5
040E:  MOVWF  07
040F:  BCF    03.5
0410:  BTFSS  07.3
0411:  GOTO   410
0412:  MOVLW  04
0413:  MOVWF  77
0414:  DECFSZ 77,F
0415:  GOTO   414
0416:  GOTO   417
0417:  NOP
0418:  BSF    20.4
0419:  MOVF   20,W
041A:  BSF    03.5
041B:  MOVWF  07
041C:  MOVLW  04
041D:  MOVWF  77
041E:  DECFSZ 77,F
041F:  GOTO   41E
....................    data=((dataM*256)+dataL);		// True value 
0420:  BCF    03.5
0421:  CLRF   47
0422:  MOVF   44,W
0423:  ADDWF  47,W
0424:  MOVWF  45
0425:  MOVF   43,W
0426:  MOVWF  46
0427:  BTFSC  03.0
0428:  INCF   46,F
....................    return(data); 
0429:  MOVF   45,W
042A:  MOVWF  78
042B:  MOVF   46,W
042C:  MOVWF  79
.................... } 
042D:  RETLW  00
....................  
.................... //-------------Ecriture  I2C------------------ 
.................... void ecr_i2c(byte device, byte address, byte data) { 
....................    i2c_start(); 
*
0309:  BSF    20.4
030A:  MOVF   20,W
030B:  BSF    03.5
030C:  MOVWF  07
030D:  MOVLW  04
030E:  MOVWF  77
030F:  DECFSZ 77,F
0310:  GOTO   30F
0311:  BCF    03.5
0312:  BSF    20.3
0313:  MOVF   20,W
0314:  BSF    03.5
0315:  MOVWF  07
0316:  MOVLW  03
0317:  MOVWF  77
0318:  DECFSZ 77,F
0319:  GOTO   318
031A:  BCF    03.5
031B:  BCF    07.4
031C:  BCF    20.4
031D:  MOVF   20,W
031E:  BSF    03.5
031F:  MOVWF  07
0320:  MOVLW  04
0321:  MOVWF  77
0322:  DECFSZ 77,F
0323:  GOTO   322
0324:  BCF    03.5
0325:  BCF    07.3
0326:  BCF    20.3
0327:  MOVF   20,W
0328:  BSF    03.5
0329:  MOVWF  07
....................    i2c_write(device); 
032A:  BCF    03.5
032B:  MOVF   40,W
032C:  MOVWF  48
032D:  CALL   2AD
....................    i2c_write(address); 
032E:  MOVF   41,W
032F:  MOVWF  48
0330:  CALL   2AD
....................    i2c_write(data); 
0331:  MOVF   42,W
0332:  MOVWF  48
0333:  CALL   2AD
....................    i2c_stop(); 
0334:  BCF    20.4
0335:  MOVF   20,W
0336:  BSF    03.5
0337:  MOVWF  07
0338:  NOP
0339:  BCF    03.5
033A:  BSF    20.3
033B:  MOVF   20,W
033C:  BSF    03.5
033D:  MOVWF  07
033E:  BCF    03.5
033F:  BTFSS  07.3
0340:  GOTO   33F
0341:  MOVLW  04
0342:  MOVWF  77
0343:  DECFSZ 77,F
0344:  GOTO   343
0345:  GOTO   346
0346:  NOP
0347:  BSF    20.4
0348:  MOVF   20,W
0349:  BSF    03.5
034A:  MOVWF  07
034B:  MOVLW  04
034C:  MOVWF  77
034D:  DECFSZ 77,F
034E:  GOTO   34D
.................... } 
034F:  BCF    03.5
0350:  RETLW  00
....................  
.................... //-------------Lecture Accéléromètre I2C------------------ 
.................... void lecture_ACC() { 
.................... 		byte tmp=0,data1,data2; 
*
09D0:  CLRF   34
.................... 		signed int16 datax, datay, dataz=0; 
09D1:  CLRF   3B
09D2:  CLRF   3C
....................  
.................... 		ecr_i2c(ACC,0x20,0b01000111); 
09D3:  MOVLW  3A
09D4:  MOVWF  40
09D5:  MOVLW  20
09D6:  MOVWF  41
09D7:  MOVLW  47
09D8:  MOVWF  42
09D9:  BCF    0A.3
09DA:  CALL   309
09DB:  BSF    0A.3
.................... 		tmp=lec_i2c(ACC,0x27,0); 
09DC:  MOVLW  3A
09DD:  MOVWF  3D
09DE:  MOVLW  27
09DF:  MOVWF  3E
09E0:  CLRF   3F
09E1:  BCF    0A.3
09E2:  CALL   754
09E3:  BSF    0A.3
09E4:  MOVF   78,W
09E5:  MOVWF  34
....................  
.................... 		if ((tmp&0x0C)==0x0C) axe_z=lec_i2c(ACC,0x2d,0); 
09E6:  MOVF   34,W
09E7:  ANDLW  0C
09E8:  SUBLW  0C
09E9:  BTFSS  03.2
09EA:  GOTO   1FA
09EB:  MOVLW  3A
09EC:  MOVWF  3D
09ED:  MOVLW  2D
09EE:  MOVWF  3E
09EF:  CLRF   3F
09F0:  BCF    0A.3
09F1:  CALL   754
09F2:  BSF    0A.3
09F3:  CLRF   7A
09F4:  MOVF   78,W
09F5:  BTFSC  78.7
09F6:  DECF   7A,F
09F7:  MOVWF  26
09F8:  MOVF   7A,W
09F9:  MOVWF  27
.................... 		if ((tmp&0x0A)==0x0A) axe_y=lec_i2c(ACC,0x2b,0); 
09FA:  MOVF   34,W
09FB:  ANDLW  0A
09FC:  SUBLW  0A
09FD:  BTFSS  03.2
09FE:  GOTO   20E
09FF:  MOVLW  3A
0A00:  MOVWF  3D
0A01:  MOVLW  2B
0A02:  MOVWF  3E
0A03:  CLRF   3F
0A04:  BCF    0A.3
0A05:  CALL   754
0A06:  BSF    0A.3
0A07:  CLRF   7A
0A08:  MOVF   78,W
0A09:  BTFSC  78.7
0A0A:  DECF   7A,F
0A0B:  MOVWF  24
0A0C:  MOVF   7A,W
0A0D:  MOVWF  25
.................... 		if ((tmp&0x09)==0x09) axe_x=lec_i2c(ACC,0x29,0); 
0A0E:  MOVF   34,W
0A0F:  ANDLW  09
0A10:  SUBLW  09
0A11:  BTFSS  03.2
0A12:  GOTO   222
0A13:  MOVLW  3A
0A14:  MOVWF  3D
0A15:  MOVLW  29
0A16:  MOVWF  3E
0A17:  CLRF   3F
0A18:  BCF    0A.3
0A19:  CALL   754
0A1A:  BSF    0A.3
0A1B:  CLRF   7A
0A1C:  MOVF   78,W
0A1D:  BTFSC  78.7
0A1E:  DECF   7A,F
0A1F:  MOVWF  22
0A20:  MOVF   7A,W
0A21:  MOVWF  23
....................  
.................... 		datax = axe_x*18; 
0A22:  MOVF   23,W
0A23:  MOVWF  3E
0A24:  MOVF   22,W
0A25:  MOVWF  3D
0A26:  CLRF   40
0A27:  MOVLW  12
0A28:  MOVWF  3F
0A29:  BCF    0A.3
0A2A:  CALL   7CE
0A2B:  BSF    0A.3
0A2C:  MOVF   79,W
0A2D:  MOVWF  38
0A2E:  MOVF   78,W
0A2F:  MOVWF  37
.................... 		datay = axe_y*18; 
0A30:  MOVF   25,W
0A31:  MOVWF  3E
0A32:  MOVF   24,W
0A33:  MOVWF  3D
0A34:  CLRF   40
0A35:  MOVLW  12
0A36:  MOVWF  3F
0A37:  BCF    0A.3
0A38:  CALL   7CE
0A39:  BSF    0A.3
0A3A:  MOVF   79,W
0A3B:  MOVWF  3A
0A3C:  MOVF   78,W
0A3D:  MOVWF  39
.................... 		dataz = axe_z*18; 
0A3E:  MOVF   27,W
0A3F:  MOVWF  3E
0A40:  MOVF   26,W
0A41:  MOVWF  3D
0A42:  CLRF   40
0A43:  MOVLW  12
0A44:  MOVWF  3F
0A45:  BCF    0A.3
0A46:  CALL   7CE
0A47:  BSF    0A.3
0A48:  MOVF   79,W
0A49:  MOVWF  3C
0A4A:  MOVF   78,W
0A4B:  MOVWF  3B
....................  
.................... 		printf(lcd_putc,"\fCap. Accelerom. \n"); 
0A4C:  CLRF   3D
0A4D:  MOVF   3D,W
0A4E:  BCF    0A.3
0A4F:  CALL   036
0A50:  BSF    0A.3
0A51:  INCF   3D,F
0A52:  MOVWF  77
0A53:  MOVWF  50
0A54:  BCF    0A.3
0A55:  CALL   1C1
0A56:  BSF    0A.3
0A57:  MOVLW  12
0A58:  SUBWF  3D,W
0A59:  BTFSS  03.2
0A5A:  GOTO   24D
.................... 		printf(lcd_putc,"X%ld Y%ld Z%ld  ",datax,datay,dataz); 
0A5B:  MOVLW  58
0A5C:  MOVWF  50
0A5D:  BCF    0A.3
0A5E:  CALL   1C1
0A5F:  BSF    0A.3
0A60:  MOVLW  10
0A61:  MOVWF  04
0A62:  MOVF   38,W
0A63:  MOVWF  3E
0A64:  MOVF   37,W
0A65:  MOVWF  3D
0A66:  BCF    0A.3
0A67:  CALL   6D4
0A68:  BSF    0A.3
0A69:  MOVLW  20
0A6A:  MOVWF  50
0A6B:  BCF    0A.3
0A6C:  CALL   1C1
0A6D:  BSF    0A.3
0A6E:  MOVLW  59
0A6F:  MOVWF  50
0A70:  BCF    0A.3
0A71:  CALL   1C1
0A72:  BSF    0A.3
0A73:  MOVLW  10
0A74:  MOVWF  04
0A75:  MOVF   3A,W
0A76:  MOVWF  3E
0A77:  MOVF   39,W
0A78:  MOVWF  3D
0A79:  BCF    0A.3
0A7A:  CALL   6D4
0A7B:  BSF    0A.3
0A7C:  MOVLW  20
0A7D:  MOVWF  50
0A7E:  BCF    0A.3
0A7F:  CALL   1C1
0A80:  BSF    0A.3
0A81:  MOVLW  5A
0A82:  MOVWF  50
0A83:  BCF    0A.3
0A84:  CALL   1C1
0A85:  BSF    0A.3
0A86:  MOVLW  10
0A87:  MOVWF  04
0A88:  MOVF   3C,W
0A89:  MOVWF  3E
0A8A:  MOVF   3B,W
0A8B:  MOVWF  3D
0A8C:  BCF    0A.3
0A8D:  CALL   6D4
0A8E:  BSF    0A.3
0A8F:  MOVLW  20
0A90:  MOVWF  50
0A91:  BCF    0A.3
0A92:  CALL   1C1
0A93:  BSF    0A.3
0A94:  MOVLW  20
0A95:  MOVWF  50
0A96:  BCF    0A.3
0A97:  CALL   1C1
0A98:  BSF    0A.3
.................... 		data1=datax;data2=datax>>8; 
0A99:  MOVF   37,W
0A9A:  MOVWF  35
0A9B:  MOVF   38,W
0A9C:  CLRF   7A
0A9D:  MOVWF  36
.................... 		putc(entete);putc(adr_acc);putc(typ_acc_x);putc(data1);putc(data2); 
0A9E:  MOVLW  FF
0A9F:  BTFSS  0C.4
0AA0:  GOTO   29F
0AA1:  MOVWF  19
0AA2:  MOVLW  3A
0AA3:  BTFSS  0C.4
0AA4:  GOTO   2A3
0AA5:  MOVWF  19
0AA6:  MOVLW  01
0AA7:  BTFSS  0C.4
0AA8:  GOTO   2A7
0AA9:  MOVWF  19
0AAA:  MOVF   35,W
0AAB:  BTFSS  0C.4
0AAC:  GOTO   2AB
0AAD:  MOVWF  19
0AAE:  MOVF   36,W
0AAF:  BTFSS  0C.4
0AB0:  GOTO   2AF
0AB1:  MOVWF  19
.................... 		delay_ms(temps); 
0AB2:  MOVLW  04
0AB3:  MOVWF  3D
0AB4:  MOVLW  FA
0AB5:  MOVWF  51
0AB6:  BCF    0A.3
0AB7:  CALL   185
0AB8:  BSF    0A.3
0AB9:  DECFSZ 3D,F
0ABA:  GOTO   2B4
.................... 		data1=datay;data2=datay>>8; 
0ABB:  MOVF   39,W
0ABC:  MOVWF  35
0ABD:  MOVF   3A,W
0ABE:  CLRF   7A
0ABF:  MOVWF  36
.................... 		putc(entete);putc(adr_acc);putc(typ_acc_y);putc(data1);putc(data2); 
0AC0:  MOVLW  FF
0AC1:  BTFSS  0C.4
0AC2:  GOTO   2C1
0AC3:  MOVWF  19
0AC4:  MOVLW  3A
0AC5:  BTFSS  0C.4
0AC6:  GOTO   2C5
0AC7:  MOVWF  19
0AC8:  MOVLW  02
0AC9:  BTFSS  0C.4
0ACA:  GOTO   2C9
0ACB:  MOVWF  19
0ACC:  MOVF   35,W
0ACD:  BTFSS  0C.4
0ACE:  GOTO   2CD
0ACF:  MOVWF  19
0AD0:  MOVF   36,W
0AD1:  BTFSS  0C.4
0AD2:  GOTO   2D1
0AD3:  MOVWF  19
.................... 		delay_ms(temps); 
0AD4:  MOVLW  04
0AD5:  MOVWF  3D
0AD6:  MOVLW  FA
0AD7:  MOVWF  51
0AD8:  BCF    0A.3
0AD9:  CALL   185
0ADA:  BSF    0A.3
0ADB:  DECFSZ 3D,F
0ADC:  GOTO   2D6
.................... 		data1=dataz;data2=dataz>>8; 
0ADD:  MOVF   3B,W
0ADE:  MOVWF  35
0ADF:  MOVF   3C,W
0AE0:  CLRF   7A
0AE1:  MOVWF  36
.................... 		putc(entete);putc(adr_acc);putc(typ_acc_z);putc(data1);putc(data2); 
0AE2:  MOVLW  FF
0AE3:  BTFSS  0C.4
0AE4:  GOTO   2E3
0AE5:  MOVWF  19
0AE6:  MOVLW  3A
0AE7:  BTFSS  0C.4
0AE8:  GOTO   2E7
0AE9:  MOVWF  19
0AEA:  MOVLW  03
0AEB:  BTFSS  0C.4
0AEC:  GOTO   2EB
0AED:  MOVWF  19
0AEE:  MOVF   35,W
0AEF:  BTFSS  0C.4
0AF0:  GOTO   2EF
0AF1:  MOVWF  19
0AF2:  MOVF   36,W
0AF3:  BTFSS  0C.4
0AF4:  GOTO   2F3
0AF5:  MOVWF  19
.................... } 
....................  
.................... //------------- Lecture Temperature ------------------ 
.................... void lecture_temp() { 
.................... 		float celcius; 
.................... 		float val; 
.................... 		int16 valt; 
.................... 		byte data1,data2; 
....................  
.................... 		ecr_i2c(temp,0x01,0x60); 
*
088E:  MOVLW  90
088F:  MOVWF  40
0890:  MOVLW  01
0891:  MOVWF  41
0892:  MOVLW  60
0893:  MOVWF  42
0894:  BCF    0A.3
0895:  CALL   309
0896:  BSF    0A.3
.................... 		celcius=lecdb_i2c(temp,0b00000000,350); 
0897:  MOVLW  90
0898:  MOVWF  40
0899:  CLRF   41
089A:  MOVLW  5E
089B:  MOVWF  42
089C:  BCF    0A.3
089D:  CALL   3A5
089E:  BSF    0A.3
089F:  MOVF   79,W
08A0:  MOVWF  41
08A1:  MOVF   78,W
08A2:  MOVWF  40
*
08C7:  MOVF   7A,W
08C8:  MOVWF  37
08C9:  MOVF   79,W
08CA:  MOVWF  36
08CB:  MOVF   78,W
08CC:  MOVWF  35
08CD:  MOVF   77,W
08CE:  MOVWF  34
.................... 		val=(celcius/256); 
08CF:  MOVF   37,W
08D0:  MOVWF  4C
08D1:  MOVF   36,W
08D2:  MOVWF  4B
08D3:  MOVF   35,W
08D4:  MOVWF  4A
08D5:  MOVF   34,W
08D6:  MOVWF  49
08D7:  CLRF   50
08D8:  CLRF   4F
08D9:  CLRF   4E
08DA:  MOVLW  87
08DB:  MOVWF  4D
08DC:  BCF    0A.3
08DD:  CALL   42E
08DE:  BSF    0A.3
08DF:  MOVF   7A,W
08E0:  MOVWF  3B
08E1:  MOVF   79,W
08E2:  MOVWF  3A
08E3:  MOVF   78,W
08E4:  MOVWF  39
08E5:  MOVF   77,W
08E6:  MOVWF  38
.................... 		valt=celcius; 
08E7:  MOVF   37,W
08E8:  MOVWF  4C
08E9:  MOVF   36,W
08EA:  MOVWF  4B
08EB:  MOVF   35,W
08EC:  MOVWF  4A
08ED:  MOVF   34,W
08EE:  MOVWF  49
08EF:  BCF    0A.3
08F0:  CALL   4F8
08F1:  BSF    0A.3
08F2:  MOVF   79,W
08F3:  MOVWF  3D
08F4:  MOVF   78,W
08F5:  MOVWF  3C
.................... 		data1=valt; 
08F6:  MOVF   3C,W
08F7:  MOVWF  3E
.................... 		data2=valt>>8; 
08F8:  MOVF   3D,W
08F9:  MOVWF  3F
.................... 		printf(lcd_putc,"\fCap. Temperature\n"); 
08FA:  CLRF   40
08FB:  MOVF   40,W
08FC:  BCF    0A.3
08FD:  CALL   04D
08FE:  BSF    0A.3
08FF:  INCF   40,F
0900:  MOVWF  77
0901:  MOVWF  50
0902:  BCF    0A.3
0903:  CALL   1C1
0904:  BSF    0A.3
0905:  MOVLW  12
0906:  SUBWF  40,W
0907:  BTFSS  03.2
0908:  GOTO   0FB
.................... 		printf(lcd_putc,"Temp.: %3.3f C      ",val); 
0909:  CLRF   40
090A:  MOVF   40,W
090B:  BCF    0A.3
090C:  CALL   064
090D:  BSF    0A.3
090E:  INCF   40,F
090F:  MOVWF  77
0910:  MOVWF  50
0911:  BCF    0A.3
0912:  CALL   1C1
0913:  BSF    0A.3
0914:  MOVLW  07
0915:  SUBWF  40,W
0916:  BTFSS  03.2
0917:  GOTO   10A
0918:  MOVLW  89
0919:  MOVWF  04
091A:  MOVF   3B,W
091B:  MOVWF  44
091C:  MOVF   3A,W
091D:  MOVWF  43
091E:  MOVF   39,W
091F:  MOVWF  42
0920:  MOVF   38,W
0921:  MOVWF  41
0922:  MOVLW  03
0923:  MOVWF  45
0924:  BCF    0A.3
0925:  GOTO   5CE
0926:  BSF    0A.3
0927:  MOVLW  20
0928:  MOVWF  50
0929:  BCF    0A.3
092A:  CALL   1C1
092B:  BSF    0A.3
092C:  MOVLW  43
092D:  MOVWF  50
092E:  BCF    0A.3
092F:  CALL   1C1
0930:  BSF    0A.3
0931:  MOVLW  06
0932:  MOVWF  41
0933:  MOVLW  20
0934:  MOVWF  50
0935:  BCF    0A.3
0936:  CALL   1C1
0937:  BSF    0A.3
0938:  DECFSZ 41,F
0939:  GOTO   133
.................... 		putc(entete);putc(adr_temp);putc(typ_temp);putc(data1);putc(data2); 
093A:  MOVLW  FF
093B:  BTFSS  0C.4
093C:  GOTO   13B
093D:  MOVWF  19
093E:  MOVLW  90
093F:  BTFSS  0C.4
0940:  GOTO   13F
0941:  MOVWF  19
0942:  MOVLW  04
0943:  BTFSS  0C.4
0944:  GOTO   143
0945:  MOVWF  19
0946:  MOVF   3E,W
0947:  BTFSS  0C.4
0948:  GOTO   147
0949:  MOVWF  19
094A:  MOVF   3F,W
094B:  BTFSS  0C.4
094C:  GOTO   14B
094D:  MOVWF  19
.................... } 
....................  
.................... //-------------Lecture Light I2C------------------ 
.................... void lecture_light() { 
.................... 		int16 val=0; 
*
094F:  CLRF   34
0950:  CLRF   35
.................... 		byte data1,data2; 
....................  
.................... 		val=lecdb_i2c(light,0x20,120);    		//One Time H-Resolution Mode 
0951:  MOVLW  46
0952:  MOVWF  40
0953:  MOVLW  20
0954:  MOVWF  41
0955:  MOVLW  78
0956:  MOVWF  42
0957:  BCF    0A.3
0958:  CALL   3A5
0959:  BSF    0A.3
095A:  MOVF   79,W
095B:  MOVWF  35
095C:  MOVF   78,W
095D:  MOVWF  34
.................... 		val=val/1.2; 
095E:  MOVF   35,W
095F:  MOVWF  46
0960:  MOVF   34,W
0961:  MOVWF  45
0962:  BCF    0A.3
0963:  CALL   6B7
0964:  BSF    0A.3
0965:  MOVF   7A,W
0966:  MOVWF  4C
0967:  MOVF   79,W
0968:  MOVWF  4B
0969:  MOVF   78,W
096A:  MOVWF  4A
096B:  MOVF   77,W
096C:  MOVWF  49
096D:  MOVLW  9A
096E:  MOVWF  50
096F:  MOVLW  99
0970:  MOVWF  4F
0971:  MOVLW  19
0972:  MOVWF  4E
0973:  MOVLW  7F
0974:  MOVWF  4D
0975:  BCF    0A.3
0976:  CALL   42E
0977:  BSF    0A.3
0978:  MOVF   7A,W
0979:  MOVWF  4C
097A:  MOVF   79,W
097B:  MOVWF  4B
097C:  MOVF   78,W
097D:  MOVWF  4A
097E:  MOVF   77,W
097F:  MOVWF  49
0980:  BCF    0A.3
0981:  CALL   4F8
0982:  BSF    0A.3
0983:  MOVF   79,W
0984:  MOVWF  35
0985:  MOVF   78,W
0986:  MOVWF  34
.................... 		data1=val;								// LSB 
0987:  MOVF   34,W
0988:  MOVWF  36
.................... 		data2=val>>8; 
0989:  MOVF   35,W
098A:  MOVWF  37
.................... 		printf(lcd_putc,"\fCap. Luminosite \n"); 
098B:  CLRF   38
098C:  MOVF   38,W
098D:  BCF    0A.3
098E:  CALL   077
098F:  BSF    0A.3
0990:  INCF   38,F
0991:  MOVWF  77
0992:  MOVWF  50
0993:  BCF    0A.3
0994:  CALL   1C1
0995:  BSF    0A.3
0996:  MOVLW  12
0997:  SUBWF  38,W
0998:  BTFSS  03.2
0999:  GOTO   18C
....................  		printf(lcd_putc,"Lux:%ld        ",val);	 
099A:  CLRF   38
099B:  MOVF   38,W
099C:  BCF    0A.3
099D:  CALL   08E
099E:  BSF    0A.3
099F:  INCF   38,F
09A0:  MOVWF  77
09A1:  MOVWF  50
09A2:  BCF    0A.3
09A3:  CALL   1C1
09A4:  BSF    0A.3
09A5:  MOVLW  04
09A6:  SUBWF  38,W
09A7:  BTFSS  03.2
09A8:  GOTO   19B
09A9:  MOVLW  10
09AA:  MOVWF  04
09AB:  MOVF   35,W
09AC:  MOVWF  3E
09AD:  MOVF   34,W
09AE:  MOVWF  3D
09AF:  BCF    0A.3
09B0:  CALL   6D4
09B1:  BSF    0A.3
09B2:  MOVLW  08
09B3:  MOVWF  39
09B4:  MOVLW  20
09B5:  MOVWF  50
09B6:  BCF    0A.3
09B7:  CALL   1C1
09B8:  BSF    0A.3
09B9:  DECFSZ 39,F
09BA:  GOTO   1B4
.................... 		putc(entete);putc(adr_light);putc(typ_light);putc(data1);putc(data2); 
09BB:  MOVLW  FF
09BC:  BTFSS  0C.4
09BD:  GOTO   1BC
09BE:  MOVWF  19
09BF:  MOVLW  46
09C0:  BTFSS  0C.4
09C1:  GOTO   1C0
09C2:  MOVWF  19
09C3:  MOVLW  05
09C4:  BTFSS  0C.4
09C5:  GOTO   1C4
09C6:  MOVWF  19
09C7:  MOVF   36,W
09C8:  BTFSS  0C.4
09C9:  GOTO   1C8
09CA:  MOVWF  19
09CB:  MOVF   37,W
09CC:  BTFSS  0C.4
09CD:  GOTO   1CC
09CE:  MOVWF  19
.................... } 
....................  
.................... //-------------Lecture Distance I2C------------------ 
.................... void lecture_SRF02() { 
.................... 		byte t0, t1=0; 
*
0AF7:  CLRF   35
.................... 		int16 val=0; 
0AF8:  CLRF   36
0AF9:  CLRF   37
....................  
.................... 		ecr_i2c(SRF02,0x00,0x51); // Commande 
0AFA:  MOVLW  E0
0AFB:  MOVWF  40
0AFC:  CLRF   41
0AFD:  MOVLW  51
0AFE:  MOVWF  42
0AFF:  BCF    0A.3
0B00:  CALL   309
0B01:  BSF    0A.3
.................... 		delay_ms(80); 
0B02:  MOVLW  50
0B03:  MOVWF  51
0B04:  BCF    0A.3
0B05:  CALL   185
0B06:  BSF    0A.3
.................... 		t1=lec_i2c(SRF02,0x02,0); 
0B07:  MOVLW  E0
0B08:  MOVWF  3D
0B09:  MOVLW  02
0B0A:  MOVWF  3E
0B0B:  CLRF   3F
0B0C:  BCF    0A.3
0B0D:  CALL   754
0B0E:  BSF    0A.3
0B0F:  MOVF   78,W
0B10:  MOVWF  35
.................... 		t0=lec_i2c(SRF02,0x03,0); 
0B11:  MOVLW  E0
0B12:  MOVWF  3D
0B13:  MOVLW  03
0B14:  MOVWF  3E
0B15:  CLRF   3F
0B16:  BCF    0A.3
0B17:  CALL   754
0B18:  BSF    0A.3
0B19:  MOVF   78,W
0B1A:  MOVWF  34
.................... 		val=t0+(t1*256); 
0B1B:  MOVLW  00
0B1C:  ADDWF  34,W
0B1D:  MOVWF  36
0B1E:  MOVF   35,W
0B1F:  MOVWF  37
0B20:  BTFSC  03.0
0B21:  INCF   37,F
.................... 		printf(lcd_putc,"\fCapt. Distance \n"); 
0B22:  CLRF   38
0B23:  MOVF   38,W
0B24:  BCF    0A.3
0B25:  CALL   09A
0B26:  BSF    0A.3
0B27:  INCF   38,F
0B28:  MOVWF  77
0B29:  MOVWF  50
0B2A:  BCF    0A.3
0B2B:  CALL   1C1
0B2C:  BSF    0A.3
0B2D:  MOVLW  11
0B2E:  SUBWF  38,W
0B2F:  BTFSS  03.2
0B30:  GOTO   323
....................  		printf(lcd_putc,"Dist:%ld Cm      ",val); 
0B31:  CLRF   38
0B32:  MOVF   38,W
0B33:  BCF    0A.3
0B34:  CALL   0B0
0B35:  BSF    0A.3
0B36:  INCF   38,F
0B37:  MOVWF  77
0B38:  MOVWF  50
0B39:  BCF    0A.3
0B3A:  CALL   1C1
0B3B:  BSF    0A.3
0B3C:  MOVLW  05
0B3D:  SUBWF  38,W
0B3E:  BTFSS  03.2
0B3F:  GOTO   332
0B40:  MOVLW  10
0B41:  MOVWF  04
0B42:  MOVF   37,W
0B43:  MOVWF  3E
0B44:  MOVF   36,W
0B45:  MOVWF  3D
0B46:  BCF    0A.3
0B47:  CALL   6D4
0B48:  BSF    0A.3
0B49:  MOVLW  20
0B4A:  MOVWF  50
0B4B:  BCF    0A.3
0B4C:  CALL   1C1
0B4D:  BSF    0A.3
0B4E:  MOVLW  43
0B4F:  MOVWF  50
0B50:  BCF    0A.3
0B51:  CALL   1C1
0B52:  BSF    0A.3
0B53:  MOVLW  6D
0B54:  MOVWF  50
0B55:  BCF    0A.3
0B56:  CALL   1C1
0B57:  BSF    0A.3
0B58:  MOVLW  06
0B59:  MOVWF  39
0B5A:  MOVLW  20
0B5B:  MOVWF  50
0B5C:  BCF    0A.3
0B5D:  CALL   1C1
0B5E:  BSF    0A.3
0B5F:  DECFSZ 39,F
0B60:  GOTO   35A
.................... 		putc(entete);putc(adr_srf02);putc(typ_srf02);putc(t0);putc(t1); 
0B61:  MOVLW  FF
0B62:  BTFSS  0C.4
0B63:  GOTO   362
0B64:  MOVWF  19
0B65:  MOVLW  E0
0B66:  BTFSS  0C.4
0B67:  GOTO   366
0B68:  MOVWF  19
0B69:  MOVLW  06
0B6A:  BTFSS  0C.4
0B6B:  GOTO   36A
0B6C:  MOVWF  19
0B6D:  MOVF   34,W
0B6E:  BTFSS  0C.4
0B6F:  GOTO   36E
0B70:  MOVWF  19
0B71:  MOVF   35,W
0B72:  BTFSS  0C.4
0B73:  GOTO   372
0B74:  MOVWF  19
.................... } 
....................  
.................... //-------------Lecture Boussole I2C------------------ 
.................... void lecture_boussole() { 
.................... 		int16 val=0; 
*
0B76:  CLRF   34
0B77:  CLRF   35
.................... 		byte data1,data2; 
....................  
.................... 		val=lecdb_i2c(boussole,0x41,10); 
0B78:  MOVLW  42
0B79:  MOVWF  40
0B7A:  MOVLW  41
0B7B:  MOVWF  41
0B7C:  MOVLW  0A
0B7D:  MOVWF  42
0B7E:  BCF    0A.3
0B7F:  CALL   3A5
0B80:  BSF    0A.3
0B81:  MOVF   79,W
0B82:  MOVWF  35
0B83:  MOVF   78,W
0B84:  MOVWF  34
.................... 		val=val/10;							// récupération de la valeur avant virgule 
0B85:  MOVF   35,W
0B86:  MOVWF  39
0B87:  MOVF   34,W
0B88:  MOVWF  38
0B89:  CLRF   3B
0B8A:  MOVLW  0A
0B8B:  MOVWF  3A
*
0BB0:  MOVF   79,W
0BB1:  MOVWF  35
0BB2:  MOVF   78,W
0BB3:  MOVWF  34
.................... 		data1=val;								// LSB 
0BB4:  MOVF   34,W
0BB5:  MOVWF  36
.................... 		data2=val>>8; 
0BB6:  MOVF   35,W
0BB7:  MOVWF  37
.................... 		printf(lcd_putc,"\fCap. Boussole   \n"); 
0BB8:  CLRF   38
0BB9:  MOVF   38,W
0BBA:  BCF    0A.3
0BBB:  CALL   0C0
0BBC:  BSF    0A.3
0BBD:  INCF   38,F
0BBE:  MOVWF  77
0BBF:  MOVWF  50
0BC0:  BCF    0A.3
0BC1:  CALL   1C1
0BC2:  BSF    0A.3
0BC3:  MOVLW  0E
0BC4:  SUBWF  38,W
0BC5:  BTFSS  03.2
0BC6:  GOTO   3B9
0BC7:  MOVLW  03
0BC8:  MOVWF  39
0BC9:  MOVLW  20
0BCA:  MOVWF  50
0BCB:  BCF    0A.3
0BCC:  CALL   1C1
0BCD:  BSF    0A.3
0BCE:  DECFSZ 39,F
0BCF:  GOTO   3C9
0BD0:  MOVLW  0A
0BD1:  MOVWF  50
0BD2:  BCF    0A.3
0BD3:  CALL   1C1
0BD4:  BSF    0A.3
....................  		printf(lcd_putc,"Degres:%ld       ",val); 
0BD5:  CLRF   38
0BD6:  MOVF   38,W
0BD7:  BCF    0A.3
0BD8:  CALL   0D4
0BD9:  BSF    0A.3
0BDA:  INCF   38,F
0BDB:  MOVWF  77
0BDC:  MOVWF  50
0BDD:  BCF    0A.3
0BDE:  CALL   1C1
0BDF:  BSF    0A.3
0BE0:  MOVLW  07
0BE1:  SUBWF  38,W
0BE2:  BTFSS  03.2
0BE3:  GOTO   3D6
0BE4:  MOVLW  10
0BE5:  MOVWF  04
0BE6:  MOVF   35,W
0BE7:  MOVWF  3E
0BE8:  MOVF   34,W
0BE9:  MOVWF  3D
0BEA:  BCF    0A.3
0BEB:  CALL   6D4
0BEC:  BSF    0A.3
0BED:  MOVLW  07
0BEE:  MOVWF  39
0BEF:  MOVLW  20
0BF0:  MOVWF  50
0BF1:  BCF    0A.3
0BF2:  CALL   1C1
0BF3:  BSF    0A.3
0BF4:  DECFSZ 39,F
0BF5:  GOTO   3EF
.................... 		putc(entete);putc(adr_boussole);putc(typ_boussole);putc(data1);;putc(data2); 
0BF6:  MOVLW  FF
0BF7:  BTFSS  0C.4
0BF8:  GOTO   3F7
0BF9:  MOVWF  19
0BFA:  MOVLW  42
0BFB:  BTFSS  0C.4
0BFC:  GOTO   3FB
0BFD:  MOVWF  19
0BFE:  MOVLW  0C
0BFF:  BTFSS  0C.4
0C00:  GOTO   3FF
0C01:  MOVWF  19
0C02:  MOVF   36,W
0C03:  BTFSS  0C.4
0C04:  GOTO   403
0C05:  MOVWF  19
0C06:  MOVF   37,W
0C07:  BTFSS  0C.4
0C08:  GOTO   407
0C09:  MOVWF  19
.................... } 
....................  
.................... //------------------------xxx--------------------- 
.................... void lecture_ADC() { 
.................... 	byte i,data1,data2; 
.................... 	long int valeur,val[5]; 
....................  
.................... 			 
.................... 		for (i=0;i<4;++i) { 
*
0C0B:  CLRF   34
0C0C:  MOVF   34,W
0C0D:  SUBLW  03
0C0E:  BTFSS  03.0
0C0F:  GOTO   471
.................... 			set_adc_channel(i);							// selection canal 1 
0C10:  RLF    34,W
0C11:  MOVWF  77
0C12:  RLF    77,F
0C13:  MOVLW  FC
0C14:  ANDWF  77,F
0C15:  MOVF   1F,W
0C16:  ANDLW  C3
0C17:  IORWF  77,W
0C18:  MOVWF  1F
.................... 			delay_us(10); 
0C19:  MOVLW  10
0C1A:  MOVWF  77
0C1B:  DECFSZ 77,F
0C1C:  GOTO   41B
0C1D:  NOP
.................... 			valeur= read_ADC(); 
0C1E:  BSF    1F.1
0C1F:  BTFSC  1F.1
0C20:  GOTO   41F
0C21:  BSF    03.5
0C22:  MOVF   1E,W
0C23:  BCF    03.5
0C24:  MOVWF  37
0C25:  MOVF   1E,W
0C26:  MOVWF  38
.................... 			val[i]=((valeur*4.88)/100); 
0C27:  BCF    03.0
0C28:  RLF    34,W
0C29:  ADDLW  39
0C2A:  MOVWF  04
0C2B:  BCF    03.7
0C2C:  MOVF   38,W
0C2D:  MOVWF  46
0C2E:  MOVF   37,W
0C2F:  MOVWF  45
0C30:  BCF    0A.3
0C31:  CALL   6B7
0C32:  BSF    0A.3
0C33:  MOVF   7A,W
0C34:  MOVWF  51
0C35:  MOVF   79,W
0C36:  MOVWF  50
0C37:  MOVF   78,W
0C38:  MOVWF  4F
0C39:  MOVF   77,W
0C3A:  MOVWF  4E
0C3B:  MOVLW  F6
0C3C:  MOVWF  55
0C3D:  MOVLW  28
0C3E:  MOVWF  54
0C3F:  MOVLW  1C
0C40:  MOVWF  53
0C41:  MOVLW  81
0C42:  MOVWF  52
0C43:  BCF    0A.3
0C44:  CALL   517
0C45:  BSF    0A.3
0C46:  MOVF   77,W
0C47:  MOVWF  45
0C48:  MOVF   78,W
0C49:  MOVWF  46
0C4A:  MOVF   79,W
0C4B:  MOVWF  47
0C4C:  MOVF   7A,W
0C4D:  MOVWF  48
0C4E:  MOVWF  4C
0C4F:  MOVF   79,W
0C50:  MOVWF  4B
0C51:  MOVF   78,W
0C52:  MOVWF  4A
0C53:  MOVF   77,W
0C54:  MOVWF  49
0C55:  CLRF   50
0C56:  CLRF   4F
0C57:  MOVLW  48
0C58:  MOVWF  4E
0C59:  MOVLW  85
0C5A:  MOVWF  4D
0C5B:  BCF    0A.3
0C5C:  CALL   42E
0C5D:  BSF    0A.3
0C5E:  MOVF   7A,W
0C5F:  MOVWF  4C
0C60:  MOVF   79,W
0C61:  MOVWF  4B
0C62:  MOVF   78,W
0C63:  MOVWF  4A
0C64:  MOVF   77,W
0C65:  MOVWF  49
0C66:  BCF    0A.3
0C67:  CALL   4F8
0C68:  BSF    0A.3
0C69:  INCF   04,F
0C6A:  MOVF   79,W
0C6B:  MOVWF  00
0C6C:  DECF   04,F
0C6D:  MOVF   78,W
0C6E:  MOVWF  00
.................... 		}		 
0C6F:  INCF   34,F
0C70:  GOTO   40C
.................... 		data1=val[1]; 
0C71:  MOVF   3B,W
0C72:  MOVWF  35
.................... 		data2=val[1]>>8; 
0C73:  MOVF   3C,W
0C74:  MOVWF  36
.................... 		printf(lcd_putc,"\fEntrees ADC     \n"); 
0C75:  CLRF   43
0C76:  MOVF   43,W
0C77:  BCF    0A.3
0C78:  CALL   0E3
0C79:  BSF    0A.3
0C7A:  INCF   43,F
0C7B:  MOVWF  77
0C7C:  MOVWF  50
0C7D:  BCF    0A.3
0C7E:  CALL   1C1
0C7F:  BSF    0A.3
0C80:  MOVLW  0C
0C81:  SUBWF  43,W
0C82:  BTFSS  03.2
0C83:  GOTO   476
0C84:  MOVLW  05
0C85:  MOVWF  44
0C86:  MOVLW  20
0C87:  MOVWF  50
0C88:  BCF    0A.3
0C89:  CALL   1C1
0C8A:  BSF    0A.3
0C8B:  DECFSZ 44,F
0C8C:  GOTO   486
0C8D:  MOVLW  0A
0C8E:  MOVWF  50
0C8F:  BCF    0A.3
0C90:  CALL   1C1
0C91:  BSF    0A.3
.................... 		printf(lcd_putc,"%1.1w %1.1w %1.1w %1.1w ",val[0],val[1],val[2],val[3]); 
0C92:  MOVLW  41
0C93:  MOVWF  04
0C94:  CLRF   46
0C95:  CLRF   45
0C96:  MOVF   3A,W
0C97:  MOVWF  44
0C98:  MOVF   39,W
0C99:  MOVWF  43
0C9A:  MOVLW  01
0C9B:  MOVWF  47
0C9C:  CALL   000
0C9D:  MOVLW  20
0C9E:  MOVWF  50
0C9F:  BCF    0A.3
0CA0:  CALL   1C1
0CA1:  BSF    0A.3
0CA2:  MOVLW  41
0CA3:  MOVWF  04
0CA4:  CLRF   46
0CA5:  CLRF   45
0CA6:  MOVF   3C,W
0CA7:  MOVWF  44
0CA8:  MOVF   3B,W
0CA9:  MOVWF  43
0CAA:  MOVLW  01
0CAB:  MOVWF  47
0CAC:  CALL   000
0CAD:  MOVLW  20
0CAE:  MOVWF  50
0CAF:  BCF    0A.3
0CB0:  CALL   1C1
0CB1:  BSF    0A.3
0CB2:  MOVLW  41
0CB3:  MOVWF  04
0CB4:  CLRF   46
0CB5:  CLRF   45
0CB6:  MOVF   3E,W
0CB7:  MOVWF  44
0CB8:  MOVF   3D,W
0CB9:  MOVWF  43
0CBA:  MOVLW  01
0CBB:  MOVWF  47
0CBC:  CALL   000
0CBD:  MOVLW  20
0CBE:  MOVWF  50
0CBF:  BCF    0A.3
0CC0:  CALL   1C1
0CC1:  BSF    0A.3
0CC2:  MOVLW  41
0CC3:  MOVWF  04
0CC4:  CLRF   46
0CC5:  CLRF   45
0CC6:  MOVF   40,W
0CC7:  MOVWF  44
0CC8:  MOVF   3F,W
0CC9:  MOVWF  43
0CCA:  MOVLW  01
0CCB:  MOVWF  47
0CCC:  CALL   000
0CCD:  MOVLW  20
0CCE:  MOVWF  50
0CCF:  BCF    0A.3
0CD0:  CALL   1C1
0CD1:  BSF    0A.3
.................... 		putc(entete);putc(adr_inout);putc(typ_adc01);putc(data1);putc(data2); 
0CD2:  MOVLW  FF
0CD3:  BTFSS  0C.4
0CD4:  GOTO   4D3
0CD5:  MOVWF  19
0CD6:  MOVLW  00
0CD7:  BTFSS  0C.4
0CD8:  GOTO   4D7
0CD9:  MOVWF  19
0CDA:  MOVLW  07
0CDB:  BTFSS  0C.4
0CDC:  GOTO   4DB
0CDD:  MOVWF  19
0CDE:  MOVF   35,W
0CDF:  BTFSS  0C.4
0CE0:  GOTO   4DF
0CE1:  MOVWF  19
0CE2:  MOVF   36,W
0CE3:  BTFSS  0C.4
0CE4:  GOTO   4E3
0CE5:  MOVWF  19
.................... } 
....................  
.................... //------------------------xxx--------------------- 
.................... void lecture_port() { 
.................... 	byte data; 
....................  
.................... 		data=input_d(); 
*
0CE7:  MOVLW  FF
0CE8:  BSF    03.5
0CE9:  MOVWF  08
0CEA:  BCF    03.5
0CEB:  MOVF   08,W
0CEC:  MOVWF  34
.................... 		printf(lcd_putc,"\fEntrees Digital \n"); 
0CED:  CLRF   35
0CEE:  MOVF   35,W
0CEF:  BCF    0A.3
0CF0:  CALL   0F5
0CF1:  BSF    0A.3
0CF2:  INCF   35,F
0CF3:  MOVWF  77
0CF4:  MOVWF  50
0CF5:  BCF    0A.3
0CF6:  CALL   1C1
0CF7:  BSF    0A.3
0CF8:  MOVLW  12
0CF9:  SUBWF  35,W
0CFA:  BTFSS  03.2
0CFB:  GOTO   4EE
.................... 		dec2bin(data); 
0CFC:  MOVF   34,W
0CFD:  MOVWF  35
.................... 		printf(lcd_putc,"%sb %2Xh",varbin,data); 
*
0D39:  MOVLW  28
0D3A:  MOVWF  04
0D3B:  BCF    03.7
0D3C:  MOVLW  00
0D3D:  IORWF  00,W
0D3E:  BTFSC  03.2
0D3F:  GOTO   552
0D40:  CLRF   36
0D41:  MOVF   04,W
0D42:  MOVWF  35
0D43:  BCF    36.0
0D44:  BTFSC  03.7
0D45:  BSF    36.0
0D46:  MOVF   00,W
0D47:  MOVWF  50
0D48:  BCF    0A.3
0D49:  CALL   1C1
0D4A:  BSF    0A.3
0D4B:  MOVF   35,W
0D4C:  MOVWF  04
0D4D:  BCF    03.7
0D4E:  BTFSC  36.0
0D4F:  BSF    03.7
0D50:  INCF   04,F
0D51:  GOTO   53C
0D52:  MOVLW  62
0D53:  MOVWF  50
0D54:  BCF    0A.3
0D55:  CALL   1C1
0D56:  BSF    0A.3
0D57:  MOVLW  20
0D58:  MOVWF  50
0D59:  BCF    0A.3
0D5A:  CALL   1C1
0D5B:  BSF    0A.3
0D5C:  MOVF   34,W
0D5D:  MOVWF  37
0D5E:  MOVLW  37
0D5F:  MOVWF  38
*
0D84:  MOVLW  68
0D85:  MOVWF  50
0D86:  BCF    0A.3
0D87:  CALL   1C1
0D88:  BSF    0A.3
.................... 		putc(entete);putc(adr_inout);putc(typ_inout);putc(data);putc(0); 
0D89:  MOVLW  FF
0D8A:  BTFSS  0C.4
0D8B:  GOTO   58A
0D8C:  MOVWF  19
0D8D:  MOVLW  00
0D8E:  BTFSS  0C.4
0D8F:  GOTO   58E
0D90:  MOVWF  19
0D91:  MOVLW  00
0D92:  BTFSS  0C.4
0D93:  GOTO   592
0D94:  MOVWF  19
0D95:  MOVF   34,W
0D96:  BTFSS  0C.4
0D97:  GOTO   596
0D98:  MOVWF  19
0D99:  MOVLW  00
0D9A:  BTFSS  0C.4
0D9B:  GOTO   59A
0D9C:  MOVWF  19
.................... } 
....................  
.................... //-------------------------xxx------------------------ 
.................... void lect_capteurs(byte cap) { 
....................  
.................... 		switch (cap) { 
*
0877:  MOVF   33,W
0878:  XORLW  00
0879:  BTFSC  03.2
087A:  GOTO   08E
087B:  XORLW  01
087C:  BTFSC  03.2
087D:  GOTO   14F
087E:  XORLW  03
087F:  BTFSC  03.2
0880:  GOTO   1D0
0881:  XORLW  01
0882:  BTFSC  03.2
0883:  GOTO   2F7
0884:  XORLW  07
0885:  BTFSC  03.2
0886:  GOTO   376
0887:  XORLW  01
0888:  BTFSC  03.2
0889:  GOTO   40B
088A:  XORLW  03
088B:  BTFSC  03.2
088C:  GOTO   4E7
088D:  GOTO   59E
....................  
.................... 			case 0:  
.................... 				lecture_temp(); 
.................... 				break; 
*
094E:  GOTO   59F
....................  
.................... 			case 1: 
.................... 				lecture_light(); 
.................... 				break; 
*
09CF:  GOTO   59F
....................  
.................... 			case 2: 
.................... 				Lecture_acc(); 
.................... 				break; 
*
0AF6:  GOTO   59F
....................  
.................... 			case 3: 
.................... 				Lecture_SRF02(); 
.................... 				break; 
*
0B75:  GOTO   59F
....................  
.................... 			case 4: 
.................... 				lecture_boussole(); 
.................... 				break; 
*
0C0A:  GOTO   59F
....................  
.................... 			case 5: 
.................... 				lecture_adc(); 
.................... 				break; 
*
0CE6:  GOTO   59F
....................  
.................... 			case 6: 
.................... 				lecture_port(); 
.................... 				break; 
*
0D9D:  GOTO   59F
....................  
....................  
.................... 			default : 
.................... 				break; 
0D9E:  GOTO   59F
.................... 		} 
.................... } 
0D9F:  BSF    0A.3
0DA0:  BCF    0A.4
0DA1:  GOTO   5FE (RETURN)
....................  
.................... //-------------------------xxx------------------------ 
.................... void main() { 
0DA2:  CLRF   04
0DA3:  BCF    03.7
0DA4:  MOVLW  1F
0DA5:  ANDWF  03,F
0DA6:  BSF    03.5
0DA7:  BSF    03.6
0DA8:  BSF    07.3
0DA9:  MOVLW  56
0DAA:  BCF    03.6
0DAB:  MOVWF  19
0DAC:  MOVLW  00
0DAD:  MOVWF  1A
0DAE:  MOVLW  A6
0DAF:  MOVWF  18
0DB0:  MOVLW  90
0DB1:  BCF    03.5
0DB2:  MOVWF  18
0DB3:  BSF    03.5
0DB4:  BSF    03.6
0DB5:  MOVF   09,W
0DB6:  ANDLW  C0
0DB7:  MOVWF  09
0DB8:  BCF    03.6
0DB9:  BCF    1F.4
0DBA:  BCF    1F.5
0DBB:  MOVLW  00
0DBC:  BSF    03.6
0DBD:  MOVWF  08
0DBE:  BCF    03.5
0DBF:  CLRF   07
0DC0:  CLRF   08
0DC1:  CLRF   09
0DC2:  BSF    03.5
0DC3:  BCF    03.6
0DC4:  CLRF   17
0DC5:  BSF    03.6
0DC6:  CLRF   05
....................  
.................... 		initialisation(); 
*
0DCD:  BCF    0A.3
0DCE:  GOTO   215
0DCF:  BSF    0A.3
.................... 		x=0; 
0DD0:  CLRF   31
.................... 		flagp=false; 
0DD1:  BCF    32.0
.................... 		while(true) { 
.................... 			if (input(bluethoot)) {							// RF bluetooth actif ? 
0DD2:  BSF    03.5
0DD3:  BSF    05.4
0DD4:  BCF    03.5
0DD5:  BTFSS  05.4
0DD6:  GOTO   609
.................... 				lcd_putc("\fBluetooth ON."); 
0DD7:  CLRF   33
0DD8:  MOVF   33,W
0DD9:  BCF    0A.3
0DDA:  CALL   10F
0DDB:  BSF    0A.3
0DDC:  IORLW  00
0DDD:  BTFSC  03.2
0DDE:  GOTO   5E5
0DDF:  INCF   33,F
0DE0:  MOVWF  50
0DE1:  BCF    0A.3
0DE2:  CALL   1C1
0DE3:  BSF    0A.3
0DE4:  GOTO   5D8
.................... 				flagp=false; 
0DE5:  BCF    32.0
.................... 				delay_ms(100); 
0DE6:  MOVLW  64
0DE7:  MOVWF  51
0DE8:  BCF    0A.3
0DE9:  CALL   185
0DEA:  BSF    0A.3
.................... 				while (input(bluethoot))					// tant que Bluetooth actif 
.................... 				{ 					 
0DEB:  BSF    03.5
0DEC:  BSF    05.4
0DED:  BCF    03.5
0DEE:  BTFSS  05.4
0DEF:  GOTO   608
.................... 					x=(x+1) % 7; 
0DF0:  MOVLW  01
0DF1:  ADDWF  31,W
0DF2:  MOVWF  34
0DF3:  MOVWF  35
0DF4:  MOVLW  07
0DF5:  MOVWF  36
0DF6:  BCF    0A.3
0DF7:  GOTO   296
0DF8:  BSF    0A.3
0DF9:  MOVF   77,W
0DFA:  MOVWF  31
.................... 					lect_capteurs(x); 
0DFB:  MOVF   31,W
0DFC:  MOVWF  33
0DFD:  GOTO   077
.................... 					delay_ms(temps); 
0DFE:  MOVLW  04
0DFF:  MOVWF  33
0E00:  MOVLW  FA
0E01:  MOVWF  51
0E02:  BCF    0A.3
0E03:  CALL   185
0E04:  BSF    0A.3
0E05:  DECFSZ 33,F
0E06:  GOTO   600
.................... 				} 
0E07:  GOTO   5EB
.................... 			} 
.................... 			else if (!flagp) {  
0E08:  GOTO   61A
0E09:  BTFSC  32.0
0E0A:  GOTO   61A
.................... 				lcd_putc("\fBluetooth OFF."); 
0E0B:  CLRF   33
0E0C:  MOVF   33,W
0E0D:  BCF    0A.3
0E0E:  CALL   122
0E0F:  BSF    0A.3
0E10:  IORLW  00
0E11:  BTFSC  03.2
0E12:  GOTO   619
0E13:  INCF   33,F
0E14:  MOVWF  50
0E15:  BCF    0A.3
0E16:  CALL   1C1
0E17:  BSF    0A.3
0E18:  GOTO   60C
.................... 				flagp=true; 
0E19:  BSF    32.0
.................... 			} 
.................... 		} 
0E1A:  GOTO   5D2
.................... } 
0E1B:  SLEEP

Configuration Fuses:
   Word  1: 2CF2   HS NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   NOWRT BORV40
